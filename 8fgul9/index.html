<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>IO多路复用机制详解 | 后端技术栈笔记</title>
    <meta name="generator" content="VuePress 1.9.7">
    <script src="/note-pages//s0.pstatp.com/cdn/expire-1-M/jquery/3.4.0/jquery.min.js"></script>
    <script src="/note-pages//s0.pstatp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.js"></script>
    <link rel="stylesheet" href="/note-pages//s0.pstatp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.css">
    <meta name="description" content="BackEnd Notes">
    
    <link rel="preload" href="/note-pages/assets/css/0.styles.167a34c7.css" as="style"><link rel="preload" href="/note-pages/assets/js/app.05dcbd87.js" as="script"><link rel="preload" href="/note-pages/assets/js/3.4a2f67fd.js" as="script"><link rel="preload" href="/note-pages/assets/js/2.ab82720e.js" as="script"><link rel="preload" href="/note-pages/assets/js/32.1ffdceaf.js" as="script"><link rel="prefetch" href="/note-pages/assets/js/10.e11a80d9.js"><link rel="prefetch" href="/note-pages/assets/js/100.489cf69a.js"><link rel="prefetch" href="/note-pages/assets/js/101.560e37ea.js"><link rel="prefetch" href="/note-pages/assets/js/102.baaa4f6a.js"><link rel="prefetch" href="/note-pages/assets/js/103.262b6423.js"><link rel="prefetch" href="/note-pages/assets/js/104.ac33d7ce.js"><link rel="prefetch" href="/note-pages/assets/js/105.5e6ce18f.js"><link rel="prefetch" href="/note-pages/assets/js/106.a69322ef.js"><link rel="prefetch" href="/note-pages/assets/js/107.6cdb78ee.js"><link rel="prefetch" href="/note-pages/assets/js/108.1d720289.js"><link rel="prefetch" href="/note-pages/assets/js/109.58f7297c.js"><link rel="prefetch" href="/note-pages/assets/js/11.241a46da.js"><link rel="prefetch" href="/note-pages/assets/js/110.9cef761d.js"><link rel="prefetch" href="/note-pages/assets/js/111.c782138c.js"><link rel="prefetch" href="/note-pages/assets/js/112.40cb3b1a.js"><link rel="prefetch" href="/note-pages/assets/js/113.c367e40a.js"><link rel="prefetch" href="/note-pages/assets/js/114.a4a75db5.js"><link rel="prefetch" href="/note-pages/assets/js/115.a73cd469.js"><link rel="prefetch" href="/note-pages/assets/js/116.ad853155.js"><link rel="prefetch" href="/note-pages/assets/js/117.a82b2649.js"><link rel="prefetch" href="/note-pages/assets/js/118.8f896dd0.js"><link rel="prefetch" href="/note-pages/assets/js/119.374482b1.js"><link rel="prefetch" href="/note-pages/assets/js/12.ebe220d5.js"><link rel="prefetch" href="/note-pages/assets/js/120.89698284.js"><link rel="prefetch" href="/note-pages/assets/js/121.cbe50685.js"><link rel="prefetch" href="/note-pages/assets/js/122.7de2ac51.js"><link rel="prefetch" href="/note-pages/assets/js/123.a2d16009.js"><link rel="prefetch" href="/note-pages/assets/js/124.e1ba7cbe.js"><link rel="prefetch" href="/note-pages/assets/js/125.4e1e6d6a.js"><link rel="prefetch" href="/note-pages/assets/js/126.3db22af3.js"><link rel="prefetch" href="/note-pages/assets/js/127.937f4ffc.js"><link rel="prefetch" href="/note-pages/assets/js/128.0bad2e20.js"><link rel="prefetch" href="/note-pages/assets/js/129.75a99d25.js"><link rel="prefetch" href="/note-pages/assets/js/13.5ee7bef5.js"><link rel="prefetch" href="/note-pages/assets/js/130.599b6d3d.js"><link rel="prefetch" href="/note-pages/assets/js/131.687214bf.js"><link rel="prefetch" href="/note-pages/assets/js/132.8295c067.js"><link rel="prefetch" href="/note-pages/assets/js/133.854d61c0.js"><link rel="prefetch" href="/note-pages/assets/js/134.f3fc20e1.js"><link rel="prefetch" href="/note-pages/assets/js/135.2a5a690d.js"><link rel="prefetch" href="/note-pages/assets/js/136.6ba30378.js"><link rel="prefetch" href="/note-pages/assets/js/137.80d7c511.js"><link rel="prefetch" href="/note-pages/assets/js/138.0a25898e.js"><link rel="prefetch" href="/note-pages/assets/js/139.fb3c377f.js"><link rel="prefetch" href="/note-pages/assets/js/14.a561f8b3.js"><link rel="prefetch" href="/note-pages/assets/js/140.cbfdbe32.js"><link rel="prefetch" href="/note-pages/assets/js/141.c09f054f.js"><link rel="prefetch" href="/note-pages/assets/js/142.723bd973.js"><link rel="prefetch" href="/note-pages/assets/js/143.b31785f9.js"><link rel="prefetch" href="/note-pages/assets/js/144.69d3d121.js"><link rel="prefetch" href="/note-pages/assets/js/145.c4ee6aa0.js"><link rel="prefetch" href="/note-pages/assets/js/146.7f836a1c.js"><link rel="prefetch" href="/note-pages/assets/js/147.d4a57976.js"><link rel="prefetch" href="/note-pages/assets/js/148.b15e75eb.js"><link rel="prefetch" href="/note-pages/assets/js/149.94085ddc.js"><link rel="prefetch" href="/note-pages/assets/js/15.4ed118f1.js"><link rel="prefetch" href="/note-pages/assets/js/150.6751d41b.js"><link rel="prefetch" href="/note-pages/assets/js/151.bd60e322.js"><link rel="prefetch" href="/note-pages/assets/js/152.15caf78f.js"><link rel="prefetch" href="/note-pages/assets/js/153.131128fc.js"><link rel="prefetch" href="/note-pages/assets/js/154.b8ee2e7d.js"><link rel="prefetch" href="/note-pages/assets/js/155.8fa1e2e0.js"><link rel="prefetch" href="/note-pages/assets/js/156.25e2a796.js"><link rel="prefetch" href="/note-pages/assets/js/157.7137c9c3.js"><link rel="prefetch" href="/note-pages/assets/js/158.fdc18c40.js"><link rel="prefetch" href="/note-pages/assets/js/159.0dadb745.js"><link rel="prefetch" href="/note-pages/assets/js/16.818fc8bf.js"><link rel="prefetch" href="/note-pages/assets/js/160.05f7541c.js"><link rel="prefetch" href="/note-pages/assets/js/161.2a8c62a2.js"><link rel="prefetch" href="/note-pages/assets/js/162.5b9983b7.js"><link rel="prefetch" href="/note-pages/assets/js/163.b51a5538.js"><link rel="prefetch" href="/note-pages/assets/js/164.06c9f20a.js"><link rel="prefetch" href="/note-pages/assets/js/165.c25063f4.js"><link rel="prefetch" href="/note-pages/assets/js/166.6c570da5.js"><link rel="prefetch" href="/note-pages/assets/js/167.12fb6fb6.js"><link rel="prefetch" href="/note-pages/assets/js/168.d7dd27bc.js"><link rel="prefetch" href="/note-pages/assets/js/169.27f575fe.js"><link rel="prefetch" href="/note-pages/assets/js/17.9daf0c47.js"><link rel="prefetch" href="/note-pages/assets/js/170.ba4295ef.js"><link rel="prefetch" href="/note-pages/assets/js/171.3fb54078.js"><link rel="prefetch" href="/note-pages/assets/js/18.086ed162.js"><link rel="prefetch" href="/note-pages/assets/js/19.adca670c.js"><link rel="prefetch" href="/note-pages/assets/js/20.2e9ff004.js"><link rel="prefetch" href="/note-pages/assets/js/21.07830947.js"><link rel="prefetch" href="/note-pages/assets/js/22.609929cb.js"><link rel="prefetch" href="/note-pages/assets/js/23.d83b832f.js"><link rel="prefetch" href="/note-pages/assets/js/24.592e8014.js"><link rel="prefetch" href="/note-pages/assets/js/25.9d28bb6f.js"><link rel="prefetch" href="/note-pages/assets/js/26.fd4195d5.js"><link rel="prefetch" href="/note-pages/assets/js/27.ca60e875.js"><link rel="prefetch" href="/note-pages/assets/js/28.c2cd75e6.js"><link rel="prefetch" href="/note-pages/assets/js/29.4213d132.js"><link rel="prefetch" href="/note-pages/assets/js/30.c6ee0ead.js"><link rel="prefetch" href="/note-pages/assets/js/31.eea6a542.js"><link rel="prefetch" href="/note-pages/assets/js/33.0425748b.js"><link rel="prefetch" href="/note-pages/assets/js/34.5dd0d81d.js"><link rel="prefetch" href="/note-pages/assets/js/35.773df14e.js"><link rel="prefetch" href="/note-pages/assets/js/36.5db32ea2.js"><link rel="prefetch" href="/note-pages/assets/js/37.1106162c.js"><link rel="prefetch" href="/note-pages/assets/js/38.793ba7d0.js"><link rel="prefetch" href="/note-pages/assets/js/39.488fb9a5.js"><link rel="prefetch" href="/note-pages/assets/js/4.550e6883.js"><link rel="prefetch" href="/note-pages/assets/js/40.9c05b0ae.js"><link rel="prefetch" href="/note-pages/assets/js/41.ae198526.js"><link rel="prefetch" href="/note-pages/assets/js/42.d815456e.js"><link rel="prefetch" href="/note-pages/assets/js/43.1808aff8.js"><link rel="prefetch" href="/note-pages/assets/js/44.c26d9bde.js"><link rel="prefetch" href="/note-pages/assets/js/45.fae5f755.js"><link rel="prefetch" href="/note-pages/assets/js/46.703057c9.js"><link rel="prefetch" href="/note-pages/assets/js/47.ed3a23ce.js"><link rel="prefetch" href="/note-pages/assets/js/48.c5a46ee8.js"><link rel="prefetch" href="/note-pages/assets/js/49.b04c1681.js"><link rel="prefetch" href="/note-pages/assets/js/5.869d288f.js"><link rel="prefetch" href="/note-pages/assets/js/50.249fc2a7.js"><link rel="prefetch" href="/note-pages/assets/js/51.cab74632.js"><link rel="prefetch" href="/note-pages/assets/js/52.e2f231b3.js"><link rel="prefetch" href="/note-pages/assets/js/53.6241e308.js"><link rel="prefetch" href="/note-pages/assets/js/54.7d29c5c0.js"><link rel="prefetch" href="/note-pages/assets/js/55.a9050f95.js"><link rel="prefetch" href="/note-pages/assets/js/56.75828a09.js"><link rel="prefetch" href="/note-pages/assets/js/57.b3f75d67.js"><link rel="prefetch" href="/note-pages/assets/js/58.0cf3bd1c.js"><link rel="prefetch" href="/note-pages/assets/js/59.19f18f1f.js"><link rel="prefetch" href="/note-pages/assets/js/6.d879438f.js"><link rel="prefetch" href="/note-pages/assets/js/60.61940d92.js"><link rel="prefetch" href="/note-pages/assets/js/61.bc890bb0.js"><link rel="prefetch" href="/note-pages/assets/js/62.f487437c.js"><link rel="prefetch" href="/note-pages/assets/js/63.4a91369b.js"><link rel="prefetch" href="/note-pages/assets/js/64.1b0770e4.js"><link rel="prefetch" href="/note-pages/assets/js/65.b56e2b22.js"><link rel="prefetch" href="/note-pages/assets/js/66.dd49594c.js"><link rel="prefetch" href="/note-pages/assets/js/67.22efede4.js"><link rel="prefetch" href="/note-pages/assets/js/68.0d22a8a4.js"><link rel="prefetch" href="/note-pages/assets/js/69.aec9bfeb.js"><link rel="prefetch" href="/note-pages/assets/js/7.e3626849.js"><link rel="prefetch" href="/note-pages/assets/js/70.0c53c20d.js"><link rel="prefetch" href="/note-pages/assets/js/71.6d6db7d6.js"><link rel="prefetch" href="/note-pages/assets/js/72.fdcfb985.js"><link rel="prefetch" href="/note-pages/assets/js/73.a390b48d.js"><link rel="prefetch" href="/note-pages/assets/js/74.e817987f.js"><link rel="prefetch" href="/note-pages/assets/js/75.f144cf4f.js"><link rel="prefetch" href="/note-pages/assets/js/76.7be2f5f1.js"><link rel="prefetch" href="/note-pages/assets/js/77.6568d596.js"><link rel="prefetch" href="/note-pages/assets/js/78.4ff63ca8.js"><link rel="prefetch" href="/note-pages/assets/js/79.daaf791e.js"><link rel="prefetch" href="/note-pages/assets/js/8.f9f716a1.js"><link rel="prefetch" href="/note-pages/assets/js/80.a0605696.js"><link rel="prefetch" href="/note-pages/assets/js/81.ecb125f5.js"><link rel="prefetch" href="/note-pages/assets/js/82.b64b1c42.js"><link rel="prefetch" href="/note-pages/assets/js/83.d13b7f19.js"><link rel="prefetch" href="/note-pages/assets/js/84.c584da75.js"><link rel="prefetch" href="/note-pages/assets/js/85.7992353f.js"><link rel="prefetch" href="/note-pages/assets/js/86.17ad6399.js"><link rel="prefetch" href="/note-pages/assets/js/87.289f9f2f.js"><link rel="prefetch" href="/note-pages/assets/js/88.3496d6e2.js"><link rel="prefetch" href="/note-pages/assets/js/89.0d0c778d.js"><link rel="prefetch" href="/note-pages/assets/js/9.3209071f.js"><link rel="prefetch" href="/note-pages/assets/js/90.245b9fda.js"><link rel="prefetch" href="/note-pages/assets/js/91.806af5f2.js"><link rel="prefetch" href="/note-pages/assets/js/92.8a10f401.js"><link rel="prefetch" href="/note-pages/assets/js/93.ea90ae18.js"><link rel="prefetch" href="/note-pages/assets/js/94.98cc66ef.js"><link rel="prefetch" href="/note-pages/assets/js/95.836e96c5.js"><link rel="prefetch" href="/note-pages/assets/js/96.d4dd3eee.js"><link rel="prefetch" href="/note-pages/assets/js/97.e4275cb9.js"><link rel="prefetch" href="/note-pages/assets/js/98.0e320d92.js"><link rel="prefetch" href="/note-pages/assets/js/99.e6f77650.js">
    <link rel="stylesheet" href="/note-pages/assets/css/0.styles.167a34c7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/note-pages/" class="home-link router-link-active"><!----> <span class="site-name">后端技术栈笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/note-pages/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础知识" class="dropdown-title"><span class="title">基础知识</span> <span class="arrow down"></span></button> <button type="button" aria-label="基础知识" class="mobile-dropdown-title"><span class="title">基础知识</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          算法
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/algorithm/5e022a/" class="nav-link">
  算法
</a></li></ul></li><li class="dropdown-item"><h4>
          计算机网络
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/network/a918ca/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-subitem"><a href="/note-pages/http/" class="nav-link">
  HTTP
</a></li><li class="dropdown-subitem"><a href="/note-pages/tcp-ip/" class="nav-link">
  TCP/IP
</a></li><li class="dropdown-subitem"><a href="/note-pages/socket/" class="nav-link">
  Socket
</a></li></ul></li><li class="dropdown-item"><h4>
          操作系统
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/operating-system/knuk3x/" class="nav-link">
  操作系统
</a></li><li class="dropdown-subitem"><a href="/note-pages/linux/" class="nav-link">
  Linux
</a></li></ul></li><li class="dropdown-item"><h4>
          其他
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/database-system/fyl5c1/" class="nav-link">
  数据库系统
</a></li><li class="dropdown-subitem"><a href="/note-pages/computer-systems/" class="nav-link">
  计算机系统
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程语言" class="dropdown-title"><span class="title">编程语言</span> <span class="arrow down"></span></button> <button type="button" aria-label="编程语言" class="mobile-dropdown-title"><span class="title">编程语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          Java
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/java/5ddf72/" class="nav-link">
  Java基础
</a></li><li class="dropdown-subitem"><a href="/note-pages/java-collection/" class="nav-link">
  Java集合
</a></li><li class="dropdown-subitem"><a href="/note-pages/java-concurrency/" class="nav-link">
  Java并发
</a></li><li class="dropdown-subitem"><a href="/note-pages/jvm/" class="nav-link">
  JVM
</a></li></ul></li><li class="dropdown-item"><h4>
          C/C++
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/cpp/" class="nav-link">
  C++基础
</a></li></ul></li><li class="dropdown-item"><h4>
          Go
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/go/" class="nav-link">
  Go基础
</a></li></ul></li><li class="dropdown-item"><h4>
          其他
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/assembly/" class="nav-link">
  Assembly
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开发框架" class="dropdown-title"><span class="title">开发框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="开发框架" class="mobile-dropdown-title"><span class="title">开发框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          框架
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/spring/" class="nav-link">
  Spring
</a></li></ul></li><li class="dropdown-item"><h4>
          数据库
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/mysql/1dh29a/" class="nav-link">
  MySQL
</a></li><li class="dropdown-subitem"><a href="/note-pages/redis/" class="nav-link">
  Redis
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="架构设计" class="dropdown-title"><span class="title">架构设计</span> <span class="arrow down"></span></button> <button type="button" aria-label="架构设计" class="mobile-dropdown-title"><span class="title">架构设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          分布式
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/distributed-system/01-理论基础/" class="nav-link">
  分布式系统
</a></li></ul></li><li class="dropdown-item"><h4>
          微服务
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/micro-service-in-action/" class="nav-link">
  微服务实战
</a></li></ul></li><li class="dropdown-item"><h4>
          消息队列
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/kafka/" class="nav-link">
  Kafka
</a></li><li class="dropdown-subitem"><a href="/note-pages/rocket-mq/" class="nav-link">
  RocketMQ
</a></li></ul></li><li class="dropdown-item"><h4>
          注册中心
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/zookeeper/" class="nav-link">
  ZooKeeper
</a></li><li class="dropdown-subitem"><a href="/note-pages/eureka/" class="nav-link">
  Eureka
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开发工具" class="dropdown-title"><span class="title">开发工具</span> <span class="arrow down"></span></button> <button type="button" aria-label="开发工具" class="mobile-dropdown-title"><span class="title">开发工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note-pages/git/" class="nav-link">
  Git
</a></li><li class="dropdown-item"><!----> <a href="/note-pages/docker/34kd5q/" class="nav-link">
  Docker
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="理论方法" class="dropdown-title"><span class="title">理论方法</span> <span class="arrow down"></span></button> <button type="button" aria-label="理论方法" class="mobile-dropdown-title"><span class="title">理论方法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note-pages/design-pattern/" class="nav-link">
  设计模式
</a></li><li class="dropdown-item"><!----> <a href="/note-pages/software-engineering/n4r1lx/" class="nav-link">
  软件工程
</a></li></ul></div></div><div class="nav-item"><a href="/note-pages/interview/f05h67/" class="nav-link">
  面试通关
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/note-pages/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础知识" class="dropdown-title"><span class="title">基础知识</span> <span class="arrow down"></span></button> <button type="button" aria-label="基础知识" class="mobile-dropdown-title"><span class="title">基础知识</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          算法
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/algorithm/5e022a/" class="nav-link">
  算法
</a></li></ul></li><li class="dropdown-item"><h4>
          计算机网络
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/network/a918ca/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-subitem"><a href="/note-pages/http/" class="nav-link">
  HTTP
</a></li><li class="dropdown-subitem"><a href="/note-pages/tcp-ip/" class="nav-link">
  TCP/IP
</a></li><li class="dropdown-subitem"><a href="/note-pages/socket/" class="nav-link">
  Socket
</a></li></ul></li><li class="dropdown-item"><h4>
          操作系统
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/operating-system/knuk3x/" class="nav-link">
  操作系统
</a></li><li class="dropdown-subitem"><a href="/note-pages/linux/" class="nav-link">
  Linux
</a></li></ul></li><li class="dropdown-item"><h4>
          其他
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/database-system/fyl5c1/" class="nav-link">
  数据库系统
</a></li><li class="dropdown-subitem"><a href="/note-pages/computer-systems/" class="nav-link">
  计算机系统
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程语言" class="dropdown-title"><span class="title">编程语言</span> <span class="arrow down"></span></button> <button type="button" aria-label="编程语言" class="mobile-dropdown-title"><span class="title">编程语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          Java
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/java/5ddf72/" class="nav-link">
  Java基础
</a></li><li class="dropdown-subitem"><a href="/note-pages/java-collection/" class="nav-link">
  Java集合
</a></li><li class="dropdown-subitem"><a href="/note-pages/java-concurrency/" class="nav-link">
  Java并发
</a></li><li class="dropdown-subitem"><a href="/note-pages/jvm/" class="nav-link">
  JVM
</a></li></ul></li><li class="dropdown-item"><h4>
          C/C++
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/cpp/" class="nav-link">
  C++基础
</a></li></ul></li><li class="dropdown-item"><h4>
          Go
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/go/" class="nav-link">
  Go基础
</a></li></ul></li><li class="dropdown-item"><h4>
          其他
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/assembly/" class="nav-link">
  Assembly
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开发框架" class="dropdown-title"><span class="title">开发框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="开发框架" class="mobile-dropdown-title"><span class="title">开发框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          框架
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/spring/" class="nav-link">
  Spring
</a></li></ul></li><li class="dropdown-item"><h4>
          数据库
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/mysql/1dh29a/" class="nav-link">
  MySQL
</a></li><li class="dropdown-subitem"><a href="/note-pages/redis/" class="nav-link">
  Redis
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="架构设计" class="dropdown-title"><span class="title">架构设计</span> <span class="arrow down"></span></button> <button type="button" aria-label="架构设计" class="mobile-dropdown-title"><span class="title">架构设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          分布式
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/distributed-system/01-理论基础/" class="nav-link">
  分布式系统
</a></li></ul></li><li class="dropdown-item"><h4>
          微服务
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/micro-service-in-action/" class="nav-link">
  微服务实战
</a></li></ul></li><li class="dropdown-item"><h4>
          消息队列
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/kafka/" class="nav-link">
  Kafka
</a></li><li class="dropdown-subitem"><a href="/note-pages/rocket-mq/" class="nav-link">
  RocketMQ
</a></li></ul></li><li class="dropdown-item"><h4>
          注册中心
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/zookeeper/" class="nav-link">
  ZooKeeper
</a></li><li class="dropdown-subitem"><a href="/note-pages/eureka/" class="nav-link">
  Eureka
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开发工具" class="dropdown-title"><span class="title">开发工具</span> <span class="arrow down"></span></button> <button type="button" aria-label="开发工具" class="mobile-dropdown-title"><span class="title">开发工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note-pages/git/" class="nav-link">
  Git
</a></li><li class="dropdown-item"><!----> <a href="/note-pages/docker/34kd5q/" class="nav-link">
  Docker
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="理论方法" class="dropdown-title"><span class="title">理论方法</span> <span class="arrow down"></span></button> <button type="button" aria-label="理论方法" class="mobile-dropdown-title"><span class="title">理论方法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note-pages/design-pattern/" class="nav-link">
  设计模式
</a></li><li class="dropdown-item"><!----> <a href="/note-pages/software-engineering/n4r1lx/" class="nav-link">
  软件工程
</a></li></ul></div></div><div class="nav-item"><a href="/note-pages/interview/f05h67/" class="nav-link">
  面试通关
</a></div> <!----></nav>  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="io多路复用机制详解"><a href="#io多路复用机制详解" class="header-anchor">#</a> IO多路复用机制详解</h1> <h2 id="常见的io模型"><a href="#常见的io模型" class="header-anchor">#</a> 常见的IO模型</h2> <p>常见的网络 IO 模型分为四种：同步阻塞 IO（Blocking IO, BIO）、同步非阻塞 IO（NIO）、IO 多路复用、异步非阻塞 IO（Async IO，AIO），其中 AIO 为异步 IO，其他都是同步 IO。</p> <h3 id="同步阻塞io-bio"><a href="#同步阻塞io-bio" class="header-anchor">#</a> 同步阻塞IO（BIO）</h3> <p>同步阻塞 IO：在线程处理过程中，如果涉及到 IO 操作，那么当前线程会被阻塞，直到 IO 处理完成，线程才接着处理后续流程。如下图，服务器针对客户端的每个 socket 都会分配一个新的线程处理，每个线程的业务处理分 2 步，当步骤 1 处理完成后遇到 IO 操作（比如：加载文件），这时候，当前线程会被阻塞，直到 IO 操作完成，线程才接着处理步骤 2。</p> <p><img src="/note-pages/assets/img/image-20230810122943271.c8f98bb4.png" alt="image-20230810122943271"></p> <p>实际场景：在 Java 中使用线程池的方式去连接数据库，使用的就是同步阻塞 IO 模型。</p> <p>模型缺点：因为每个客户端存都需要一个新的线程，势必导致线程被频繁阻塞和切换带来开销。</p> <h3 id="同步非阻塞-io-nio-new-io"><a href="#同步非阻塞-io-nio-new-io" class="header-anchor">#</a> 同步非阻塞 IO-NIO（New IO）</h3> <p>同步非阻塞 IO：在线程处理过程中，如果涉及到 IO 操作，那么当前的线程不会被阻塞，而是会去处理其他业务代码，然后等过段时间再来查询 IO 交互是否完成。如下图：Buffer 是一个缓冲区，用来缓存读取和写入的数据；Channel 是一个通道，负责后台对接 IO 数据；而 Selector 实现的主要功能，是主动查询哪些通道是处于就绪状态。Selector 复用一个线程，来查询已就绪的通道，这样大大减少 IO 交互引起的频繁切换线程的开销。</p> <p><img src="/note-pages/assets/img/image-20230810122958500.b0967932.png" alt="image-20230810122958500"></p> <p>实际场景：Java NIO 正是基于这个 IO 交互模型，来支撑业务代码实现针对 IO 进行同步非阻塞的设计，从而降低了原来传统的同步阻塞 IO 交互过程中，线程被频繁阻塞和切换带的开销。NIO使用的经典案例是 Netty 框架，Elasticsearch 底层实际上就是采用的这种机制。</p> <h3 id="io-多路复用"><a href="#io-多路复用" class="header-anchor">#</a> IO 多路复用</h3> <p>下文会详细讲解</p> <h3 id="异步非阻塞-io-aio"><a href="#异步非阻塞-io-aio" class="header-anchor">#</a> 异步非阻塞 IO（AIO）</h3> <p>AIO 是异步 IO 的缩写，即 Asynchronized IO。对于 AIO 来说，它不是在 IO 准备好时再通知线程，而是在 IO 操作已经完成后，再给线程发出通知。因此，AIO 是完全不会阻塞的。此时，我们的业务逻辑将变成一个回调函数，等待 IO 操作完成后，由系统自动触发。Netty5 中有使用到 AIO，但是花了大力气，Netty5  性能没能在 Netty5 上有大的飞越。</p> <h2 id="什么是io多路复用"><a href="#什么是io多路复用" class="header-anchor">#</a> 什么是IO多路复用</h2> <p>在 socket 编程中[ClientIp, ClientPort, ServerIp, ServerPort, Protocol] 5 元素可以唯一标识一个 socket 连接，基于这个前提，同一个服务的某个端口 可以和 n 个客户端建立 socket 连接，可以通过下图来大致描述：</p> <p><img src="/note-pages/assets/img/image-20230810123011523.113fa8bb.png" alt="image-20230810123011523"></p> <p>因此，每个客户端和服务器的 socket 连接就可以看做”一路“，多个客户端和该服务器的 socket 连接就是”多路“，从而，IO 多路就是多个 socket 连接上的输入输出流，复用就是多个 socket 连接上的输入输出流由一个线程处理。因此 IO 多路复用可以定义如下：</p> <p>Linux 中的 IO 多路复用是指：<strong>一个线程处理多个 IO 流</strong>。</p> <h2 id="io多路复用的实现机制"><a href="#io多路复用的实现机制" class="header-anchor">#</a> IO多路复用的实现机制</h2> <p>先看下基础 socket 的模型，才能与下文 IO 多路复用机制形成对比，伪代码实现如下</p> <div class="language-c extra-class"><pre class="language-c"><code>listenSocket <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 		<span class="token comment">// 系统调用 socket() 函数，调用创建一个主动 socket</span>
<span class="token function">bind</span><span class="token punctuation">(</span>listenSocket<span class="token punctuation">)</span><span class="token punctuation">;</span>  			<span class="token comment">// 给主动 socket 绑定地址和端口</span>
<span class="token function">listen</span><span class="token punctuation">(</span>listenSocket<span class="token punctuation">)</span><span class="token punctuation">;</span> 			<span class="token comment">// 将默认的主动 socket 转换为服务器使用的被动 socket（监听 socket）</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">{</span> 					<span class="token comment">// 循环监听客户端连接请求</span>
   connSocket <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>listenSocket<span class="token punctuation">)</span><span class="token punctuation">;</span> 	<span class="token comment">// 接受客户端连接，获取已连接 socket</span>
   <span class="token function">recv</span><span class="token punctuation">(</span>connsocket<span class="token punctuation">)</span><span class="token punctuation">;</span> 			<span class="token comment">// 从客户端读取数据，只能同时处理一个客户端</span>
   <span class="token function">send</span><span class="token punctuation">(</span>connsocket<span class="token punctuation">)</span><span class="token punctuation">;</span> 			<span class="token comment">// 给客户端返回数据，只能同时处理一个客户端</span>
<span class="token punctuation">}</span>
</code></pre></div><p>实现网络通信流程如下图</p> <p><img src="/note-pages/assets/img/image-20230810123024837.d087a43a.png" alt="image-20230810123024837"></p> <p>基础 socket 模型，能够实现服务器端和客户端之间的通信，但是程序每调用一次 accept 函数，只能处理一个客户端连接，当有大量的客户端连接时，这种模型处理性能比较差。因此 Linux 提供了高性能的 IO 多路复用机制来解决这种困境。</p> <p>在 Linux 中，操作系统提供了 select、poll 和 epoll 三种 IO 多路复用机制。</p> <h3 id="select-机制"><a href="#select-机制" class="header-anchor">#</a> select 机制</h3> <p>select 机制中一个重要的函数是 select()，函数有 4 个入参，返回一个整数，select() 原型和参数详情如下：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">/**
*  参数说明
*  监听的文件描述符数量__nfds、
*  被监听描述符的三个集合*__readfds,*__writefds和*__exceptfds
*  监听时阻塞等待的超时时长*__timeout
*  返回值：返回一个 socket 对应的文件描述符
*/</span>
<span class="token keyword">int</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token keyword">int</span> __nfds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span> __readfds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span> __writefds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span> __exceptfds<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span> __timeout<span class="token punctuation">)</span>
</code></pre></div><p><strong>select 可以监听多少个 socket</strong></p> <p>1024</p> <p><strong>select 可以监听 socket 的哪些事件</strong></p> <p>select() 函数有三个 fd_set 集合，表示监听的三类事件，分别是 <strong>读数据事件</strong>（readfds 集合）、<strong>写数据事件</strong>（writefds 集合）和 <strong>异常事件</strong>（__exceptfds 集合），当集合为 NULL 时，代表不需要处理对应的事件。</p> <p><strong>select 如何感知已就绪的 fd</strong></p> <p>需要遍历 fd 集合，才能找到就绪的描述符。</p> <p><strong>select 机制如何实现网络通信</strong></p> <p>代码实现</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> sock_fd<span class="token punctuation">,</span>conn_fd<span class="token punctuation">;</span> 			<span class="token comment">// 监听 socket 和已连接 socket 的变量</span>
sock_fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 				<span class="token comment">// 创建 socket</span>
<span class="token function">bind</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">)</span>   				<span class="token comment">// 绑定 socket</span>
<span class="token function">listen</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">)</span> 				<span class="token comment">// 在socket 上进行监听，将 socket 转为监听 socket</span>

fd_set rset<span class="token punctuation">;</span>  					<span class="token comment">// 被监听的描述符集合，关注描述符上的读事件</span>
<span class="token keyword">int</span> max_fd <span class="token operator">=</span> sock_fd

<span class="token comment">// 初始化 rset 数组，使用 FD_ZERO 宏设置每个元素为 0 </span>
<span class="token function">FD_ZERO</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rset<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 使用 FD_SET 宏设置 rset 数组中位置为 sock_fd 的文件描述符为 1，表示需要监听该文件描述符</span>
<span class="token function">FD_SET</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">,</span><span class="token operator">&amp;</span>rset<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 设置超时时间 </span>
<span class="token keyword">struct</span> <span class="token class-name">timeval</span> timeout<span class="token punctuation">;</span>
timeout<span class="token punctuation">.</span>tv_sec <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
timeout<span class="token punctuation">.</span>tv_usec <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 调用 select 函数，检测 rset 数组保存的文件描述符是否已有读事件就绪，返回就绪的文件描述符个数</span>
   n <span class="token operator">=</span> <span class="token function">select</span><span class="token punctuation">(</span>max_fd<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>rset<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
   <span class="token comment">// 调用 FD_ISSET 宏，在 rset 数组中检测 sock_fd 对应的文件描述符是否就绪</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">FD_ISSET</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rset<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 如果 sock_fd 已经就绪，表明已有客户端连接；调用 accept 函数建立连接</span>
       conn_fd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token comment">// 设置 rset 数组中位置为 conn_fd 的文件描述符为 1，表示需要监听该文件描述符</span>
       <span class="token function">FD_SET</span><span class="token punctuation">(</span>conn_fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rset<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token comment">// 依次检查已连接套接字的文件描述符</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxfd<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 调用 FD_ISSET 宏，在 rset 数组中检测文件描述符是否就绪</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">FD_ISSET</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rset<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// 有数据可读，进行读数据处理</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>select 实现网络通信流程如下图：</p> <p><img src="/note-pages/assets/img/image-20230810123050448.ef706407.png" alt="image-20230810123050448"></p> <p><strong>select 函数存在的不足</strong></p> <p>首先，select() 函数对单个进程能监听的文件描述符数量是有限制的，它能监听的文件描述符个数由 __FD_SETSIZE 决定，默认值是 1024。</p> <p>其次，当 select 函数返回后，需要遍历描述符集合，才能找到就绪的描述符。这个遍历过程会产生一定开销，从而降低程序的性能。</p> <h3 id="poll-机制"><a href="#poll-机制" class="header-anchor">#</a> poll 机制</h3> <p>poll 机制的主要函数是 poll() 函数，poll() 函数原型定义：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">/**
* 参数 *__fds 是 pollfd 结构体数组，pollfd 结构体里包含了要监听的描述符，以及该描述符上要监听的事件类型
* 参数 __nfds 表示的是 *__fds 数组的元素个数
*  __timeout 表示 poll 函数阻塞的超时时间
*/</span>
<span class="token keyword">int</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token operator">*</span>__fds<span class="token punctuation">,</span> <span class="token class-name">nfds_t</span> __nfds<span class="token punctuation">,</span> <span class="token keyword">int</span> __timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>pollfd结构体的定义</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>         			<span class="token comment">// 进行监听的文件描述符</span>
    <span class="token keyword">short</span> <span class="token keyword">int</span> events<span class="token punctuation">;</span>       	<span class="token comment">// 要监听的事件类型</span>
    <span class="token keyword">short</span> <span class="token keyword">int</span> revents<span class="token punctuation">;</span>     	 	<span class="token comment">// 实际发生的事件类型</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>pollfd 结构体中包含了三个成员变量 fd、events 和 revents，分别表示要监听的文件描述符、要监听的事件类型和实际发生的事件类型。</p> <p><strong>poll 可以监听多少个 socket</strong></p> <p>自定义，但是需要系统能够承受</p> <p><strong>poll 可以监听 socket 里面的哪些事件</strong></p> <p>pollfd 结构体中要监听和实际发生的事件类型，是通过以下三个宏定义来表示的，分别是 POLLRDNORM、POLLWRNORM 和 POLLERR，它们分别表示可读、可写和错误事件。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POLLRDNORM</span> <span class="token expression"><span class="token number">0x040</span>  		</span><span class="token comment">// 可读事件</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POLLWRNORM</span> <span class="token expression"><span class="token number">0x100</span>  		</span><span class="token comment">// 可写事件</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POLLERR</span> <span class="token expression"><span class="token number">0x008</span>     		</span><span class="token comment">// 错误事件</span></span>
</code></pre></div><p><strong>poll 如何获取已就绪 fd</strong></p> <p>和 select 差不多，需要遍历 fd 集合，才能找到就绪的描述符。</p> <p><strong>poll 机制如何实现网络通信</strong></p> <p>poll 实现代码</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> sock_fd<span class="token punctuation">,</span>conn_fd<span class="token punctuation">;</span> 			<span class="token comment">// 监听套接字和已连接套接字的变量</span>
sock_fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 				<span class="token comment">// 创建套接字</span>
<span class="token function">bind</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">)</span>   				<span class="token comment">// 绑定套接字</span>
<span class="token function">listen</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">)</span> 				<span class="token comment">// 在套接字上进行监听，将套接字转为监听套接字</span>

<span class="token comment">// poll 函数可以监听的文件描述符数量，可以大于 1024</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_OPEN</span> <span class="token expression"><span class="token operator">=</span> <span class="token number">2048</span></span></span>

<span class="token comment">// pollfd 结构体数组，对应文件描述符</span>
<span class="token keyword">struct</span> <span class="token class-name">pollfd</span> client<span class="token punctuation">[</span>MAX_OPEN<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 将创建的监听套接字加入 pollfd 数组，并监听其可读事件</span>
client<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">=</span> sock_fd<span class="token punctuation">;</span>
client<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">=</span> POLLRDNORM<span class="token punctuation">;</span> 
maxfd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token comment">// 初始化 client 数组其他元素为-1</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX_OPEN<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> 

<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 调用 poll 函数，检测 client 数组里的文件描述符是否有就绪的，返回就绪的文件描述符个数</span>
   n <span class="token operator">=</span> <span class="token function">poll</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> maxfd<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment">// 如果监听套件字的文件描述符有可读事件，则进行处理</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>client<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>revents <span class="token operator">&amp;</span> POLLRDNORM<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 有客户端连接；调用 accept 函数建立连接</span>
       conn_fd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

       <span class="token comment">// 保存已建立连接套接字</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX_OPEN<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">=</span> conn_fd<span class="token punctuation">;</span> 			<span class="token comment">// 将已建立连接的文件描述符保存到client数组</span>
           client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">=</span> POLLRDNORM<span class="token punctuation">;</span> 	<span class="token comment">// 设置该文件描述符监听可读事件</span>
           <span class="token keyword">break</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
       maxfd <span class="token operator">=</span> i<span class="token punctuation">;</span> 
   <span class="token punctuation">}</span>
   
   <span class="token comment">// 依次检查已连接套接字的文件描述符</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX_OPEN<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>revents <span class="token operator">&amp;</span> <span class="token punctuation">(</span>POLLRDNORM <span class="token operator">|</span> POLLERR<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">// 有数据可读或发生错误，进行读数据处理或错误处理</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>poll 机制解决了 select 的单个进程最大只能监听 1024 个 socket 的限制，但是并没有解决轮询获取就绪 fd 的问题。</p> <h3 id="epoll-机制"><a href="#epoll-机制" class="header-anchor">#</a> epoll 机制</h3> <p>epoll 是 2.6 内核中提出，使用 epoll_event 结构体来记录待监听的 fd 及其监听的事件类型的。</p> <p>epoll_event 结构体以及 epoll_data 结构体的定义</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">union</span> epoll_data
<span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">int</span> fd<span class="token punctuation">;</span>  <span class="token comment">// 记录文件描述符</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> <span class="token class-name">epoll_data_t</span><span class="token punctuation">;</span>


<span class="token keyword">struct</span> <span class="token class-name">epoll_event</span>
<span class="token punctuation">{</span>
  <span class="token class-name">uint32_t</span> events<span class="token punctuation">;</span>  	<span class="token comment">// epoll 监听的事件类型</span>
  <span class="token class-name">epoll_data_t</span> data<span class="token punctuation">;</span> 	<span class="token comment">// 应用程序数据</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>epoll 的接口比较简单，一共有三个函数：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>创建一个 epoll 的句柄，size 用来告诉内核这个监听的数目一共有多大。epoll 实例内部维护了两个结构，分别是记录要监听的 fd 和已经就绪的 fd，而对于已经就绪的文件描述符来说，它们会被返回给用户程序进行处理。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">epoll_ctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>epoll 的事件注册函数，epoll_ctl 向 epoll 对象中添加、修改或者删除感兴趣的事件，成功返回 0，否则返回 –1。此时需要根据 errno 错误码判断错误类型。它不同于 select() 是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。epoll_wait 方法返回的事件必然是通过 epoll_ctl 添加到 epoll 中的。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> epfd<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span> events<span class="token punctuation">,</span> <span class="token keyword">int</span> maxevents<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>等待事件的产生，类似于 select() 调用。参数 events 用来从内核得到事件的集合，maxevents 是 events 集合的大小，且不大于 epoll_create() 时的 size，参数 timeout 是超时时间（毫秒，0 会立即返回，-1 将不确定或永久阻塞）。函数返回需要处理的事件数目，返回 0 表示已超时，返回 –1 表示错误，需要检查 errno 错误码判断错误类型。</p> <p><strong>关于 epoll 的 ET 和 LT 两种工作模式</strong></p> <p>epoll 有两种工作模式：<strong>水平触发（level trigger, LT）模式</strong> 和 <strong>边缘触发（edge trigger, ET）模式</strong>。</p> <ul><li>LT 模式：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用 epoll_wait 时，会再次响应应用程序并通知此事件。</li> <li>ET 模式：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用 epoll_wait 时，不会再次响应应用程序并通知此事件。</li></ul> <p><strong>epoll 可以监听多少个 socket</strong></p> <p>自定义，但是需要系统能够承受</p> <p><strong>epoll 如何获取已就绪 fd</strong></p> <p>epoll 实例内部维护了两个结构，分别是记录要监听的 fd 和已经就绪的 fd，可以监听就绪的 fd。通过 poll 机制让上层能直接告诉底层，我这个 fd 一旦读写就绪了，请底层硬件（比如网卡）回调的时候自动把这个 fd 相关的结构体放到指定队列中，并且唤醒操作系统。</p> <p><strong>epoll 如何实现网络通信</strong></p> <p>代码实现</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> sock_fd<span class="token punctuation">,</span>conn_fd<span class="token punctuation">;</span> 			<span class="token comment">// 监听 socket 和已连接 socket 的变量</span>
sock_fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 				<span class="token comment">// 创建主动 socket</span>
<span class="token function">bind</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">)</span>   				<span class="token comment">// 绑定 socket</span>
<span class="token function">listen</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">)</span>					<span class="token comment">// 在 socket 进行监听，将 socket 转为监听 socket</span>
    
epfd <span class="token operator">=</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span>EPOLL_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 创建 epoll 实例，</span>
<span class="token comment">// 创建 epoll_event 结构体数组，保存 socket 对应文件描述符和监听事件类型</span>
ep_events <span class="token operator">=</span> <span class="token punctuation">(</span>epoll_event<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>epoll_event<span class="token punctuation">)</span> <span class="token operator">*</span> EPOLL_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 创建 epoll_event 变量</span>
<span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> ee
<span class="token comment">// 监听读事件</span>
ee<span class="token punctuation">.</span>events <span class="token operator">=</span> EPOLLIN<span class="token punctuation">;</span>
<span class="token comment">// 监听的文件描述符是刚创建的监听 socket</span>
ee<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">=</span> sock_fd<span class="token punctuation">;</span>

<span class="token comment">// 将监听 socket 加入到监听列表中    </span>
<span class="token function">epoll_ctl</span><span class="token punctuation">(</span>epfd<span class="token punctuation">,</span> EPOLL_CTL_ADD<span class="token punctuation">,</span> sock_fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ee<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// 等待返回已经就绪的描述符 </span>
   n <span class="token operator">=</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span>epfd<span class="token punctuation">,</span> ep_events<span class="token punctuation">,</span> EPOLL_SIZE<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
   <span class="token comment">// 遍历所有就绪的描述符     </span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">// 如果是监听 socket 描述符就绪，表明有一个新客户端连接到来 </span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>ep_events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">==</span> sock_fd<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
          conn_fd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用 accept() 建立连接</span>
          ee<span class="token punctuation">.</span>events <span class="token operator">=</span> EPOLLIN<span class="token punctuation">;</span>  
          ee<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">=</span> conn_fd<span class="token punctuation">;</span>
          <span class="token comment">// 添加对新创建的已连接 socket 描述符的监听，监听后续在已连接 socket 上的读事件      </span>
          <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>epfd<span class="token punctuation">,</span> EPOLL_CTL_ADD<span class="token punctuation">,</span> conn_fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ee<span class="token punctuation">)</span><span class="token punctuation">;</span> 
                
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 如果是已连接 socket 描述符就绪，则可以读数据</span>
           <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token comment">// 读取数据并处理</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>epoll 进行网络通信的流程如下图：</p> <p><img src="/note-pages/assets/img/image-20230810123103807.6d82c4c5.png" alt="image-20230810123103807"></p> <p>epllo 实现网络通信</p> <p><strong>三者的差异</strong></p> <table><thead><tr><th>IO多路复用机制</th> <th>监听文件描述符最大限制</th> <th>如何查找就绪的文件描述符</th></tr></thead> <tbody><tr><td>select</td> <td>1024</td> <td>遍历文件描述符集合</td></tr> <tr><td>poll</td> <td>自定义</td> <td>遍历文件描述符集合</td></tr> <tr><td>epoll</td> <td>自定义</td> <td>epoll_wait返回就绪的文件描述符</td></tr></tbody></table> <h2 id="使用io多路复用的技术框架"><a href="#使用io多路复用的技术框架" class="header-anchor">#</a> 使用IO多路复用的技术框架</h2> <p><strong>Redis</strong>：Redis 的 ae_select.c 和 ae_epoll.c 文件，就分别使用了 select 和 epoll 这两种机制，实现 IO 多路复用；</p> <p><strong>Nginx</strong>：Nginx 支持 epoll、select、kqueue 等不同操作系统下的各种 IO 多路复用方式；Nginx 是通过 ET 模式使用 epoll。</p> <p><strong>Reactor框架</strong>：无论 C++ 还是 Java，在高性能的网络编程框架的编写上，大多数都是基于 Reactor 模式，其中最为典型的便是 Java 的 Netty 框架，而 Reactor 模式是基于 IO 多路复用的。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main> <aside items="" class="right-sidebar"><div style="margin-left:20px; margin-bottom: 10px; text-align: center; font-size:16px;font-weight:bold;">此页内容</div> <div class="right-sidebar-wrap"><ul class="right-sidebar-links"><li id="tab-item0" class="right-sidebar-item active"><a href="#常见的io模型" class="right-sidebar-item-level2">
          常见的IO模型
        </a></li><li id="tab-item1" class="right-sidebar-item"><a href="#同步阻塞io-bio" class="right-sidebar-item-level3">
          同步阻塞IO（BIO）
        </a></li><li id="tab-item2" class="right-sidebar-item"><a href="#同步非阻塞-io-nio-new-io" class="right-sidebar-item-level3">
          同步非阻塞 IO-NIO（New IO）
        </a></li><li id="tab-item3" class="right-sidebar-item"><a href="#io-多路复用" class="right-sidebar-item-level3">
          IO 多路复用
        </a></li><li id="tab-item4" class="right-sidebar-item"><a href="#异步非阻塞-io-aio" class="right-sidebar-item-level3">
          异步非阻塞 IO（AIO）
        </a></li><li id="tab-item5" class="right-sidebar-item"><a href="#什么是io多路复用" class="right-sidebar-item-level2">
          什么是IO多路复用
        </a></li><li id="tab-item6" class="right-sidebar-item"><a href="#io多路复用的实现机制" class="right-sidebar-item-level2">
          IO多路复用的实现机制
        </a></li><li id="tab-item7" class="right-sidebar-item"><a href="#select-机制" class="right-sidebar-item-level3">
          select 机制
        </a></li><li id="tab-item8" class="right-sidebar-item"><a href="#poll-机制" class="right-sidebar-item-level3">
          poll 机制
        </a></li><li id="tab-item9" class="right-sidebar-item"><a href="#epoll-机制" class="right-sidebar-item-level3">
          epoll 机制
        </a></li><li id="tab-item10" class="right-sidebar-item"><a href="#使用io多路复用的技术框架" class="right-sidebar-item-level2">
          使用IO多路复用的技术框架
        </a></li></ul></div></aside></div><div class="global-ui"></div></div>
    <script src="/note-pages/assets/js/app.05dcbd87.js" defer></script><script src="/note-pages/assets/js/3.4a2f67fd.js" defer></script><script src="/note-pages/assets/js/2.ab82720e.js" defer></script><script src="/note-pages/assets/js/32.1ffdceaf.js" defer></script>
  </body>
</html>
