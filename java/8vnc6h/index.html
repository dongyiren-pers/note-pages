<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第9章 Java 8 的流库 | 后端技术栈笔记</title>
    <meta name="generator" content="VuePress 1.9.7">
    <script src="/note-pages//s0.pstatp.com/cdn/expire-1-M/jquery/3.4.0/jquery.min.js"></script>
    <script src="/note-pages//s0.pstatp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.js"></script>
    <link rel="stylesheet" href="/note-pages//s0.pstatp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.css">
    <meta name="description" content="BackEnd Notes">
    
    <link rel="preload" href="/note-pages/assets/css/0.styles.167a34c7.css" as="style"><link rel="preload" href="/note-pages/assets/js/app.05dcbd87.js" as="script"><link rel="preload" href="/note-pages/assets/js/3.4a2f67fd.js" as="script"><link rel="preload" href="/note-pages/assets/js/2.ab82720e.js" as="script"><link rel="preload" href="/note-pages/assets/js/143.b31785f9.js" as="script"><link rel="prefetch" href="/note-pages/assets/js/10.e11a80d9.js"><link rel="prefetch" href="/note-pages/assets/js/100.489cf69a.js"><link rel="prefetch" href="/note-pages/assets/js/101.560e37ea.js"><link rel="prefetch" href="/note-pages/assets/js/102.baaa4f6a.js"><link rel="prefetch" href="/note-pages/assets/js/103.262b6423.js"><link rel="prefetch" href="/note-pages/assets/js/104.ac33d7ce.js"><link rel="prefetch" href="/note-pages/assets/js/105.5e6ce18f.js"><link rel="prefetch" href="/note-pages/assets/js/106.a69322ef.js"><link rel="prefetch" href="/note-pages/assets/js/107.6cdb78ee.js"><link rel="prefetch" href="/note-pages/assets/js/108.1d720289.js"><link rel="prefetch" href="/note-pages/assets/js/109.58f7297c.js"><link rel="prefetch" href="/note-pages/assets/js/11.241a46da.js"><link rel="prefetch" href="/note-pages/assets/js/110.9cef761d.js"><link rel="prefetch" href="/note-pages/assets/js/111.c782138c.js"><link rel="prefetch" href="/note-pages/assets/js/112.40cb3b1a.js"><link rel="prefetch" href="/note-pages/assets/js/113.c367e40a.js"><link rel="prefetch" href="/note-pages/assets/js/114.a4a75db5.js"><link rel="prefetch" href="/note-pages/assets/js/115.a73cd469.js"><link rel="prefetch" href="/note-pages/assets/js/116.ad853155.js"><link rel="prefetch" href="/note-pages/assets/js/117.a82b2649.js"><link rel="prefetch" href="/note-pages/assets/js/118.8f896dd0.js"><link rel="prefetch" href="/note-pages/assets/js/119.374482b1.js"><link rel="prefetch" href="/note-pages/assets/js/12.ebe220d5.js"><link rel="prefetch" href="/note-pages/assets/js/120.89698284.js"><link rel="prefetch" href="/note-pages/assets/js/121.cbe50685.js"><link rel="prefetch" href="/note-pages/assets/js/122.7de2ac51.js"><link rel="prefetch" href="/note-pages/assets/js/123.a2d16009.js"><link rel="prefetch" href="/note-pages/assets/js/124.e1ba7cbe.js"><link rel="prefetch" href="/note-pages/assets/js/125.4e1e6d6a.js"><link rel="prefetch" href="/note-pages/assets/js/126.3db22af3.js"><link rel="prefetch" href="/note-pages/assets/js/127.937f4ffc.js"><link rel="prefetch" href="/note-pages/assets/js/128.0bad2e20.js"><link rel="prefetch" href="/note-pages/assets/js/129.75a99d25.js"><link rel="prefetch" href="/note-pages/assets/js/13.5ee7bef5.js"><link rel="prefetch" href="/note-pages/assets/js/130.599b6d3d.js"><link rel="prefetch" href="/note-pages/assets/js/131.687214bf.js"><link rel="prefetch" href="/note-pages/assets/js/132.8295c067.js"><link rel="prefetch" href="/note-pages/assets/js/133.854d61c0.js"><link rel="prefetch" href="/note-pages/assets/js/134.f3fc20e1.js"><link rel="prefetch" href="/note-pages/assets/js/135.2a5a690d.js"><link rel="prefetch" href="/note-pages/assets/js/136.6ba30378.js"><link rel="prefetch" href="/note-pages/assets/js/137.80d7c511.js"><link rel="prefetch" href="/note-pages/assets/js/138.0a25898e.js"><link rel="prefetch" href="/note-pages/assets/js/139.fb3c377f.js"><link rel="prefetch" href="/note-pages/assets/js/14.a561f8b3.js"><link rel="prefetch" href="/note-pages/assets/js/140.cbfdbe32.js"><link rel="prefetch" href="/note-pages/assets/js/141.c09f054f.js"><link rel="prefetch" href="/note-pages/assets/js/142.723bd973.js"><link rel="prefetch" href="/note-pages/assets/js/144.69d3d121.js"><link rel="prefetch" href="/note-pages/assets/js/145.c4ee6aa0.js"><link rel="prefetch" href="/note-pages/assets/js/146.7f836a1c.js"><link rel="prefetch" href="/note-pages/assets/js/147.d4a57976.js"><link rel="prefetch" href="/note-pages/assets/js/148.b15e75eb.js"><link rel="prefetch" href="/note-pages/assets/js/149.94085ddc.js"><link rel="prefetch" href="/note-pages/assets/js/15.4ed118f1.js"><link rel="prefetch" href="/note-pages/assets/js/150.6751d41b.js"><link rel="prefetch" href="/note-pages/assets/js/151.bd60e322.js"><link rel="prefetch" href="/note-pages/assets/js/152.15caf78f.js"><link rel="prefetch" href="/note-pages/assets/js/153.131128fc.js"><link rel="prefetch" href="/note-pages/assets/js/154.b8ee2e7d.js"><link rel="prefetch" href="/note-pages/assets/js/155.8fa1e2e0.js"><link rel="prefetch" href="/note-pages/assets/js/156.25e2a796.js"><link rel="prefetch" href="/note-pages/assets/js/157.7137c9c3.js"><link rel="prefetch" href="/note-pages/assets/js/158.fdc18c40.js"><link rel="prefetch" href="/note-pages/assets/js/159.0dadb745.js"><link rel="prefetch" href="/note-pages/assets/js/16.818fc8bf.js"><link rel="prefetch" href="/note-pages/assets/js/160.05f7541c.js"><link rel="prefetch" href="/note-pages/assets/js/161.2a8c62a2.js"><link rel="prefetch" href="/note-pages/assets/js/162.5b9983b7.js"><link rel="prefetch" href="/note-pages/assets/js/163.b51a5538.js"><link rel="prefetch" href="/note-pages/assets/js/164.06c9f20a.js"><link rel="prefetch" href="/note-pages/assets/js/165.c25063f4.js"><link rel="prefetch" href="/note-pages/assets/js/166.6c570da5.js"><link rel="prefetch" href="/note-pages/assets/js/167.12fb6fb6.js"><link rel="prefetch" href="/note-pages/assets/js/168.d7dd27bc.js"><link rel="prefetch" href="/note-pages/assets/js/169.27f575fe.js"><link rel="prefetch" href="/note-pages/assets/js/17.9daf0c47.js"><link rel="prefetch" href="/note-pages/assets/js/170.ba4295ef.js"><link rel="prefetch" href="/note-pages/assets/js/171.3fb54078.js"><link rel="prefetch" href="/note-pages/assets/js/18.086ed162.js"><link rel="prefetch" href="/note-pages/assets/js/19.adca670c.js"><link rel="prefetch" href="/note-pages/assets/js/20.2e9ff004.js"><link rel="prefetch" href="/note-pages/assets/js/21.07830947.js"><link rel="prefetch" href="/note-pages/assets/js/22.609929cb.js"><link rel="prefetch" href="/note-pages/assets/js/23.d83b832f.js"><link rel="prefetch" href="/note-pages/assets/js/24.592e8014.js"><link rel="prefetch" href="/note-pages/assets/js/25.9d28bb6f.js"><link rel="prefetch" href="/note-pages/assets/js/26.fd4195d5.js"><link rel="prefetch" href="/note-pages/assets/js/27.ca60e875.js"><link rel="prefetch" href="/note-pages/assets/js/28.c2cd75e6.js"><link rel="prefetch" href="/note-pages/assets/js/29.4213d132.js"><link rel="prefetch" href="/note-pages/assets/js/30.c6ee0ead.js"><link rel="prefetch" href="/note-pages/assets/js/31.eea6a542.js"><link rel="prefetch" href="/note-pages/assets/js/32.1ffdceaf.js"><link rel="prefetch" href="/note-pages/assets/js/33.0425748b.js"><link rel="prefetch" href="/note-pages/assets/js/34.5dd0d81d.js"><link rel="prefetch" href="/note-pages/assets/js/35.773df14e.js"><link rel="prefetch" href="/note-pages/assets/js/36.5db32ea2.js"><link rel="prefetch" href="/note-pages/assets/js/37.1106162c.js"><link rel="prefetch" href="/note-pages/assets/js/38.793ba7d0.js"><link rel="prefetch" href="/note-pages/assets/js/39.488fb9a5.js"><link rel="prefetch" href="/note-pages/assets/js/4.550e6883.js"><link rel="prefetch" href="/note-pages/assets/js/40.9c05b0ae.js"><link rel="prefetch" href="/note-pages/assets/js/41.ae198526.js"><link rel="prefetch" href="/note-pages/assets/js/42.d815456e.js"><link rel="prefetch" href="/note-pages/assets/js/43.1808aff8.js"><link rel="prefetch" href="/note-pages/assets/js/44.c26d9bde.js"><link rel="prefetch" href="/note-pages/assets/js/45.fae5f755.js"><link rel="prefetch" href="/note-pages/assets/js/46.703057c9.js"><link rel="prefetch" href="/note-pages/assets/js/47.ed3a23ce.js"><link rel="prefetch" href="/note-pages/assets/js/48.c5a46ee8.js"><link rel="prefetch" href="/note-pages/assets/js/49.b04c1681.js"><link rel="prefetch" href="/note-pages/assets/js/5.869d288f.js"><link rel="prefetch" href="/note-pages/assets/js/50.249fc2a7.js"><link rel="prefetch" href="/note-pages/assets/js/51.cab74632.js"><link rel="prefetch" href="/note-pages/assets/js/52.e2f231b3.js"><link rel="prefetch" href="/note-pages/assets/js/53.6241e308.js"><link rel="prefetch" href="/note-pages/assets/js/54.7d29c5c0.js"><link rel="prefetch" href="/note-pages/assets/js/55.a9050f95.js"><link rel="prefetch" href="/note-pages/assets/js/56.75828a09.js"><link rel="prefetch" href="/note-pages/assets/js/57.b3f75d67.js"><link rel="prefetch" href="/note-pages/assets/js/58.0cf3bd1c.js"><link rel="prefetch" href="/note-pages/assets/js/59.19f18f1f.js"><link rel="prefetch" href="/note-pages/assets/js/6.d879438f.js"><link rel="prefetch" href="/note-pages/assets/js/60.61940d92.js"><link rel="prefetch" href="/note-pages/assets/js/61.bc890bb0.js"><link rel="prefetch" href="/note-pages/assets/js/62.f487437c.js"><link rel="prefetch" href="/note-pages/assets/js/63.4a91369b.js"><link rel="prefetch" href="/note-pages/assets/js/64.1b0770e4.js"><link rel="prefetch" href="/note-pages/assets/js/65.b56e2b22.js"><link rel="prefetch" href="/note-pages/assets/js/66.dd49594c.js"><link rel="prefetch" href="/note-pages/assets/js/67.22efede4.js"><link rel="prefetch" href="/note-pages/assets/js/68.0d22a8a4.js"><link rel="prefetch" href="/note-pages/assets/js/69.aec9bfeb.js"><link rel="prefetch" href="/note-pages/assets/js/7.e3626849.js"><link rel="prefetch" href="/note-pages/assets/js/70.0c53c20d.js"><link rel="prefetch" href="/note-pages/assets/js/71.6d6db7d6.js"><link rel="prefetch" href="/note-pages/assets/js/72.fdcfb985.js"><link rel="prefetch" href="/note-pages/assets/js/73.a390b48d.js"><link rel="prefetch" href="/note-pages/assets/js/74.e817987f.js"><link rel="prefetch" href="/note-pages/assets/js/75.f144cf4f.js"><link rel="prefetch" href="/note-pages/assets/js/76.7be2f5f1.js"><link rel="prefetch" href="/note-pages/assets/js/77.6568d596.js"><link rel="prefetch" href="/note-pages/assets/js/78.4ff63ca8.js"><link rel="prefetch" href="/note-pages/assets/js/79.daaf791e.js"><link rel="prefetch" href="/note-pages/assets/js/8.f9f716a1.js"><link rel="prefetch" href="/note-pages/assets/js/80.a0605696.js"><link rel="prefetch" href="/note-pages/assets/js/81.ecb125f5.js"><link rel="prefetch" href="/note-pages/assets/js/82.b64b1c42.js"><link rel="prefetch" href="/note-pages/assets/js/83.d13b7f19.js"><link rel="prefetch" href="/note-pages/assets/js/84.c584da75.js"><link rel="prefetch" href="/note-pages/assets/js/85.7992353f.js"><link rel="prefetch" href="/note-pages/assets/js/86.17ad6399.js"><link rel="prefetch" href="/note-pages/assets/js/87.289f9f2f.js"><link rel="prefetch" href="/note-pages/assets/js/88.3496d6e2.js"><link rel="prefetch" href="/note-pages/assets/js/89.0d0c778d.js"><link rel="prefetch" href="/note-pages/assets/js/9.3209071f.js"><link rel="prefetch" href="/note-pages/assets/js/90.245b9fda.js"><link rel="prefetch" href="/note-pages/assets/js/91.806af5f2.js"><link rel="prefetch" href="/note-pages/assets/js/92.8a10f401.js"><link rel="prefetch" href="/note-pages/assets/js/93.ea90ae18.js"><link rel="prefetch" href="/note-pages/assets/js/94.98cc66ef.js"><link rel="prefetch" href="/note-pages/assets/js/95.836e96c5.js"><link rel="prefetch" href="/note-pages/assets/js/96.d4dd3eee.js"><link rel="prefetch" href="/note-pages/assets/js/97.e4275cb9.js"><link rel="prefetch" href="/note-pages/assets/js/98.0e320d92.js"><link rel="prefetch" href="/note-pages/assets/js/99.e6f77650.js">
    <link rel="stylesheet" href="/note-pages/assets/css/0.styles.167a34c7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/note-pages/" class="home-link router-link-active"><!----> <span class="site-name">后端技术栈笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/note-pages/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础知识" class="dropdown-title"><span class="title">基础知识</span> <span class="arrow down"></span></button> <button type="button" aria-label="基础知识" class="mobile-dropdown-title"><span class="title">基础知识</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          算法
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/algorithm/5e022a/" class="nav-link">
  算法
</a></li></ul></li><li class="dropdown-item"><h4>
          计算机网络
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/network/a918ca/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-subitem"><a href="/note-pages/http/" class="nav-link">
  HTTP
</a></li><li class="dropdown-subitem"><a href="/note-pages/tcp-ip/" class="nav-link">
  TCP/IP
</a></li><li class="dropdown-subitem"><a href="/note-pages/socket/" class="nav-link">
  Socket
</a></li></ul></li><li class="dropdown-item"><h4>
          操作系统
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/operating-system/knuk3x/" class="nav-link">
  操作系统
</a></li><li class="dropdown-subitem"><a href="/note-pages/linux/" class="nav-link">
  Linux
</a></li></ul></li><li class="dropdown-item"><h4>
          其他
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/database-system/fyl5c1/" class="nav-link">
  数据库系统
</a></li><li class="dropdown-subitem"><a href="/note-pages/computer-systems/" class="nav-link">
  计算机系统
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程语言" class="dropdown-title"><span class="title">编程语言</span> <span class="arrow down"></span></button> <button type="button" aria-label="编程语言" class="mobile-dropdown-title"><span class="title">编程语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          Java
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/java/5ddf72/" class="nav-link">
  Java基础
</a></li><li class="dropdown-subitem"><a href="/note-pages/java-collection/" class="nav-link">
  Java集合
</a></li><li class="dropdown-subitem"><a href="/note-pages/java-concurrency/" class="nav-link">
  Java并发
</a></li><li class="dropdown-subitem"><a href="/note-pages/jvm/" class="nav-link">
  JVM
</a></li></ul></li><li class="dropdown-item"><h4>
          C/C++
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/cpp/" class="nav-link">
  C++基础
</a></li></ul></li><li class="dropdown-item"><h4>
          Go
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/go/" class="nav-link">
  Go基础
</a></li></ul></li><li class="dropdown-item"><h4>
          其他
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/assembly/" class="nav-link">
  Assembly
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开发框架" class="dropdown-title"><span class="title">开发框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="开发框架" class="mobile-dropdown-title"><span class="title">开发框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          框架
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/spring/" class="nav-link">
  Spring
</a></li></ul></li><li class="dropdown-item"><h4>
          数据库
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/mysql/1dh29a/" class="nav-link">
  MySQL
</a></li><li class="dropdown-subitem"><a href="/note-pages/redis/" class="nav-link">
  Redis
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="架构设计" class="dropdown-title"><span class="title">架构设计</span> <span class="arrow down"></span></button> <button type="button" aria-label="架构设计" class="mobile-dropdown-title"><span class="title">架构设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          分布式
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/distributed-system/01-理论基础/" class="nav-link">
  分布式系统
</a></li></ul></li><li class="dropdown-item"><h4>
          微服务
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/micro-service-in-action/" class="nav-link">
  微服务实战
</a></li></ul></li><li class="dropdown-item"><h4>
          消息队列
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/kafka/" class="nav-link">
  Kafka
</a></li><li class="dropdown-subitem"><a href="/note-pages/rocket-mq/" class="nav-link">
  RocketMQ
</a></li></ul></li><li class="dropdown-item"><h4>
          注册中心
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/zookeeper/" class="nav-link">
  ZooKeeper
</a></li><li class="dropdown-subitem"><a href="/note-pages/eureka/" class="nav-link">
  Eureka
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开发工具" class="dropdown-title"><span class="title">开发工具</span> <span class="arrow down"></span></button> <button type="button" aria-label="开发工具" class="mobile-dropdown-title"><span class="title">开发工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note-pages/git/" class="nav-link">
  Git
</a></li><li class="dropdown-item"><!----> <a href="/note-pages/docker/34kd5q/" class="nav-link">
  Docker
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="理论方法" class="dropdown-title"><span class="title">理论方法</span> <span class="arrow down"></span></button> <button type="button" aria-label="理论方法" class="mobile-dropdown-title"><span class="title">理论方法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note-pages/design-pattern/" class="nav-link">
  设计模式
</a></li><li class="dropdown-item"><!----> <a href="/note-pages/software-engineering/n4r1lx/" class="nav-link">
  软件工程
</a></li></ul></div></div><div class="nav-item"><a href="/note-pages/interview/f05h67/" class="nav-link">
  面试通关
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/note-pages/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础知识" class="dropdown-title"><span class="title">基础知识</span> <span class="arrow down"></span></button> <button type="button" aria-label="基础知识" class="mobile-dropdown-title"><span class="title">基础知识</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          算法
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/algorithm/5e022a/" class="nav-link">
  算法
</a></li></ul></li><li class="dropdown-item"><h4>
          计算机网络
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/network/a918ca/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-subitem"><a href="/note-pages/http/" class="nav-link">
  HTTP
</a></li><li class="dropdown-subitem"><a href="/note-pages/tcp-ip/" class="nav-link">
  TCP/IP
</a></li><li class="dropdown-subitem"><a href="/note-pages/socket/" class="nav-link">
  Socket
</a></li></ul></li><li class="dropdown-item"><h4>
          操作系统
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/operating-system/knuk3x/" class="nav-link">
  操作系统
</a></li><li class="dropdown-subitem"><a href="/note-pages/linux/" class="nav-link">
  Linux
</a></li></ul></li><li class="dropdown-item"><h4>
          其他
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/database-system/fyl5c1/" class="nav-link">
  数据库系统
</a></li><li class="dropdown-subitem"><a href="/note-pages/computer-systems/" class="nav-link">
  计算机系统
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程语言" class="dropdown-title"><span class="title">编程语言</span> <span class="arrow down"></span></button> <button type="button" aria-label="编程语言" class="mobile-dropdown-title"><span class="title">编程语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          Java
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/java/5ddf72/" class="nav-link">
  Java基础
</a></li><li class="dropdown-subitem"><a href="/note-pages/java-collection/" class="nav-link">
  Java集合
</a></li><li class="dropdown-subitem"><a href="/note-pages/java-concurrency/" class="nav-link">
  Java并发
</a></li><li class="dropdown-subitem"><a href="/note-pages/jvm/" class="nav-link">
  JVM
</a></li></ul></li><li class="dropdown-item"><h4>
          C/C++
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/cpp/" class="nav-link">
  C++基础
</a></li></ul></li><li class="dropdown-item"><h4>
          Go
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/go/" class="nav-link">
  Go基础
</a></li></ul></li><li class="dropdown-item"><h4>
          其他
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/assembly/" class="nav-link">
  Assembly
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开发框架" class="dropdown-title"><span class="title">开发框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="开发框架" class="mobile-dropdown-title"><span class="title">开发框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          框架
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/spring/" class="nav-link">
  Spring
</a></li></ul></li><li class="dropdown-item"><h4>
          数据库
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/mysql/1dh29a/" class="nav-link">
  MySQL
</a></li><li class="dropdown-subitem"><a href="/note-pages/redis/" class="nav-link">
  Redis
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="架构设计" class="dropdown-title"><span class="title">架构设计</span> <span class="arrow down"></span></button> <button type="button" aria-label="架构设计" class="mobile-dropdown-title"><span class="title">架构设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          分布式
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/distributed-system/01-理论基础/" class="nav-link">
  分布式系统
</a></li></ul></li><li class="dropdown-item"><h4>
          微服务
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/micro-service-in-action/" class="nav-link">
  微服务实战
</a></li></ul></li><li class="dropdown-item"><h4>
          消息队列
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/kafka/" class="nav-link">
  Kafka
</a></li><li class="dropdown-subitem"><a href="/note-pages/rocket-mq/" class="nav-link">
  RocketMQ
</a></li></ul></li><li class="dropdown-item"><h4>
          注册中心
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/zookeeper/" class="nav-link">
  ZooKeeper
</a></li><li class="dropdown-subitem"><a href="/note-pages/eureka/" class="nav-link">
  Eureka
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开发工具" class="dropdown-title"><span class="title">开发工具</span> <span class="arrow down"></span></button> <button type="button" aria-label="开发工具" class="mobile-dropdown-title"><span class="title">开发工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note-pages/git/" class="nav-link">
  Git
</a></li><li class="dropdown-item"><!----> <a href="/note-pages/docker/34kd5q/" class="nav-link">
  Docker
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="理论方法" class="dropdown-title"><span class="title">理论方法</span> <span class="arrow down"></span></button> <button type="button" aria-label="理论方法" class="mobile-dropdown-title"><span class="title">理论方法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note-pages/design-pattern/" class="nav-link">
  设计模式
</a></li><li class="dropdown-item"><!----> <a href="/note-pages/software-engineering/n4r1lx/" class="nav-link">
  软件工程
</a></li></ul></div></div><div class="nav-item"><a href="/note-pages/interview/f05h67/" class="nav-link">
  面试通关
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/note-pages/java/5ddf72/" class="sidebar-link">第1章 Java程序设计概述</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf72/#_1-1-java-程序设计平台" class="sidebar-link">1.1 Java 程序设计平台</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf72/#_1-2-java-白皮书-的关键术语" class="sidebar-link">1.2 Java ”白皮书” 的关键术语</a></li></ul></li><li><a href="/note-pages/java/5ddf77/" class="sidebar-link">第2章 Java程序设计基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf77/#_2-1-简单示例" class="sidebar-link">2.1 简单示例</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf77/#_2-2-注释" class="sidebar-link">2.2 注释</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf77/#_2-3-数据类型" class="sidebar-link">2.3 数据类型</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf77/#_2-4-变量" class="sidebar-link">2.4 变量</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf77/#_2-5-运算符" class="sidebar-link">2.5 运算符</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf77/#_2-6-字符串" class="sidebar-link">2.6 字符串</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf77/#_2-7-输入输出" class="sidebar-link">2.7 输入输出</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf77/#_2-8-控制流程" class="sidebar-link">2.8 控制流程</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf77/#_2-9-大数值" class="sidebar-link">2.9 大数值</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf77/#_2-10-数组" class="sidebar-link">2.10 数组</a></li></ul></li><li><a href="/note-pages/java/5ddf78/" class="sidebar-link">第3章 对象与类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf78/#_3-1-面向对象程序设计概述" class="sidebar-link">3.1 面向对象程序设计概述</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf78/#_3-2-使用预定义类" class="sidebar-link">3.2 使用预定义类</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf78/#_3-3-用户自定义类" class="sidebar-link">3.3 用户自定义类</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf78/#_3-4-静态域与静态方法" class="sidebar-link">3.4 静态域与静态方法</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf78/#_3-5-按值调用" class="sidebar-link">3.5 按值调用</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf78/#_3-6-对象构造" class="sidebar-link">3.6 对象构造</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf78/#_3-7-包" class="sidebar-link">3.7 包</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf78/#_3-8-类路径" class="sidebar-link">3.8 类路径</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf78/#_3-9-文档注释" class="sidebar-link">3.9 文档注释</a></li></ul></li><li><a href="/note-pages/java/5ddf79/" class="sidebar-link">第4章 继承与多态</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf79/#_4-1-类、超类和子类" class="sidebar-link">4.1 类、超类和子类</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf79/#_4-2-object-所有类的超类" class="sidebar-link">4.2 Object：所有类的超类</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf79/#_4-3-接口" class="sidebar-link">4.3 接口</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf79/#_4-4-lambda-表达式" class="sidebar-link">4.4 lambda  表达式</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf79/#_4-5-内部类" class="sidebar-link">4.5 内部类</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf79/#_4-6-泛型数组列表" class="sidebar-link">4.6 泛型数组列表</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf79/#_4-7-对象包装器与自动装箱" class="sidebar-link">4.7 对象包装器与自动装箱</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf79/#_4-8-参数数量可变的方法" class="sidebar-link">4.8 参数数量可变的方法</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf79/#_4-9-枚举类" class="sidebar-link">4.9 枚举类</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf79/#_4-10-继承的设计技巧" class="sidebar-link">4.10 继承的设计技巧</a></li></ul></li><li><a href="/note-pages/java/5ddf7a/" class="sidebar-link">第5章 反射机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf7a/#_5-1-class-类" class="sidebar-link">5.1 Class 类</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf7a/#_5-2-利用反射分析类的能力" class="sidebar-link">5.2 利用反射分析类的能力</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf7a/#_5-3-在运行时使用反射分析对象" class="sidebar-link">5.3 在运行时使用反射分析对象</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf7a/#_5-4-使用反射编写泛型数组代码" class="sidebar-link">5.4 使用反射编写泛型数组代码</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf7a/#_5-5-调用任意方法" class="sidebar-link">5.5 调用任意方法</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf7a/#_5-6-代理" class="sidebar-link">5.6 代理</a></li></ul></li><li><a href="/note-pages/java/5ddf7b/" class="sidebar-link">第6章 异常处理和日志</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf7b/#_6-1-异常" class="sidebar-link">6.1 异常</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf7b/#_6-2-捕获异常" class="sidebar-link">6.2 捕获异常</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf7b/#_6-3-断言" class="sidebar-link">6.3 断言</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf7b/#_6-4-日志" class="sidebar-link">6.4 日志</a></li></ul></li><li><a href="/note-pages/java/5ddfa4/" class="sidebar-link">第7章 泛型程序设计</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa4/#_7-1-定义简单泛型类" class="sidebar-link">7.1 定义简单泛型类</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa4/#_7-2-定义泛型方法" class="sidebar-link">7.2 定义泛型方法</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa4/#_7-3-类型变量的限定" class="sidebar-link">7.3 类型变量的限定</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa4/#_7-4-泛型代码和虚拟机" class="sidebar-link">7.4 泛型代码和虚拟机</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa4/#_7-5-约束与局限性" class="sidebar-link">7.5 约束与局限性</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa4/#_7-6-泛型类型的继承规则" class="sidebar-link">7.6 泛型类型的继承规则</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa4/#_7-7-通配符类型" class="sidebar-link">7.7 通配符类型</a></li></ul></li><li><a href="/note-pages/java/5ddfa5/" class="sidebar-link">第8章 集合和算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa5/#_8-1-集合框架" class="sidebar-link">8.1 集合框架</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa5/#_8-2-集合" class="sidebar-link">8.2 集合</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa5/#_8-3-映射" class="sidebar-link">8.3 映射</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa5/#_8-4-视图与包装器" class="sidebar-link">8.4 视图与包装器</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa5/#_8-5-算法" class="sidebar-link">8.5 算法</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa5/#_8-6-遗留的集合" class="sidebar-link">8.6 遗留的集合</a></li></ul></li><li><a href="/note-pages/java/8vnc6h/" aria-current="page" class="active sidebar-link">第9章 Java 8 的流库</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note-pages/java/8vnc6h/#_9-1-从迭代到流的操作" class="sidebar-link">9.1 从迭代到流的操作</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/8vnc6h/#_9-2-流的操作" class="sidebar-link">9.2 流的操作</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/8vnc6h/#_9-3-约简操作" class="sidebar-link">9.3 约简操作</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/8vnc6h/#_9-4-optional-类型" class="sidebar-link">9.4 Optional 类型</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/8vnc6h/#_9-5-收集结果" class="sidebar-link">9.5 收集结果</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/8vnc6h/#_9-6-群组和分区" class="sidebar-link">9.6 群组和分区</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/8vnc6h/#_9-7-基本类型流" class="sidebar-link">9.7 基本类型流</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/8vnc6h/#_9-8-并行流" class="sidebar-link">9.8 并行流</a></li></ul></li><li><a href="/note-pages/java/5ddfa7/" class="sidebar-link">第10章 Java类库</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa7/#_10-1-基础类库" class="sidebar-link">10.1 基础类库</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa7/#_10-2-反射类库" class="sidebar-link">10.2 反射类库</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa7/#_10-3-工具类库" class="sidebar-link">10.3 工具类库</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa7/#_10-4-集合类库" class="sidebar-link">10.4 集合类库</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa7/#_10-5-数学类库" class="sidebar-link">10.5 数学类库</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa7/#_10-6-日志类库" class="sidebar-link">10.6 日志类库</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa7/#_10-7-文本类库" class="sidebar-link">10.7 文本类库</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="第9章-java-8-的流库"><a href="#第9章-java-8-的流库" class="header-anchor">#</a> 第9章 Java 8 的流库</h1> <p>与集合相比，流提供了一种可以让我们在更高的概念级别上指定计算任务的数据视图。通过使用流，我们可以说明想要完成什么任务，而不是说明如何去实现它。我们将操作的调度留给具体实现去解决。</p> <h2 id="_9-1-从迭代到流的操作"><a href="#_9-1-从迭代到流的操作" class="header-anchor">#</a> 9.1 从迭代到流的操作</h2> <p>在处理集合时，我们通常会迭代遍历它的元素，并在每个元素上执行某项操作。例如，假设我们想要对某本书中的所有长单词进行计数。首先，将所有单词放到一个列表中并迭代：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> words <span class="token operator">=</span> <span class="token class-name">List</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>contents<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&quot;\\PL+&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> w <span class="token operator">:</span> words<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>w<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在使用流时， 相同的操作看起来像下面这样:</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">long</span> count <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    	<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>w <span class="token operator">-&gt;</span> w<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">12</span><span class="token punctuation">)</span>
    	<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>循环需要非常详细地指定操作的顺序，而流却能够以其想要的任何方式来调度这些操作，只要结果是正确的即可。</p> <p>仅将 stream 修改为 parallelStream 就可以让流库以并行方式来执行过滤和计数。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">long</span> count <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">parallelStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>w <span class="token operator">-&gt;</span> w<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">12</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>流表面上看起来和集合很类似，都可以让我们转换和获取数据。但是，它们之间存在着显著的差异：</p> <ul><li>流并不存储其元素。这些元素可能存储在底层的集合中，或者是按需生成的。</li> <li>流的操作不会修改其数据源。例如，filter 方法不会从流中移除元素，而是会生成一个新的流，其中不包含被过滤掉的元素。</li> <li>流的操作是尽可能惰性执行的。这意味着直至需要其结果时，操作才会执行。</li></ul> <p>这个工作流是操作流时的典型流程。我们建立了一个包含三个阶段的操作管道：</p> <ul><li>创建一个流。</li> <li>指定将初始流转换为其他流的中间操作，可能包含多个步骤。</li> <li>应用终止操作，从而产生结果。这个操作会强制执行之前的惰性操作。</li></ul> <h2 id="_9-2-流的操作"><a href="#_9-2-流的操作" class="header-anchor">#</a> 9.2 流的操作</h2> <h3 id="流的创建"><a href="#流的创建" class="header-anchor">#</a> 流的创建</h3> <div class="subtitle"><p>将数组转换为流</p></div><p>使用静态的 <strong>Stream.of 方法</strong> 可以将数组转换为一个流：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> words <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>contents<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&quot;\\PL+&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// split returns a String array</span>
</code></pre></div><p>of 方法具有可变长参数，因此我们可以构建具有任意数量引元的流：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> song <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">&quot;gently&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;down&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;the&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot; stream&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="subtitle"><p>创建不包含任何元素的流</p></div><p>使用静态的 <strong>Stream.empty 方法</strong> 可以创建不包含任何元素的流：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> silence <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Generic type &lt;String&gt; is inferred; same as Stream.&lt;String&gt;empty()</span>
</code></pre></div><div class="subtitle"><p>创建无限流</p></div><p>Stream 接口有两个用于创建无限流的静态方法。<strong>generate 方法</strong> 会接受一个不包含任何引元的函数（或者从技术上讲，是一个 Supplier&lt;T&gt; 接口的对象）。我们可以像下面这样获得一个常量值的流：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> echos <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token string">&quot;Echo&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>或者像下面这样获取一个随机数的流：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Double</span><span class="token punctuation">&gt;</span></span> randoms <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token operator">:</span>random<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果要产生像 0 1 2 3 … 这样的序列，可以使用 <strong>iterate 方法</strong>。它会接受一个 “种子” 值，以及一个函数（从技术上讲，是一个 UnaryOperation&lt;T&gt;），并且会反复地将该函数应用到之前的结果上。例如，</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BigInteger</span><span class="token punctuation">&gt;</span></span> integers <span class="token operator">=</span> 
    <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">iterate</span><span class="token punctuation">(</span><span class="token class-name">BigInteger</span><span class="token punctuation">.</span>ZERO<span class="token punctuation">,</span> n <span class="token operator">-&gt;</span> n<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">BigInteger</span><span class="token punctuation">.</span>ONE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>该序列中的第一个元素是种子 Biglnteger.ZERO，第二个元素是 f(seed)，即 1 (作为大整数)，下一个元素是 f(f(seed))，即 2，后续以此类推。</p> <p>如果要产生一个有限序列，则需要添加一个谓词来描述迭代应该如何结束：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">var</span> limit <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BigInteger</span><span class="token punctuation">(</span><span class="token string">&quot;10000000&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">BigInteger</span><span class="token punctuation">&gt;</span></span> integers <span class="token operator">=</span> 
    <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">iterate</span><span class="token punctuation">(</span><span class="token class-name">BigInteger</span><span class="token punctuation">.</span>ZERO<span class="token punctuation">,</span>
                   n <span class="token operator">-&gt;</span> n<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>limit<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">,</span>
                   n <span class="token operator">-&gt;</span> n<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">BigInteger</span><span class="token punctuation">.</span>ONE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>只要该谓词拒绝了某个迭代生成的值，这个流即结束。</p> <div class="subtitle"><p>创建一个非常短的流</p></div><p><strong>Stream.ofNullable 方法</strong> 会用一个对象来创建一个非常短的流。如果该对象为 null，那么这个流的长度就为 0；否则，这个流的长度为1，即只包含该对象。这个方法与 flatMap 相结合时最有用。</p> <blockquote><p><strong>警告</strong>：至关重要的是，在执行流的操作时，我们并没有修改流背后的集合。记住，流并没有收集其数据，数据一直存储在单独的集合中。如果修改了该集合，那么流操作的结果就会变成未定义的。JDK 文档称这种要求为 <strong>不干涉性</strong>。</p></blockquote> <h3 id="filter、map-和-flatmap-方法"><a href="#filter、map-和-flatmap-方法" class="header-anchor">#</a> filter、map 和 flatMap 方法</h3> <div class="subtitle"><p>filter 方法</p></div><p>流的转换会产生一个新的流，它的元素派生自另一个流中的元素。我们已经看到了 filter 转换会产生一个新流，它的元素与某种条件相匹配。下面，我们将一个字符串流转换为只包含长单词的另一个流：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> words <span class="token operator">=</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> longWords <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>w <span class="token operator">-&gt;</span> w<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>filter 的引元是 Predicate&lt;T&gt;，即从 T 到 boolean 的函数。</p> <div class="subtitle"><p>map 方法</p></div><p>如果想要按照某种方式来转换流中的值，可以使用 <strong>map 方法</strong> 并传递执行该转换的函数。例如，我们可以像下面这样将所有单词都转换为小写：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> lowercaseWords <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">:</span>toLowerCase<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="subtitle"><p>flatMap 方法</p></div><p>在使用 map 时，会有一个函数应用到每个元素上，并且其结果是包含了应用该函数后所产生的所有结果的流。现在，假设有一个函数，它返回的不是一个值，而是一个包含众多值的流。以下示例展示的方法会将字符串转换为字符串流，即一个个的编码点：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">codePoints</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> j <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">offsetByCodePoints</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        i <span class="token operator">=</span> j<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个方法可以正确地处理需要用两个 char 值来表示的 Unicode 字符。例如，codePoints(&quot;boat&quot;) 的返回值是流 [&quot;b&quot;,&quot;o&quot;,&quot;a&quot;,&quot;t&quot;]。</p> <p>假设我们将 codePoints 方法映射到一个字符串流上：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Stream</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>w <span class="token operator">-&gt;</span> <span class="token function">codePoints</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>我们会得到一个包含流的流，就像 [... [&quot;y&quot;,&quot;o&quot;,&quot;u&quot;,&quot;r&quot;], [&quot;b&quot;,&quot;o&quot;,&quot;a&quot;,&quot;t&quot;],…] 。为了将其摊平为单个流 [...&quot;y&quot;,&quot;o&quot;,&quot;u&quot;,&quot;r&quot;,&quot;b&quot;,&quot;o&quot;,&quot;a&quot;,&quot;t&quot;,...] 可以使用 <strong>flatMap方法</strong> 而不是 map 方法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> flatResult <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>w <span class="token operator">-&gt;</span> <span class="token function">codePoints</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Calls codePoints on each word and flattens the results</span>
</code></pre></div><h3 id="抽取子流和组合流"><a href="#抽取子流和组合流" class="header-anchor">#</a> 抽取子流和组合流</h3> <div class="subtitle"><p>抽取子流</p></div><p><strong>stream.limit(n) 方法</strong>：返回一个新的流，它在 n 个元素之后结束（如果原来的流比 n 短，那么就会在该流结束时结束）。这个方法对于裁剪无限流的尺寸特别有用。例如，</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Double</span><span class="token punctuation">&gt;</span></span> randoms <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token operator">:</span>random<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
</code></pre></div><p>会产生一个包含 100 个随机数的流。</p> <p><strong>stream.skip(n) 方法</strong> 正好相反：它会丢弃前 n 个元素。</p> <p><strong>stream.takeWhile(predicate) 方法</strong>：如果此流是有序的，则返回一个从该流中提取的与给定谓词匹配的元素的最长前缀组成的流。如果该流是无序的，则返回一个由从该流中提取的与给定谓词匹配的元素子集组成的流。</p> <p><strong>stream.dropWhile(predicate) 方法</strong>：如果此流是有序的，则在删除与给定谓词匹配的元素的最长前缀后，返回由此流的其余元素组成的流。如果该流是无序的，则在删除与给定谓词匹配的元素子集后，返回由该流的剩余元素组成的流。</p> <div class="subtitle"><p>组合流</p></div><p>我们可以用 Stream 类的静态 <strong>concat 方法</strong> 将两个流连接起来：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> combined <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token function">codePoints</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">codePoints</span><span class="token punctuation">(</span><span class="token string">&quot;World&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Yields the stream [&quot;H&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;,&quot;W&quot;,&quot;o&quot;,&quot;r&quot;,&quot;l&quot;,&quot;d&quot;]</span>
</code></pre></div><h3 id="其他的流转换"><a href="#其他的流转换" class="header-anchor">#</a> 其他的流转换</h3> <div class="subtitle"><p>distinct 方法</p></div><p><strong>distinct 方法</strong> 会返回一个流，它的元素是从原有流中产生的，即原来的元素按照同样的顺序剔除重复元素后产生的。这些重复元素并不一定是毗邻的。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> uniqueWords
    <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">&quot;merrily&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;merrily&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;merrily&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;gently&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Only one &quot;merrily&quot; is retained</span>
</code></pre></div><div class="subtitle"><p>sorted 方法</p></div><p>对于流的排序，有多种 <strong>sorted 方法</strong> 的变体可用。其中一种用于操作 Comparable 元素的流，而另一种可以接受一个 Comparator。下面，我们对字符串排序，使得最长的字符串排在最前面：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> longestFirst
    <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">:</span>length<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>与所有的流转换一样，sorted 方法会产生一个新的流，它的元素是原有流中按照顺序排列的元素。</p> <p>当然，在对集合排序时可以不使用流。但当排序处理是流管道的一部分时，sorted 方法就会显得很有用。</p> <div class="subtitle"><p>peek 方法</p></div><p><strong>peek 方法</strong> 会产生另一个流，它的元素与原来流中的元素相同，但是在每次获取一个元素时，都会调用一次函数，这对于调试来说很方便：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> powers <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">iterate</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> p <span class="token operator">-&gt;</span> p <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span>e <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Fetching&quot;</span> <span class="token operator">+</span> e<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>当实际访问一个元素时，就会打印出来一条消息。通过这种方式，你可以验证 iterate 返回的无限流是被惰性处理的。</p> <h2 id="_9-3-约简操作"><a href="#_9-3-约简操作" class="header-anchor">#</a> 9.3 约简操作</h2> <p>约简是一种终结操作（terminal operation），它们会将流约简为可以在程序中使用的非流值。</p> <h3 id="简单约简"><a href="#简单约简" class="header-anchor">#</a> 简单约简</h3> <p>你已经看到过一种简单约简：<strong>count 方法</strong> 会返回流中元素的数量。</p> <p>其他的简单约简还有 <strong>max</strong> 和 <strong>min</strong>，它们分别返回最大值和最小值：这里要稍作解释，这些方法返回的是一个类型 Optional&lt;T&gt; 的值，它要么在其中包装了答案，要么表示没有任何值（因为流碰巧为空）。在过去， 碰到这种情况返回 null 是很常见的，但是这样做会导致在未做完备测试的程序中产生空指针异常。 Optional 类型是一种表示缺少返回值的更好的方式。</p> <p>示例展示了如何获得流中的最大值：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> largest <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">:</span>compareToIgnoreCase<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;largest:&quot;</span> <span class="token operator">+</span> largest<span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>findFirst 方法</strong> 返回的是非空集合中的第一个值。它通常在与 filter 组合使用时很有用。例如，下面展示了如何找到第一个以字母 Q 开头的单词，前提是存在这样的单词：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> startsWithQ
    <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>s <span class="token operator">-&gt;</span> s<span class="token punctuation">.</span><span class="token function">startswith</span><span class="token punctuation">(</span><span class="token string">&quot;O&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果不强调使用第一个匹配，而是使用任意的匹配都可以，那么就可以使用 <strong>findAny 方法</strong>。这个方法在并行处理流时很有效，因为流可以报告任何它找到的匹配而不是被限制为必须报告第一个匹配。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> startsWithQ
    <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">parallel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filte</span><span class="token punctuation">(</span>s <span class="token operator">-&gt;</span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">&quot;Q&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findAny</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果只想知道是否存在匹配，那么可以使用 <strong>anyMatch 方法</strong>。这个方法会接受一个断言引元，因此不需要使用 filter。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">boolean</span> aWordStartswithQ
    <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">parallel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">anyMatch</span><span class="token punctuation">(</span>s <span class="token operator">-&gt;</span> s<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">&quot;Q&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>还有 <strong>allMatch</strong> 和 <strong>noneMatch 方法</strong>， 它们分别在所有元素和没有任何元素匹配谓词的情况下返回 true。这两个方法可以通过并行运行而获益。</p> <h3 id="reduce-方法"><a href="#reduce-方法" class="header-anchor">#</a> reduce 方法</h3> <p><strong>reduce 方法</strong> 是一种用于从流中计算某个值的通用机制，其最简单的形式 <strong>接受一个二元函数，并从前两个元素开始持续应用它</strong>。如果该函数是求和函数，那么就很容易解释这种机制：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> values <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> sum <span class="token operator">=</span> values<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> x <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在上面的情况中，reduce 方法会计算 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub><mo>+</mo><msub><mi>v</mi><mn>1</mn></msub><mo>+</mo><msub><mi>v</mi><mn>2</mn></msub><mo>+</mo><mo>⋯</mo></mrow><annotation encoding="application/x-tex">v_0+v_1+v_2+\cdots</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.31em;vertical-align:0em;"></span><span class="minner">⋯</span></span></span></span></span>，其中 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 是流中的元素。如果流为空，那么该方法会返回一个Optional，因为没有任何有效的结果。</p> <p>更一般地，我们可以使用任何约简操作将部分结果 x 与下一个值 y 组合起来以产生新的部分结果。</p> <p>以下是另一种看待约简的方式：给定约简操作 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>p</mi></mrow><annotation encoding="application/x-tex">op</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span></span></span></span></span>，该约简会产生 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mn>0</mn></msub><mtext></mtext><mi>o</mi><mi>p</mi><mtext></mtext><msub><mi>v</mi><mn>1</mn></msub><mtext></mtext><mi>o</mi><mi>p</mi><mtext></mtext><msub><mi>v</mi><mn>2</mn></msub><mtext></mtext><mi>o</mi><mi>p</mi><mo>⋯</mo></mrow><annotation encoding="application/x-tex">v_0\ op\ v_1\ op\ v_2\ op\cdots</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">⋯</span></span></span></span></span>  ，其中我们将函数 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>o</mi><mi>p</mi><mo stretchy="false">(</mo><msub><mi>v</mi><mi>i</mi></msub><mo separator="true">,</mo><msub><mi>v</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">op(v_i,v_{i+1})</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span> 调用写作 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub><mtext></mtext><mi>o</mi><mi>p</mi><mtext></mtext><msub><mi>v</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">v_i\ op\ v_{i+1}</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace"> </span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mspace"> </span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></span>。有很多在实践中很有用的可结合操作，例如求和、乘积、字符串连接、求最大值和最小值、求集的并与交等。</p> <p>如果要使用并行流来约简，这项约简操作必须是可结合的，即组合元素时使用的顺序不会产生任何影响。在数学标记法中，<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mtext></mtext><mi>o</mi><mi>p</mi><mtext></mtext><mi>y</mi><mo stretchy="false">)</mo><mtext></mtext><mi>o</mi><mi>p</mi><mtext></mtext><mi>z</mi></mrow><annotation encoding="application/x-tex">(x\ op\ y)\ op\ z</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace"> </span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span></span></span></span></span> 必须等于 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mtext></mtext><mi>o</mi><mi>p</mi><mtext></mtext><mo stretchy="false">(</mo><mi>y</mi><mtext></mtext><mi>o</mi><mi>p</mi><mtext></mtext><mi>z</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">x\ op\ (y\ op\ z)</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">x</span><span class="mspace"> </span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace"> </span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span></span>。减法是一个不可结合操作的例子。</p> <p>通常，会有一个幺元值 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi></mrow><annotation encoding="application/x-tex">e</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span></span> 使得 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>e</mi><mtext></mtext><mi>o</mi><mi>p</mi><mtext></mtext><mi>x</mi><mo>=</mo><mi>e</mi></mrow><annotation encoding="application/x-tex">e\ op\ x = e</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">e</span><span class="mspace"> </span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mspace"> </span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">e</span></span></span></span></span>，可以使用这个元素作为计算的起点。例如，<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></span> 是加法的幺元值。由此，我们可以使用 <strong>第 2 种形式的 reduce</strong>：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> values <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token class-name">Integer</span> sum <span class="token operator">=</span> values<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> x <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Computes 0 + v0 + v1 + v2 + ...</span>
</code></pre></div><p>如果流为空，则会返回幺元值，你就不需要处理 Optional 类了。</p> <h2 id="_9-4-optional-类型"><a href="#_9-4-optional-类型" class="header-anchor">#</a> 9.4 Optional 类型</h2> <p>Optional&lt;T&gt; 对象是一种包装器对象，要么包装了类型 T 的对象，要么没有包装任何对象。对于第一种情况，我们称这种值是存在的。Optional&lt;T&gt; 类型被当作一种更安全的方式，用来替代类型 T 的引用，这种引用要么引用某个对象，要么为 null。但是，它只有在正确使用的情况下才会更安全，接下来我们将讨论如何正确使用。</p> <h3 id="获取、消费、管道化-optional-值"><a href="#获取、消费、管道化-optional-值" class="header-anchor">#</a> 获取、消费、管道化 Optional 值</h3> <div class="subtitle"><p>获取 Optional 值</p></div><p>有效地使用 Optional 的关键是要使用这样的方法：它在值不存在的情况下会产生一个可替代物，而只有在值存在的情况下才会使用这个值。</p> <p>本小节先来看看第一条策略通常，在没有任何匹配时，我们会希望使用某种默认值，可能是空字符串：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span> result <span class="token operator">=</span> optionalString<span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// The wrapped string, or &quot;&quot; if none</span>
</code></pre></div><p>还可以调用代码来计算默认值：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span> result <span class="token operator">=</span> optionalString<span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">&quot;myapp.default&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// The function is only called when needed</span>
</code></pre></div><p>或者可以在没有任何值时抛岀异常:</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span> result <span class="token operator">=</span> optionalString<span class="token punctuation">.</span><span class="token function">orElseThrow</span><span class="token punctuation">(</span><span class="token class-name">IllegalStateException</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Supply a method that yields an exception object</span>
</code></pre></div><div class="subtitle"><p>消费 Optional 值</p></div><p>在上一小节，我们看到了如何在不存在任何值的情况下产生相应的替代物。另一条使用可选值的策略是只有在其存在的情况下才消费该值。</p> <p><strong>ifPresent 方法</strong> 会接受一个函数。如果可选值存在，它会被传递给该函数。否则，不会发生任何事情。</p> <div class="language-java extra-class"><pre class="language-java"><code>optionalValue<span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>v <span class="token operator">-&gt;</span> <span class="token class-name">Process</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>例如，如果在该值存在的情况下想要将其添加到某个集中，那么就可以调用</p> <div class="language-java extra-class"><pre class="language-java"><code>optionalValue<span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>v <span class="token operator">-&gt;</span> results<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>或者直接调用</p> <div class="language-java extra-class"><pre class="language-java"><code>optionalValue<span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>results<span class="token operator">::</span><span class="token function">add</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果想要在可选值存在时执行一种动作，在可选值不存在时执行另一种动作，可以使用 <strong>ifPresentOrElse 方法</strong>：</p> <div class="language-java extra-class"><pre class="language-java"><code>optionalValue<span class="token punctuation">.</span><span class="token function">ifPresentOrElse</span><span class="token punctuation">(</span>
    v <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Found &quot;</span> <span class="token operator">+</span> v<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token operator">&gt;</span> logger<span class="token punctuation">.</span><span class="token function">warning</span><span class="token punctuation">(</span><span class="token string">&quot;No match&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="subtitle"><p>管道化 Optional 值</p></div><p>你已经看到了如何从 Optional 对象获取值。另一种有用的策略是保持 Optional 完整，使用 <strong>map 方法</strong> 来转换 Optional 内部的值：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> transformed <span class="token operator">=</span> optionalstring<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">:</span>toUpperCase<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果 optionalString 为空， 那么 transformed 也为空。</p> <p>下面是另一个例子，我们将一个结果添加到列表中，如果它存在的话：</p> <div class="language-java extra-class"><pre class="language-java"><code>optionalValue<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>results<span class="token operator">:</span>add<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果 optionalValue 为空，则什么也不会发生。</p> <blockquote><p><strong>注释</strong>：这个 map 方法与 Stream 接口的 map 方法类似。你可以直接将可选值想象成尺寸为 0 或 1 的流。结果的尺寸也是 0 或 1，并且在后一种情况中，函数会应用于其上。</p></blockquote> <p>类似地，可以使用 <strong>filter 方法</strong> 来只处理那些在转换它之前或之后满足某种特定属性的 Optional 值。如果不满足该属性，那么管道会产生空的结果：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> transformed <span class="token operator">=</span> optionalString
    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>s <span class="token operator">-&gt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">8</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">:</span>toUpperCase<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>可以用 <strong>or 方法</strong> 将空 Optional 替换为一个可替代的 Optional。这个可替代值将以惰性方式计算。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> optionalString<span class="token punctuation">.</span><span class="token function">or</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span> <span class="token comment">// Supply an Optional</span>
	alternatives<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">findFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果 optionalString 的值存在，那么 result 为 optionalString。如果值不存在，那么就会计算 lambda 表达式，并使用计算出来的结果。</p> <h3 id="正确用法提示"><a href="#正确用法提示" class="header-anchor">#</a> 正确用法提示</h3> <p>get 方法会在 Optional 值存在的情况下获得其中包装的元素，或者在不存在的情况下拋岀一个 NoSuchElementException 异常。因此，</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> optionalValue <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
optionalValue<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>并不比下面的方式更安全：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">T</span> value <span class="token operator">=</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
value<span class="token punctuation">.</span><span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>isPresent 方法会报告某个 Optional&lt;T&gt; 对象是否具有值。但是</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>optionalvalue<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> optionalValue<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>并不比下面的方式更容易处理：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> value<span class="token punctuation">.</span><span class="token function">someMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p><strong>注释</strong>：Java 10 为 get 方法引入了一个耸人听闻的同义词，称为 optionaValue.orElseThrow()，这个名字明确表示该方法会在 optionalValue 为空时抛出一个 NoSuchElementException() 这样命名是希望程序员只有在非常明确地知道 Optional 永远都不会为空时才去调用该方法。</p></blockquote> <p>有关 Optional 类型正确用法的提示：</p> <ul><li>Optional 类型的变量永远都不应该为 null。</li> <li>不要使用 Optional 类型的域。因为其代价是额外多出来一个对象。在类的内部，使用 null 表示缺失的域更易于操作。</li> <li>不要在集合中放置 Optional 对象，并且不要将它们用作 Map 的键。应该直接收集其中的值。</li></ul> <h3 id="optional-的创建"><a href="#optional-的创建" class="header-anchor">#</a> Optional 的创建</h3> <p>有多个方法可以用于此目的，包括 <strong>Optional.of(result)</strong> 和 <strong>Optional.empty()</strong>。例如，</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Double</span><span class="token punctuation">&gt;</span></span> <span class="token function">inverse</span><span class="token punctuation">(</span><span class="token class-name">Double</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">/</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>ofNullable 方法</strong> 被用来作为可能出现的 null 值和可选值之间的桥梁。Optional.ofNullable(obj) 会在 obj 不为 null 的情况下返回 Optional.of(obj)，否则会返回 Optional.empty() 。</p> <h3 id="flatmap-方法"><a href="#flatmap-方法" class="header-anchor">#</a> flatMap 方法</h3> <p>假设有一个可以产生 Optional&lt;T&gt; 对象的方法 f， 并且目标类型 T 具有一个可以 <strong>产生 Optional&lt;U&gt; 对象</strong> 的方法 g。 如果它们都是普通的方法， 那么你可以通过调用 s.f().g() 来将它们组合起来。 但是这种组合无法工作， 因为 s.f() 的类型为 Optional&lt;T&gt;， 而不是 T。 因此， 需要调用</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">U</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token operator">::</span><span class="token function">g</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果 s.f() 的值存在，那么 g 就可以应用到它上面。否则，就会返回一个空 Optional&lt;U&gt;。</p> <p>很明显，如果有更多可以产生 Optional 值的方法或 lambda 表达式，那么就可以重复此过程。可以直接将对 flatMap 的调用链接起来，从而构建由这些步骤构成的管道，只有所有步骤都成功，该管道才会成功。</p> <p>例如，考虑前一节中安全的 inverse 方法。假设我们还有一个安全的平方根：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Double</span><span class="token punctuation">&gt;</span></span> <span class="token function">squareRoot</span><span class="token punctuation">(</span><span class="token class-name">Double</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> x <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>你可以像下面这样计算倒数的平方根：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Double</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token function">inverse</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token class-name">MyMath</span><span class="token operator">::</span><span class="token function">squareRoot</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>或者，你可以选择下面的方式：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Double</span><span class="token punctuation">&gt;</span></span> result
    <span class="token operator">=</span> <span class="token class-name">Optional</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">4.0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token class-name">Demo</span><span class="token operator">:</span>inverse<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token class-name">Demo</span><span class="token operator">:</span>squareRoot<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>无论是 inverse 方法还是 squareRoot 方法返回 Optional.empty() ，整个结果都会为空。</p> <blockquote><p><strong>注释</strong>：Stream 接口的 flatMap 方法被用来将产生流的两个方法组合起来，其实现方式是摊平由流构成的流。如果将可选值解释为具有 0 个或 1 个元素，那么 Optional.flatMap 方法与其操作方式一样。</p></blockquote> <h3 id="将-optional-转换为流"><a href="#将-optional-转换为流" class="header-anchor">#</a> 将 Optional 转换为流</h3> <p><strong>stream 方法</strong> 会将一个 Optional&lt;T&gt; 对象转换为一个具有 0 个或 1 个元素的 Stream&lt;T&gt; 对象。这种做法看起来很自然，但是我们为什么希望这么做呢？</p> <p>这会使返回 Optional 结果的方法变得很有用。假设我们有一个用户 ID 流和下面的方法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Optional</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token function">lookup</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">)</span>
</code></pre></div><p>怎样才能在获取用户流时，跳过那些无效的 ID 呢？</p> <p>当然，我们可以过滤掉无效 ID，然后将 get 方法应用于剩余的 ID：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> ids <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> users <span class="token operator">=</span> ids<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Users</span><span class="token operator">::</span><span class="token function">lookup</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">Optional</span><span class="token operator">::</span><span class="token function">isPresent</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Optional</span><span class="token operator">::</span><span class="token function">get</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>但是这样就需要使用我们之前警告过要慎用的 isPresent 和 get 方法。以下调用显得更优雅：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> users <span class="token operator">=</span> ids<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token class-name">Users</span><span class="token operator">::</span><span class="token function">lookup</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token class-name">Optional</span><span class="token operator">::</span><span class="token function">stream</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>每一个对 stream 的调用都会返回一个具有 0 个或 1 个元素的流。flatMap 方法将这些方法每一个对 stream 的调用都会返回一个具有 0 个或 1 个元素的流。</p> <h2 id="_9-5-收集结果"><a href="#_9-5-收集结果" class="header-anchor">#</a> 9.5 收集结果</h2> <p>当处理完流之后，通常会想要查看其结果。此时可以调用 iterator 方法，它会产生用来访问元素的旧式风格的迭代器。或者，可以调用 forEach 方法，将某个函数应用于每个元素：</p> <div class="language-java extra-class"><pre class="language-java"><code>stream<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在并行流上，forEach 方法会以任意顺序遍历各个元素。如果想要按照流中的顺序来处理它们，可以调用 forEachOrdered 方法。当然，这个方法会丧失并行处理的部分甚至全部优势。</p> <h3 id="收集到数组中"><a href="#收集到数组中" class="header-anchor">#</a> 收集到数组中</h3> <p>但是，更常见的情况是，我们想要将结果收集到数据结构中。此时，可以调用 <strong>toArray</strong>，获得由流的元素构成的数组。</p> <p>因为无法在运行时创建泛型数组，所以表达式 stream.toArray() 会返回一个 Object[] 数组。如果想要让数组具有正确的类型，可以将其传递到数组构造器中：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">)</span>
<span class="token comment">// stream.toArray() has type object[]</span>
</code></pre></div><h3 id="收集到集合中"><a href="#收集到集合中" class="header-anchor">#</a> 收集到集合中</h3> <p>将流中的元素收集到另一个目标中，有一个便捷方法 —— <strong>collect</strong>，它接受一个 <strong>Collector 接口</strong> 的实例。</p> <p><strong>收集器</strong> 是一种收集众多元素并产生单一结果的对象，Collectors 类提供了大量用于生成常见收集器的工厂方法。要想将流的元素收集到一个列表中，应该使用 Collectors.toList() 方法产生的收集器：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Colectors</span><span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>类似地，下面的代码展示了如何将流的元素收集到一个集中：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果想要控制获得的集的种类，可以使用下面的调用：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">TreeSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toCollection</span><span class="token punctuation">(</span><span class="token class-name">TreeSet</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果想要通过连接操作来收集流中的所有字符串，可以使用下面的调用：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span> result <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">joining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果想要在元素之间增加分隔符，可以将分隔符传递给 joining 方法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span> result <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">joining</span><span class="token punctuation">(</span><span class="token string">&quot;,&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果想要将流的结果约简为总和、数量 、平均值、最大值或最小值，可以使用 summarizingInt、summarizingLong、summarizingDouble 方法中的一个。这些方法接受一个将流对象映射为数值的函数，产生类型为 IntSummaryStatistics、LongSummaryStatistics、DoubleSummaryStatistics 的结果，同时计算总和、数量 、平均值 、最大值和最小值。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">IntSummaryStatistics</span> summary <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">summarizingInt</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">:</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> averageWordLength <span class="token operator">=</span> summary<span class="token punctuation">.</span><span class="token function">getAverage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">double</span> maxWordLength <span class="token operator">=</span> summary<span class="token punctuation">.</span><span class="token function">getMax</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="收集到映射表中"><a href="#收集到映射表中" class="header-anchor">#</a> 收集到映射表中</h3> <p>假设我们有一个 Stream&lt;Person&gt;，并且想要将其元素收集到一个映射表中，这样后续就可以通过它们的 ID 来查找人员了。<strong>Collectors.toMap 方法</strong> 有两个函数引元，它们用来产生映射表的键和值。例如，</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> idToName <span class="token operator">=</span> people<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>
    <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toMap</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token operator">::</span><span class="token function">getId</span><span class="token punctuation">,</span> <span class="token class-name">Person</span><span class="token operator">::</span><span class="token function">getName</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>通常情况下，值是本身对象，因此第二个函数可以使用 Function.identity()。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span><span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> idToPerson <span class="token operator">=</span> people<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>
    <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toMap</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token operator">::</span><span class="token function">getId</span><span class="token punctuation">,</span> <span class="token class-name">Function</span><span class="token punctuation">.</span><span class="token function">identity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果有多个元素具有相同的键，就会存在冲突，收集器将会抛出一个 IllegalStateException 异常。可以通过提供第三个函数引元来覆盖这种行为，该函数会针对给定的已有值和新值来解决冲突并确定键对应的值。这个函数应该返回已有值、新值或它们的组合。</p> <p>在下面的代码中，我们构建了一个映射表，存储了所有可用 locale 中的语言，其中每种语言在默认 locale 中的名字（例如 “German” ） 为键，而其本地化的名字（例如 “Deutsch” ） 为值：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Locale</span><span class="token punctuation">&gt;</span></span> locales <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token class-name">Locale</span><span class="token punctuation">.</span><span class="token function">getAvailableLocales</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> languageNames <span class="token operator">=</span> locales<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>
    <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toMap</span><span class="token punctuation">(</span>
        <span class="token class-name">Locale</span><span class="token operator">::</span><span class="token function">getDisplayLanguage</span><span class="token punctuation">,</span>
        loc <span class="token operator">-&gt;</span> loc<span class="token punctuation">.</span><span class="token function">getDisplayLanguage</span><span class="token punctuation">(</span>loc<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span>existingValue<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> existingValue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>我们不关心同一种语言是否可能会出现两次（例如，德国和瑞士都使用德语），因此我们只记录第一项。</p> <p>现在，假设我们想要了解给定国家的所有语言，这样我们就需要一个 Map&lt;String，Set&lt;String&gt;&gt;。</p> <p>例如，&quot;Switzerland&quot; 的值是集 [French，German，Italian]。首先，我们为每种语言都存储一个单例集。无论何时，只要找到了给定国家的新语言，我们就会对已有集和新集进行并操作。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> countryLanguageSets <span class="token operator">=</span> locales<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>
    <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toMap</span><span class="token punctuation">(</span>
        <span class="token class-name">Locale</span><span class="token operator">::</span><span class="token function">getDisplayCountry</span><span class="token punctuation">,</span>
        l <span class="token operator">-&gt;</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singleton</span><span class="token punctuation">(</span>l<span class="token punctuation">.</span><span class="token function">getDisplayLanguage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// Union of a and b</span>
            <span class="token keyword">var</span> union <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
            union<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> union<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在下一节中，你将会看到一种更简单的获取这种映射表的方式。</p> <p>如果想要得到 TreeMap，那么可以将构造器作为第四个引元来提供。你必须提供一种合并函数。下面是本节一开始所列举的示例之一，现在它会产生一个 TreeMap：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Person</span><span class="token punctuation">&gt;</span></span> idToPerson <span class="token operator">=</span> people<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>
    <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toMap</span><span class="token punctuation">(</span>
        <span class="token class-name">Person</span><span class="token operator">::</span><span class="token function">getId</span><span class="token punctuation">,</span>
        <span class="token class-name">Function</span><span class="token punctuation">.</span><span class="token function">identity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span>existingValue<span class="token punctuation">,</span> newvalue<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
        <span class="token class-name">TreeMap</span><span class="token operator">::</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p><strong>注释</strong>：对于每一个 toMap 方法，都有一个等价的可以产生并发映射表的 toConcurrentMap方法。单个并发映射表可以用于并行集合处理。当使用并行流时，共享的映射表比合并映射表更高效。注意，元素不再是按照流中的顺序收集的，但是通常这不会有什么问题。</p></blockquote> <h2 id="_9-6-群组和分区"><a href="#_9-6-群组和分区" class="header-anchor">#</a> 9.6 群组和分区</h2> <p>在上一节中，你看到了如何收集给定国家的所有语言，但是其处理显得有些冗长。你必须为每个映射表的值都生成单例集，然后指定如何将现有值与新值合并。将具有相同特性的值群聚成组是非常常见的，并且 <strong>groupingBy 方法</strong> 直接就支持它。</p> <p>我们来看看通过国家聚成组 Locale 的问题。首先，构建该映射表：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Locale</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> countryToLocales <span class="token operator">=</span> locales<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>
    <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">Locale</span><span class="token operator">::</span><span class="token function">getCountry</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>函数 Locale::getCountry 是群组的分类函数，你现在可以查找给定国家代码对应的所有地点了，例如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Locale</span><span class="token punctuation">&gt;</span></span> swissLocales <span class="token operator">=</span> countryToLocales<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;CH&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Yields locales de_CH, fr_CH, it_CH and maybe more</span>
</code></pre></div><blockquote><p><strong>注释</strong>：快速复习一下 locale：每个 locale 都有一个语言代码（ 例如英语的 en） 和一个国家代码（ 例如美国的 US）。locale en_US 描述的是美国英语，而 en_IE 是爱尔兰英语。某些国家有多个 locale。例如，ga_IE 是爱尔兰的盖尔语，而前面的示例展示了我的JDK 知道瑞士至少有三个 locale。</p></blockquote> <p>当分类函数是断言函数（即返回 boolean 值的函数） 时，流的元素可以分为两个列表：该函数返回 true 的元素和其他的元素。在这种情况下，使用 <strong>partitioningBy</strong> 比使用 groupingBy 更高效。例如，在下面的代码中，我们将所有 locale 分成了使用英语和使用所有其他语言的两类：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Locale</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> englishAndOtherLocales <span class="token operator">=</span> locales<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>
    <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">partitioningBy</span><span class="token punctuation">(</span>l <span class="token operator">-&gt;</span> l<span class="token punctuation">.</span><span class="token function">getLanguage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">&quot;en&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Locale</span><span class="token punctuation">&gt;</span></span> englishLocales <span class="token operator">=</span> englishAndOtherLocales<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p><strong>注释</strong>：如果调用 groupingByConcurrent 方法，就会在使用并行流时获得一个被并行组装的并行映射表。这与 toConcurrentHap 方法完全类似。</p></blockquote> <h3 id="下游收集器"><a href="#下游收集器" class="header-anchor">#</a> 下游收集器</h3> <p>groupingBy 方法会产生一个映射表，它的每个值都是一个列表。如果想要以某种方式来处理这些列表，就需要提供一个 <strong>“下游收集器”</strong>。例如，如果想要获得集而不是列表，那么可以使用上一节中看到的 Collectors.toSet 收集器：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token punctuation">&lt;</span><span class="token class-name">Locale</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> countryToLocaleSet <span class="token operator">=</span> locales<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>
    <span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">Locale</span><span class="token operator">::</span><span class="token function">getCountry</span><span class="token punctuation">,</span> <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Java 提供了多种可以将收集到的元素约简为数字的收集器：</p> <p><strong>counting</strong> 会产生收集到的元素的个数。例如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> countryToLocaleCounts <span class="token operator">=</span> locales<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>
    <span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">Locale</span><span class="token operator">:</span>getCountry<span class="token punctuation">,</span> <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">counting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>对每个国家有多少个 locale 进行计数。</p> <p><strong>summingInt、summingLong、summingDouble</strong> 会接受一个函数作为引元，将该函数应用到下游元素中，并产生它们的和。例如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stateToCityPopulation <span class="token operator">=</span> cities<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>
    <span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">City</span><span class="token operator">::</span><span class="token function">getState</span><span class="token punctuation">,</span> <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">summingInt</span><span class="token punctuation">(</span><span class="token class-name">City</span><span class="token operator">::</span><span class="token function">getPopulation</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>计算城市流中每个州的人口总和。</p> <p><strong>maxBy</strong> 和 <strong>minBy</strong> 会接受一个比较器，并分别产生下游元素中的最大值和最小值。例如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Optional</span><span class="token punctuation">&lt;</span><span class="token class-name">City</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> stateToLargestCity <span class="token operator">=</span> cities<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>
    <span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">City</span><span class="token operator">::</span><span class="token function">getState</span><span class="token punctuation">,</span>
               <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">maxBy</span><span class="token punctuation">(</span><span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token class-name">City</span><span class="token operator">::</span><span class="token function">getPopulation</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>产生每个州中最大的城市。</p> <p><strong>collectingAndThen 收集器</strong> 在收集器后面添加了一个最终处理步骤。例如，如果我们想要知道有多少不同的结果，那么就可以将它们收集到一个集中，然后计算其尺寸：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> stringCountsByStartingLetter <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>
    <span class="token function">groupingBy</span><span class="token punctuation">(</span>s <span class="token operator">-&gt;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
               <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">collectingAndThen</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token operator">:</span>size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>mapping 收集器</strong> 正好相反，它会将一个函数应用于收集到的每个元素，并将结果传递给下游收集器。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> stringLengthsByStartingLetter <span class="token operator">=</span> strings<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>
    <span class="token function">groupingBy</span><span class="token punctuation">(</span>s <span class="token operator">-&gt;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
               <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">mapping</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">length</span><span class="token punctuation">,</span> <span class="token class-name">CollectorstoSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这里，我们按照首字符对字符串进行了分组。在每个组内部，我们会计算字符串的长度，然后将这些长度收集到一个集中。</p> <p>mapping 方法针对上一节中的问题，即把某国所有的语言收集到一个集中，产生了一种更佳的解决方案。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> countryToLanguages <span class="token operator">=</span> locales<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>
    <span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">Locale</span><span class="token operator">::</span><span class="token function">getDisplayCountry</span><span class="token punctuation">,</span>
               <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">mapping</span><span class="token punctuation">(</span><span class="token class-name">Locale</span><span class="token operator">::</span><span class="token function">getDisplayLanguage</span><span class="token punctuation">,</span>
                                  <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>还有一个 <strong>flatMapping 方法</strong>，可以与返回流的函数一起使用。</p> <p>如果群组和映射函数的返回值为 int、long 或 double，那么可以将元素收集到汇总统计对象中。例如，</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">IntSummaryStatistics</span><span class="token punctuation">&gt;</span></span> stateToCityPopulationSummary <span class="token operator">=</span> cities<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>
    <span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">City</span><span class="token operator">::</span><span class="token function">getState</span><span class="token punctuation">,</span>
               <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">summarizingInt</span><span class="token punctuation">(</span><span class="token class-name">City</span><span class="token operator">::</span><span class="token function">getPopulation</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>filtering 收集器</strong> 会将一个过滤器应用到每个组上，例如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Set</span><span class="token punctuation">&lt;</span><span class="token class-name">City</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> largeCitiesByState <span class="token operator">=</span> 
    cities<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>
    <span class="token function">groupingBy</span><span class="token punctuation">(</span><span class="token class-name">City</span><span class="token operator">::</span><span class="token function">getState</span><span class="token punctuation">,</span>
               <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">filtering</span><span class="token punctuation">(</span>c <span class="token operator">-&gt;</span> c<span class="token punctuation">.</span><span class="token function">getPopulation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">500000</span><span class="token punctuation">,</span>
                                    <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// States without large cities have empty sets</span>
</code></pre></div><p>将收集器组合起来是一种很强大的方式，但是它也可能会导致产生非常复杂的表达式。最佳用法是与 groupingBy 或 partitioningBy 一起处理 “下游的” 映射表中的值。否则，应该直接在流上应用诸如 map、reduce、count、max 或 min 这样的方法。</p> <h2 id="_9-7-基本类型流"><a href="#_9-7-基本类型流" class="header-anchor">#</a> 9.7 基本类型流</h2> <p>到目前为止，我们都是将整数收集到 Strean&lt;Integer&gt;，尽管很明显，但是将每个整数都包装到包装器对象中却是很低效的。对其他基本类型来说，情况也是一样，这些基本类型是 double、float、long、short、char、byte 和 boolean。流库中具有专门的类型 IntStream、LongStreamm DoubleStream，用来直接存储基本类型值，而无须使用包装器。如果想要存储 short、char、byte 和 boolean，可以使用 IntStream；而对于 float，可以使用 DoubleStream。</p> <p>为了创建 IntStream，需要调用 IntStream.of 和 Arrays.stream 方法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">IntStream</span> stream <span class="token operator">=</span> <span class="token class-name">IntStream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
stream <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>values<span class="token punctuation">,</span> from<span class="token punctuation">,</span> <span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// values is an int[] array</span>
</code></pre></div><p>与对象流一样，我们还可以使用静态的 generate 和 iterate 方法。此外，IntStream 和 LongStream 有静态方法 range 和 rangeClosed，可以生成步长为 1 的整数范围：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">IntStream</span> zeroToNinetyNine <span class="token operator">=</span> <span class="token class-name">IntStream</span><span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Upper bound is excluded</span>
<span class="token class-name">IntStream</span> zeroToHundred <span class="token operator">=</span> <span class="token class-name">IntStream</span><span class="token punctuation">.</span><span class="token function">rangeclosed</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Upper bound is included</span>
</code></pre></div><p>CharSequence 接口拥有 codePoints 和 chars 方法，可以生成由字符的 Unicode 码或由 UTF-16 编码机制的码元构成的 IntStream。</p> <p>当你有一个对象流时，可以用 mapToInt 、mapToLong 或 mapToDouble 将其转换为基本类型流。例如，如果你有一个字符串流，并想将其长度处理为整数，那么就可以在 IntStream 中实现此目的：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> words <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token class-name">IntStream</span> lengths <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">mapToInt</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token operator">::</span><span class="token function">length</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>为了将基本类型流转换为对象流，需要使用 <strong>boxed 方法</strong>：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> integers <span class="token operator">=</span> <span class="token class-name">IntStream</span><span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">boxed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>通常，基本类型流上的方法与对象流上的方法类似。以下是主要的差异：</p> <ul><li>toArray 方法会返回基本类型数组。</li> <li>产生可选结果的方法会返回一个 Optionallnt、OptionalLong 或 OptionalDouble。这些类与 Optional 类类似，但是具有 getAsInt、getAsLong 和 getAsDouble 方法，而不是 get 方法。</li> <li>具有分别返回总和、平均值、最大值和最小值的 sum、average、max 和 min 方法。对象流没有定义这些方法。</li> <li>summaryStatistics 方法会产生一个类型为 IntSummaryStatistics、LongSummaryStatistics 或 DoubleSummaryStatistics 的对象，它们可以同时报告流的总和、数量 、平均值、最大值和最小值。</li></ul> <h2 id="_9-8-并行流"><a href="#_9-8-并行流" class="header-anchor">#</a> 9.8 并行流</h2> <p>流使并行处理块操作变得很容易。这个过程几乎是自动的，但是需要遵守一些规则。首先，必须有一个并行流。可以用 <strong>Collection.parallelStream()</strong> 方法从任何集合中获取一个并行流：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> parallelWords <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">parallelstream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>而且，<strong>parallel 方法</strong> 可以将任意的顺序流转换为并行流。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Stream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> parallelWords <span class="token operator">=</span> <span class="token class-name">Stream</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>wordArray<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">parallel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>只要在终结方法执行时流处于并行模式，所有的中间流操作就都将被并行化。</p> <p>当流操作并行运行时，其目标是让其返回结果与顺序执行时返回的结果相同。重要的是，这些操作是无状态的 ，并且可以以任意顺序执行。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/note-pages/java/5ddfa5/" class="prev">
        第8章 集合和算法
      </a></span> <span class="next"><a href="/note-pages/java/5ddfa7/">
        第10章 Java类库
      </a>
      →
    </span></p></div> </main> <aside items="[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]" class="right-sidebar"><div style="margin-left:20px; margin-bottom: 10px; text-align: center; font-size:16px;font-weight:bold;">此页内容</div> <div class="right-sidebar-wrap"><ul class="right-sidebar-links"><li id="tab-item0" class="right-sidebar-item active"><a href="#_9-1-从迭代到流的操作" class="right-sidebar-item-level2">
          9.1 从迭代到流的操作
        </a></li><li id="tab-item1" class="right-sidebar-item"><a href="#_9-2-流的操作" class="right-sidebar-item-level2">
          9.2 流的操作
        </a></li><li id="tab-item2" class="right-sidebar-item"><a href="#流的创建" class="right-sidebar-item-level3">
          流的创建
        </a></li><li id="tab-item3" class="right-sidebar-item"><a href="#filter、map-和-flatmap-方法" class="right-sidebar-item-level3">
          filter、map 和 flatMap 方法
        </a></li><li id="tab-item4" class="right-sidebar-item"><a href="#抽取子流和组合流" class="right-sidebar-item-level3">
          抽取子流和组合流
        </a></li><li id="tab-item5" class="right-sidebar-item"><a href="#其他的流转换" class="right-sidebar-item-level3">
          其他的流转换
        </a></li><li id="tab-item6" class="right-sidebar-item"><a href="#_9-3-约简操作" class="right-sidebar-item-level2">
          9.3 约简操作
        </a></li><li id="tab-item7" class="right-sidebar-item"><a href="#简单约简" class="right-sidebar-item-level3">
          简单约简
        </a></li><li id="tab-item8" class="right-sidebar-item"><a href="#reduce-方法" class="right-sidebar-item-level3">
          reduce 方法
        </a></li><li id="tab-item9" class="right-sidebar-item"><a href="#_9-4-optional-类型" class="right-sidebar-item-level2">
          9.4 Optional 类型
        </a></li><li id="tab-item10" class="right-sidebar-item"><a href="#获取、消费、管道化-optional-值" class="right-sidebar-item-level3">
          获取、消费、管道化 Optional 值
        </a></li><li id="tab-item11" class="right-sidebar-item"><a href="#正确用法提示" class="right-sidebar-item-level3">
          正确用法提示
        </a></li><li id="tab-item12" class="right-sidebar-item"><a href="#optional-的创建" class="right-sidebar-item-level3">
          Optional 的创建
        </a></li><li id="tab-item13" class="right-sidebar-item"><a href="#flatmap-方法" class="right-sidebar-item-level3">
          flatMap 方法
        </a></li><li id="tab-item14" class="right-sidebar-item"><a href="#将-optional-转换为流" class="right-sidebar-item-level3">
          将 Optional 转换为流
        </a></li><li id="tab-item15" class="right-sidebar-item"><a href="#_9-5-收集结果" class="right-sidebar-item-level2">
          9.5 收集结果
        </a></li><li id="tab-item16" class="right-sidebar-item"><a href="#收集到数组中" class="right-sidebar-item-level3">
          收集到数组中
        </a></li><li id="tab-item17" class="right-sidebar-item"><a href="#收集到集合中" class="right-sidebar-item-level3">
          收集到集合中
        </a></li><li id="tab-item18" class="right-sidebar-item"><a href="#收集到映射表中" class="right-sidebar-item-level3">
          收集到映射表中
        </a></li><li id="tab-item19" class="right-sidebar-item"><a href="#_9-6-群组和分区" class="right-sidebar-item-level2">
          9.6 群组和分区
        </a></li><li id="tab-item20" class="right-sidebar-item"><a href="#下游收集器" class="right-sidebar-item-level3">
          下游收集器
        </a></li><li id="tab-item21" class="right-sidebar-item"><a href="#_9-7-基本类型流" class="right-sidebar-item-level2">
          9.7 基本类型流
        </a></li><li id="tab-item22" class="right-sidebar-item"><a href="#_9-8-并行流" class="right-sidebar-item-level2">
          9.8 并行流
        </a></li></ul></div></aside></div><div class="global-ui"></div></div>
    <script src="/note-pages/assets/js/app.05dcbd87.js" defer></script><script src="/note-pages/assets/js/3.4a2f67fd.js" defer></script><script src="/note-pages/assets/js/2.ab82720e.js" defer></script><script src="/note-pages/assets/js/143.b31785f9.js" defer></script>
  </body>
</html>
