<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第4章 继承与多态 | 后端技术栈笔记</title>
    <meta name="generator" content="VuePress 1.9.7">
    <script src="/note-pages//s0.pstatp.com/cdn/expire-1-M/jquery/3.4.0/jquery.min.js"></script>
    <script src="/note-pages//s0.pstatp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.js"></script>
    <link rel="stylesheet" href="/note-pages//s0.pstatp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.css">
    <meta name="description" content="BackEnd Notes">
    
    <link rel="preload" href="/note-pages/assets/css/0.styles.167a34c7.css" as="style"><link rel="preload" href="/note-pages/assets/js/app.05dcbd87.js" as="script"><link rel="preload" href="/note-pages/assets/js/3.4a2f67fd.js" as="script"><link rel="preload" href="/note-pages/assets/js/2.ab82720e.js" as="script"><link rel="preload" href="/note-pages/assets/js/140.cbfdbe32.js" as="script"><link rel="prefetch" href="/note-pages/assets/js/10.e11a80d9.js"><link rel="prefetch" href="/note-pages/assets/js/100.489cf69a.js"><link rel="prefetch" href="/note-pages/assets/js/101.560e37ea.js"><link rel="prefetch" href="/note-pages/assets/js/102.baaa4f6a.js"><link rel="prefetch" href="/note-pages/assets/js/103.262b6423.js"><link rel="prefetch" href="/note-pages/assets/js/104.ac33d7ce.js"><link rel="prefetch" href="/note-pages/assets/js/105.5e6ce18f.js"><link rel="prefetch" href="/note-pages/assets/js/106.a69322ef.js"><link rel="prefetch" href="/note-pages/assets/js/107.6cdb78ee.js"><link rel="prefetch" href="/note-pages/assets/js/108.1d720289.js"><link rel="prefetch" href="/note-pages/assets/js/109.58f7297c.js"><link rel="prefetch" href="/note-pages/assets/js/11.241a46da.js"><link rel="prefetch" href="/note-pages/assets/js/110.9cef761d.js"><link rel="prefetch" href="/note-pages/assets/js/111.c782138c.js"><link rel="prefetch" href="/note-pages/assets/js/112.40cb3b1a.js"><link rel="prefetch" href="/note-pages/assets/js/113.c367e40a.js"><link rel="prefetch" href="/note-pages/assets/js/114.a4a75db5.js"><link rel="prefetch" href="/note-pages/assets/js/115.a73cd469.js"><link rel="prefetch" href="/note-pages/assets/js/116.ad853155.js"><link rel="prefetch" href="/note-pages/assets/js/117.a82b2649.js"><link rel="prefetch" href="/note-pages/assets/js/118.8f896dd0.js"><link rel="prefetch" href="/note-pages/assets/js/119.374482b1.js"><link rel="prefetch" href="/note-pages/assets/js/12.ebe220d5.js"><link rel="prefetch" href="/note-pages/assets/js/120.89698284.js"><link rel="prefetch" href="/note-pages/assets/js/121.cbe50685.js"><link rel="prefetch" href="/note-pages/assets/js/122.7de2ac51.js"><link rel="prefetch" href="/note-pages/assets/js/123.a2d16009.js"><link rel="prefetch" href="/note-pages/assets/js/124.e1ba7cbe.js"><link rel="prefetch" href="/note-pages/assets/js/125.4e1e6d6a.js"><link rel="prefetch" href="/note-pages/assets/js/126.3db22af3.js"><link rel="prefetch" href="/note-pages/assets/js/127.937f4ffc.js"><link rel="prefetch" href="/note-pages/assets/js/128.0bad2e20.js"><link rel="prefetch" href="/note-pages/assets/js/129.75a99d25.js"><link rel="prefetch" href="/note-pages/assets/js/13.5ee7bef5.js"><link rel="prefetch" href="/note-pages/assets/js/130.599b6d3d.js"><link rel="prefetch" href="/note-pages/assets/js/131.687214bf.js"><link rel="prefetch" href="/note-pages/assets/js/132.8295c067.js"><link rel="prefetch" href="/note-pages/assets/js/133.854d61c0.js"><link rel="prefetch" href="/note-pages/assets/js/134.f3fc20e1.js"><link rel="prefetch" href="/note-pages/assets/js/135.2a5a690d.js"><link rel="prefetch" href="/note-pages/assets/js/136.6ba30378.js"><link rel="prefetch" href="/note-pages/assets/js/137.80d7c511.js"><link rel="prefetch" href="/note-pages/assets/js/138.0a25898e.js"><link rel="prefetch" href="/note-pages/assets/js/139.fb3c377f.js"><link rel="prefetch" href="/note-pages/assets/js/14.a561f8b3.js"><link rel="prefetch" href="/note-pages/assets/js/141.c09f054f.js"><link rel="prefetch" href="/note-pages/assets/js/142.723bd973.js"><link rel="prefetch" href="/note-pages/assets/js/143.b31785f9.js"><link rel="prefetch" href="/note-pages/assets/js/144.69d3d121.js"><link rel="prefetch" href="/note-pages/assets/js/145.c4ee6aa0.js"><link rel="prefetch" href="/note-pages/assets/js/146.7f836a1c.js"><link rel="prefetch" href="/note-pages/assets/js/147.d4a57976.js"><link rel="prefetch" href="/note-pages/assets/js/148.b15e75eb.js"><link rel="prefetch" href="/note-pages/assets/js/149.94085ddc.js"><link rel="prefetch" href="/note-pages/assets/js/15.4ed118f1.js"><link rel="prefetch" href="/note-pages/assets/js/150.6751d41b.js"><link rel="prefetch" href="/note-pages/assets/js/151.bd60e322.js"><link rel="prefetch" href="/note-pages/assets/js/152.15caf78f.js"><link rel="prefetch" href="/note-pages/assets/js/153.131128fc.js"><link rel="prefetch" href="/note-pages/assets/js/154.b8ee2e7d.js"><link rel="prefetch" href="/note-pages/assets/js/155.8fa1e2e0.js"><link rel="prefetch" href="/note-pages/assets/js/156.25e2a796.js"><link rel="prefetch" href="/note-pages/assets/js/157.7137c9c3.js"><link rel="prefetch" href="/note-pages/assets/js/158.fdc18c40.js"><link rel="prefetch" href="/note-pages/assets/js/159.0dadb745.js"><link rel="prefetch" href="/note-pages/assets/js/16.818fc8bf.js"><link rel="prefetch" href="/note-pages/assets/js/160.05f7541c.js"><link rel="prefetch" href="/note-pages/assets/js/161.2a8c62a2.js"><link rel="prefetch" href="/note-pages/assets/js/162.5b9983b7.js"><link rel="prefetch" href="/note-pages/assets/js/163.b51a5538.js"><link rel="prefetch" href="/note-pages/assets/js/164.06c9f20a.js"><link rel="prefetch" href="/note-pages/assets/js/165.c25063f4.js"><link rel="prefetch" href="/note-pages/assets/js/166.6c570da5.js"><link rel="prefetch" href="/note-pages/assets/js/167.12fb6fb6.js"><link rel="prefetch" href="/note-pages/assets/js/168.d7dd27bc.js"><link rel="prefetch" href="/note-pages/assets/js/169.27f575fe.js"><link rel="prefetch" href="/note-pages/assets/js/17.9daf0c47.js"><link rel="prefetch" href="/note-pages/assets/js/170.ba4295ef.js"><link rel="prefetch" href="/note-pages/assets/js/171.3fb54078.js"><link rel="prefetch" href="/note-pages/assets/js/18.086ed162.js"><link rel="prefetch" href="/note-pages/assets/js/19.adca670c.js"><link rel="prefetch" href="/note-pages/assets/js/20.2e9ff004.js"><link rel="prefetch" href="/note-pages/assets/js/21.07830947.js"><link rel="prefetch" href="/note-pages/assets/js/22.609929cb.js"><link rel="prefetch" href="/note-pages/assets/js/23.d83b832f.js"><link rel="prefetch" href="/note-pages/assets/js/24.592e8014.js"><link rel="prefetch" href="/note-pages/assets/js/25.9d28bb6f.js"><link rel="prefetch" href="/note-pages/assets/js/26.fd4195d5.js"><link rel="prefetch" href="/note-pages/assets/js/27.ca60e875.js"><link rel="prefetch" href="/note-pages/assets/js/28.c2cd75e6.js"><link rel="prefetch" href="/note-pages/assets/js/29.4213d132.js"><link rel="prefetch" href="/note-pages/assets/js/30.c6ee0ead.js"><link rel="prefetch" href="/note-pages/assets/js/31.eea6a542.js"><link rel="prefetch" href="/note-pages/assets/js/32.1ffdceaf.js"><link rel="prefetch" href="/note-pages/assets/js/33.0425748b.js"><link rel="prefetch" href="/note-pages/assets/js/34.5dd0d81d.js"><link rel="prefetch" href="/note-pages/assets/js/35.773df14e.js"><link rel="prefetch" href="/note-pages/assets/js/36.5db32ea2.js"><link rel="prefetch" href="/note-pages/assets/js/37.1106162c.js"><link rel="prefetch" href="/note-pages/assets/js/38.793ba7d0.js"><link rel="prefetch" href="/note-pages/assets/js/39.488fb9a5.js"><link rel="prefetch" href="/note-pages/assets/js/4.550e6883.js"><link rel="prefetch" href="/note-pages/assets/js/40.9c05b0ae.js"><link rel="prefetch" href="/note-pages/assets/js/41.ae198526.js"><link rel="prefetch" href="/note-pages/assets/js/42.d815456e.js"><link rel="prefetch" href="/note-pages/assets/js/43.1808aff8.js"><link rel="prefetch" href="/note-pages/assets/js/44.c26d9bde.js"><link rel="prefetch" href="/note-pages/assets/js/45.fae5f755.js"><link rel="prefetch" href="/note-pages/assets/js/46.703057c9.js"><link rel="prefetch" href="/note-pages/assets/js/47.ed3a23ce.js"><link rel="prefetch" href="/note-pages/assets/js/48.c5a46ee8.js"><link rel="prefetch" href="/note-pages/assets/js/49.b04c1681.js"><link rel="prefetch" href="/note-pages/assets/js/5.869d288f.js"><link rel="prefetch" href="/note-pages/assets/js/50.249fc2a7.js"><link rel="prefetch" href="/note-pages/assets/js/51.cab74632.js"><link rel="prefetch" href="/note-pages/assets/js/52.e2f231b3.js"><link rel="prefetch" href="/note-pages/assets/js/53.6241e308.js"><link rel="prefetch" href="/note-pages/assets/js/54.7d29c5c0.js"><link rel="prefetch" href="/note-pages/assets/js/55.a9050f95.js"><link rel="prefetch" href="/note-pages/assets/js/56.75828a09.js"><link rel="prefetch" href="/note-pages/assets/js/57.b3f75d67.js"><link rel="prefetch" href="/note-pages/assets/js/58.0cf3bd1c.js"><link rel="prefetch" href="/note-pages/assets/js/59.19f18f1f.js"><link rel="prefetch" href="/note-pages/assets/js/6.d879438f.js"><link rel="prefetch" href="/note-pages/assets/js/60.61940d92.js"><link rel="prefetch" href="/note-pages/assets/js/61.bc890bb0.js"><link rel="prefetch" href="/note-pages/assets/js/62.f487437c.js"><link rel="prefetch" href="/note-pages/assets/js/63.4a91369b.js"><link rel="prefetch" href="/note-pages/assets/js/64.1b0770e4.js"><link rel="prefetch" href="/note-pages/assets/js/65.b56e2b22.js"><link rel="prefetch" href="/note-pages/assets/js/66.dd49594c.js"><link rel="prefetch" href="/note-pages/assets/js/67.22efede4.js"><link rel="prefetch" href="/note-pages/assets/js/68.0d22a8a4.js"><link rel="prefetch" href="/note-pages/assets/js/69.aec9bfeb.js"><link rel="prefetch" href="/note-pages/assets/js/7.e3626849.js"><link rel="prefetch" href="/note-pages/assets/js/70.0c53c20d.js"><link rel="prefetch" href="/note-pages/assets/js/71.6d6db7d6.js"><link rel="prefetch" href="/note-pages/assets/js/72.fdcfb985.js"><link rel="prefetch" href="/note-pages/assets/js/73.a390b48d.js"><link rel="prefetch" href="/note-pages/assets/js/74.e817987f.js"><link rel="prefetch" href="/note-pages/assets/js/75.f144cf4f.js"><link rel="prefetch" href="/note-pages/assets/js/76.7be2f5f1.js"><link rel="prefetch" href="/note-pages/assets/js/77.6568d596.js"><link rel="prefetch" href="/note-pages/assets/js/78.4ff63ca8.js"><link rel="prefetch" href="/note-pages/assets/js/79.daaf791e.js"><link rel="prefetch" href="/note-pages/assets/js/8.f9f716a1.js"><link rel="prefetch" href="/note-pages/assets/js/80.a0605696.js"><link rel="prefetch" href="/note-pages/assets/js/81.ecb125f5.js"><link rel="prefetch" href="/note-pages/assets/js/82.b64b1c42.js"><link rel="prefetch" href="/note-pages/assets/js/83.d13b7f19.js"><link rel="prefetch" href="/note-pages/assets/js/84.c584da75.js"><link rel="prefetch" href="/note-pages/assets/js/85.7992353f.js"><link rel="prefetch" href="/note-pages/assets/js/86.17ad6399.js"><link rel="prefetch" href="/note-pages/assets/js/87.289f9f2f.js"><link rel="prefetch" href="/note-pages/assets/js/88.3496d6e2.js"><link rel="prefetch" href="/note-pages/assets/js/89.0d0c778d.js"><link rel="prefetch" href="/note-pages/assets/js/9.3209071f.js"><link rel="prefetch" href="/note-pages/assets/js/90.245b9fda.js"><link rel="prefetch" href="/note-pages/assets/js/91.806af5f2.js"><link rel="prefetch" href="/note-pages/assets/js/92.8a10f401.js"><link rel="prefetch" href="/note-pages/assets/js/93.ea90ae18.js"><link rel="prefetch" href="/note-pages/assets/js/94.98cc66ef.js"><link rel="prefetch" href="/note-pages/assets/js/95.836e96c5.js"><link rel="prefetch" href="/note-pages/assets/js/96.d4dd3eee.js"><link rel="prefetch" href="/note-pages/assets/js/97.e4275cb9.js"><link rel="prefetch" href="/note-pages/assets/js/98.0e320d92.js"><link rel="prefetch" href="/note-pages/assets/js/99.e6f77650.js">
    <link rel="stylesheet" href="/note-pages/assets/css/0.styles.167a34c7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/note-pages/" class="home-link router-link-active"><!----> <span class="site-name">后端技术栈笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/note-pages/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础知识" class="dropdown-title"><span class="title">基础知识</span> <span class="arrow down"></span></button> <button type="button" aria-label="基础知识" class="mobile-dropdown-title"><span class="title">基础知识</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          算法
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/algorithm/5e022a/" class="nav-link">
  算法
</a></li></ul></li><li class="dropdown-item"><h4>
          计算机网络
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/network/a918ca/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-subitem"><a href="/note-pages/http/" class="nav-link">
  HTTP
</a></li><li class="dropdown-subitem"><a href="/note-pages/tcp-ip/" class="nav-link">
  TCP/IP
</a></li><li class="dropdown-subitem"><a href="/note-pages/socket/" class="nav-link">
  Socket
</a></li></ul></li><li class="dropdown-item"><h4>
          操作系统
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/operating-system/knuk3x/" class="nav-link">
  操作系统
</a></li><li class="dropdown-subitem"><a href="/note-pages/linux/" class="nav-link">
  Linux
</a></li></ul></li><li class="dropdown-item"><h4>
          其他
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/database-system/fyl5c1/" class="nav-link">
  数据库系统
</a></li><li class="dropdown-subitem"><a href="/note-pages/computer-systems/" class="nav-link">
  计算机系统
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程语言" class="dropdown-title"><span class="title">编程语言</span> <span class="arrow down"></span></button> <button type="button" aria-label="编程语言" class="mobile-dropdown-title"><span class="title">编程语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          Java
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/java/5ddf72/" class="nav-link">
  Java基础
</a></li><li class="dropdown-subitem"><a href="/note-pages/java-collection/" class="nav-link">
  Java集合
</a></li><li class="dropdown-subitem"><a href="/note-pages/java-concurrency/" class="nav-link">
  Java并发
</a></li><li class="dropdown-subitem"><a href="/note-pages/jvm/" class="nav-link">
  JVM
</a></li></ul></li><li class="dropdown-item"><h4>
          C/C++
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/cpp/" class="nav-link">
  C++基础
</a></li></ul></li><li class="dropdown-item"><h4>
          Go
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/go/" class="nav-link">
  Go基础
</a></li></ul></li><li class="dropdown-item"><h4>
          其他
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/assembly/" class="nav-link">
  Assembly
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开发框架" class="dropdown-title"><span class="title">开发框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="开发框架" class="mobile-dropdown-title"><span class="title">开发框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          框架
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/spring/" class="nav-link">
  Spring
</a></li></ul></li><li class="dropdown-item"><h4>
          数据库
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/mysql/1dh29a/" class="nav-link">
  MySQL
</a></li><li class="dropdown-subitem"><a href="/note-pages/redis/" class="nav-link">
  Redis
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="架构设计" class="dropdown-title"><span class="title">架构设计</span> <span class="arrow down"></span></button> <button type="button" aria-label="架构设计" class="mobile-dropdown-title"><span class="title">架构设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          分布式
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/distributed-system/01-理论基础/" class="nav-link">
  分布式系统
</a></li></ul></li><li class="dropdown-item"><h4>
          微服务
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/micro-service-in-action/" class="nav-link">
  微服务实战
</a></li></ul></li><li class="dropdown-item"><h4>
          消息队列
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/kafka/" class="nav-link">
  Kafka
</a></li><li class="dropdown-subitem"><a href="/note-pages/rocket-mq/" class="nav-link">
  RocketMQ
</a></li></ul></li><li class="dropdown-item"><h4>
          注册中心
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/zookeeper/" class="nav-link">
  ZooKeeper
</a></li><li class="dropdown-subitem"><a href="/note-pages/eureka/" class="nav-link">
  Eureka
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开发工具" class="dropdown-title"><span class="title">开发工具</span> <span class="arrow down"></span></button> <button type="button" aria-label="开发工具" class="mobile-dropdown-title"><span class="title">开发工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note-pages/git/" class="nav-link">
  Git
</a></li><li class="dropdown-item"><!----> <a href="/note-pages/docker/34kd5q/" class="nav-link">
  Docker
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="理论方法" class="dropdown-title"><span class="title">理论方法</span> <span class="arrow down"></span></button> <button type="button" aria-label="理论方法" class="mobile-dropdown-title"><span class="title">理论方法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note-pages/design-pattern/" class="nav-link">
  设计模式
</a></li><li class="dropdown-item"><!----> <a href="/note-pages/software-engineering/n4r1lx/" class="nav-link">
  软件工程
</a></li></ul></div></div><div class="nav-item"><a href="/note-pages/interview/f05h67/" class="nav-link">
  面试通关
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/note-pages/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础知识" class="dropdown-title"><span class="title">基础知识</span> <span class="arrow down"></span></button> <button type="button" aria-label="基础知识" class="mobile-dropdown-title"><span class="title">基础知识</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          算法
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/algorithm/5e022a/" class="nav-link">
  算法
</a></li></ul></li><li class="dropdown-item"><h4>
          计算机网络
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/network/a918ca/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-subitem"><a href="/note-pages/http/" class="nav-link">
  HTTP
</a></li><li class="dropdown-subitem"><a href="/note-pages/tcp-ip/" class="nav-link">
  TCP/IP
</a></li><li class="dropdown-subitem"><a href="/note-pages/socket/" class="nav-link">
  Socket
</a></li></ul></li><li class="dropdown-item"><h4>
          操作系统
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/operating-system/knuk3x/" class="nav-link">
  操作系统
</a></li><li class="dropdown-subitem"><a href="/note-pages/linux/" class="nav-link">
  Linux
</a></li></ul></li><li class="dropdown-item"><h4>
          其他
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/database-system/fyl5c1/" class="nav-link">
  数据库系统
</a></li><li class="dropdown-subitem"><a href="/note-pages/computer-systems/" class="nav-link">
  计算机系统
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程语言" class="dropdown-title"><span class="title">编程语言</span> <span class="arrow down"></span></button> <button type="button" aria-label="编程语言" class="mobile-dropdown-title"><span class="title">编程语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          Java
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/java/5ddf72/" class="nav-link">
  Java基础
</a></li><li class="dropdown-subitem"><a href="/note-pages/java-collection/" class="nav-link">
  Java集合
</a></li><li class="dropdown-subitem"><a href="/note-pages/java-concurrency/" class="nav-link">
  Java并发
</a></li><li class="dropdown-subitem"><a href="/note-pages/jvm/" class="nav-link">
  JVM
</a></li></ul></li><li class="dropdown-item"><h4>
          C/C++
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/cpp/" class="nav-link">
  C++基础
</a></li></ul></li><li class="dropdown-item"><h4>
          Go
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/go/" class="nav-link">
  Go基础
</a></li></ul></li><li class="dropdown-item"><h4>
          其他
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/assembly/" class="nav-link">
  Assembly
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开发框架" class="dropdown-title"><span class="title">开发框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="开发框架" class="mobile-dropdown-title"><span class="title">开发框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          框架
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/spring/" class="nav-link">
  Spring
</a></li></ul></li><li class="dropdown-item"><h4>
          数据库
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/mysql/1dh29a/" class="nav-link">
  MySQL
</a></li><li class="dropdown-subitem"><a href="/note-pages/redis/" class="nav-link">
  Redis
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="架构设计" class="dropdown-title"><span class="title">架构设计</span> <span class="arrow down"></span></button> <button type="button" aria-label="架构设计" class="mobile-dropdown-title"><span class="title">架构设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          分布式
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/distributed-system/01-理论基础/" class="nav-link">
  分布式系统
</a></li></ul></li><li class="dropdown-item"><h4>
          微服务
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/micro-service-in-action/" class="nav-link">
  微服务实战
</a></li></ul></li><li class="dropdown-item"><h4>
          消息队列
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/kafka/" class="nav-link">
  Kafka
</a></li><li class="dropdown-subitem"><a href="/note-pages/rocket-mq/" class="nav-link">
  RocketMQ
</a></li></ul></li><li class="dropdown-item"><h4>
          注册中心
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/zookeeper/" class="nav-link">
  ZooKeeper
</a></li><li class="dropdown-subitem"><a href="/note-pages/eureka/" class="nav-link">
  Eureka
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开发工具" class="dropdown-title"><span class="title">开发工具</span> <span class="arrow down"></span></button> <button type="button" aria-label="开发工具" class="mobile-dropdown-title"><span class="title">开发工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note-pages/git/" class="nav-link">
  Git
</a></li><li class="dropdown-item"><!----> <a href="/note-pages/docker/34kd5q/" class="nav-link">
  Docker
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="理论方法" class="dropdown-title"><span class="title">理论方法</span> <span class="arrow down"></span></button> <button type="button" aria-label="理论方法" class="mobile-dropdown-title"><span class="title">理论方法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note-pages/design-pattern/" class="nav-link">
  设计模式
</a></li><li class="dropdown-item"><!----> <a href="/note-pages/software-engineering/n4r1lx/" class="nav-link">
  软件工程
</a></li></ul></div></div><div class="nav-item"><a href="/note-pages/interview/f05h67/" class="nav-link">
  面试通关
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/note-pages/java/5ddf72/" class="sidebar-link">第1章 Java程序设计概述</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf72/#_1-1-java-程序设计平台" class="sidebar-link">1.1 Java 程序设计平台</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf72/#_1-2-java-白皮书-的关键术语" class="sidebar-link">1.2 Java ”白皮书” 的关键术语</a></li></ul></li><li><a href="/note-pages/java/5ddf77/" class="sidebar-link">第2章 Java程序设计基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf77/#_2-1-简单示例" class="sidebar-link">2.1 简单示例</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf77/#_2-2-注释" class="sidebar-link">2.2 注释</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf77/#_2-3-数据类型" class="sidebar-link">2.3 数据类型</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf77/#_2-4-变量" class="sidebar-link">2.4 变量</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf77/#_2-5-运算符" class="sidebar-link">2.5 运算符</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf77/#_2-6-字符串" class="sidebar-link">2.6 字符串</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf77/#_2-7-输入输出" class="sidebar-link">2.7 输入输出</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf77/#_2-8-控制流程" class="sidebar-link">2.8 控制流程</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf77/#_2-9-大数值" class="sidebar-link">2.9 大数值</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf77/#_2-10-数组" class="sidebar-link">2.10 数组</a></li></ul></li><li><a href="/note-pages/java/5ddf78/" class="sidebar-link">第3章 对象与类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf78/#_3-1-面向对象程序设计概述" class="sidebar-link">3.1 面向对象程序设计概述</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf78/#_3-2-使用预定义类" class="sidebar-link">3.2 使用预定义类</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf78/#_3-3-用户自定义类" class="sidebar-link">3.3 用户自定义类</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf78/#_3-4-静态域与静态方法" class="sidebar-link">3.4 静态域与静态方法</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf78/#_3-5-按值调用" class="sidebar-link">3.5 按值调用</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf78/#_3-6-对象构造" class="sidebar-link">3.6 对象构造</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf78/#_3-7-包" class="sidebar-link">3.7 包</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf78/#_3-8-类路径" class="sidebar-link">3.8 类路径</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf78/#_3-9-文档注释" class="sidebar-link">3.9 文档注释</a></li></ul></li><li><a href="/note-pages/java/5ddf79/" aria-current="page" class="active sidebar-link">第4章 继承与多态</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf79/#_4-1-类、超类和子类" class="sidebar-link">4.1 类、超类和子类</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf79/#_4-2-object-所有类的超类" class="sidebar-link">4.2 Object：所有类的超类</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf79/#_4-3-接口" class="sidebar-link">4.3 接口</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf79/#_4-4-lambda-表达式" class="sidebar-link">4.4 lambda  表达式</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf79/#_4-5-内部类" class="sidebar-link">4.5 内部类</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf79/#_4-6-泛型数组列表" class="sidebar-link">4.6 泛型数组列表</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf79/#_4-7-对象包装器与自动装箱" class="sidebar-link">4.7 对象包装器与自动装箱</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf79/#_4-8-参数数量可变的方法" class="sidebar-link">4.8 参数数量可变的方法</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf79/#_4-9-枚举类" class="sidebar-link">4.9 枚举类</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf79/#_4-10-继承的设计技巧" class="sidebar-link">4.10 继承的设计技巧</a></li></ul></li><li><a href="/note-pages/java/5ddf7a/" class="sidebar-link">第5章 反射机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf7a/#_5-1-class-类" class="sidebar-link">5.1 Class 类</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf7a/#_5-2-利用反射分析类的能力" class="sidebar-link">5.2 利用反射分析类的能力</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf7a/#_5-3-在运行时使用反射分析对象" class="sidebar-link">5.3 在运行时使用反射分析对象</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf7a/#_5-4-使用反射编写泛型数组代码" class="sidebar-link">5.4 使用反射编写泛型数组代码</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf7a/#_5-5-调用任意方法" class="sidebar-link">5.5 调用任意方法</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf7a/#_5-6-代理" class="sidebar-link">5.6 代理</a></li></ul></li><li><a href="/note-pages/java/5ddf7b/" class="sidebar-link">第6章 异常处理和日志</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf7b/#_6-1-异常" class="sidebar-link">6.1 异常</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf7b/#_6-2-捕获异常" class="sidebar-link">6.2 捕获异常</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf7b/#_6-3-断言" class="sidebar-link">6.3 断言</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddf7b/#_6-4-日志" class="sidebar-link">6.4 日志</a></li></ul></li><li><a href="/note-pages/java/5ddfa4/" class="sidebar-link">第7章 泛型程序设计</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa4/#_7-1-定义简单泛型类" class="sidebar-link">7.1 定义简单泛型类</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa4/#_7-2-定义泛型方法" class="sidebar-link">7.2 定义泛型方法</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa4/#_7-3-类型变量的限定" class="sidebar-link">7.3 类型变量的限定</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa4/#_7-4-泛型代码和虚拟机" class="sidebar-link">7.4 泛型代码和虚拟机</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa4/#_7-5-约束与局限性" class="sidebar-link">7.5 约束与局限性</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa4/#_7-6-泛型类型的继承规则" class="sidebar-link">7.6 泛型类型的继承规则</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa4/#_7-7-通配符类型" class="sidebar-link">7.7 通配符类型</a></li></ul></li><li><a href="/note-pages/java/5ddfa5/" class="sidebar-link">第8章 集合和算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa5/#_8-1-集合框架" class="sidebar-link">8.1 集合框架</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa5/#_8-2-集合" class="sidebar-link">8.2 集合</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa5/#_8-3-映射" class="sidebar-link">8.3 映射</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa5/#_8-4-视图与包装器" class="sidebar-link">8.4 视图与包装器</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa5/#_8-5-算法" class="sidebar-link">8.5 算法</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa5/#_8-6-遗留的集合" class="sidebar-link">8.6 遗留的集合</a></li></ul></li><li><a href="/note-pages/java/8vnc6h/" class="sidebar-link">第9章 Java 8 的流库</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note-pages/java/8vnc6h/#_9-1-从迭代到流的操作" class="sidebar-link">9.1 从迭代到流的操作</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/8vnc6h/#_9-2-流的操作" class="sidebar-link">9.2 流的操作</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/8vnc6h/#_9-3-约简操作" class="sidebar-link">9.3 约简操作</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/8vnc6h/#_9-4-optional-类型" class="sidebar-link">9.4 Optional 类型</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/8vnc6h/#_9-5-收集结果" class="sidebar-link">9.5 收集结果</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/8vnc6h/#_9-6-群组和分区" class="sidebar-link">9.6 群组和分区</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/8vnc6h/#_9-7-基本类型流" class="sidebar-link">9.7 基本类型流</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/8vnc6h/#_9-8-并行流" class="sidebar-link">9.8 并行流</a></li></ul></li><li><a href="/note-pages/java/5ddfa7/" class="sidebar-link">第10章 Java类库</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa7/#_10-1-基础类库" class="sidebar-link">10.1 基础类库</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa7/#_10-2-反射类库" class="sidebar-link">10.2 反射类库</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa7/#_10-3-工具类库" class="sidebar-link">10.3 工具类库</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa7/#_10-4-集合类库" class="sidebar-link">10.4 集合类库</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa7/#_10-5-数学类库" class="sidebar-link">10.5 数学类库</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa7/#_10-6-日志类库" class="sidebar-link">10.6 日志类库</a></li><li class="sidebar-sub-header"><a href="/note-pages/java/5ddfa7/#_10-7-文本类库" class="sidebar-link">10.7 文本类库</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="第4章-继承与多态"><a href="#第4章-继承与多态" class="header-anchor">#</a> 第4章 继承与多态</h1> <p>利用继承，可以基于已存在的类构造一个新类。继承已存在的类就是复用（继承）这些类的方法和域。在此基础上，还可以添加一些新的方法和域，以满足新的需求。这是 Java 程序设计中的一项核心技术。</p> <h2 id="_4-1-类、超类和子类"><a href="#_4-1-类、超类和子类" class="header-anchor">#</a> 4.1 类、超类和子类</h2> <h3 id="定义子类"><a href="#定义子类" class="header-anchor">#</a> 定义子类</h3> <p>下面是由继承 Employee 类来定义 Manager（经理） 类的格式，关键字 extends 表示继承。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
    <span class="token comment">// 添加方法和域</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p><strong>C++ 注释</strong>：在 Java 中，所有的继承都是公有继承，而没有 C++ 中的私有继承和保护继承。</p></blockquote> <p>关键字 extends 表明正在构造的新类派生于一个已存在的类。</p> <ul><li>已存在的类称为<strong>超类</strong>（superclass）、基类（base class）或父类（parent class）；</li> <li>新类称为<strong>子类</strong>（subclass）、派生类（derived class）或孩子类（child class）。</li></ul> <p>在 Manager 类中，增加一个用于存储奖金信息的域，以及一个用于设置这个域的新方法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">double</span> bonus<span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBonus</span><span class="token punctuation">(</span><span class="token keyword">double</span> bonus<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>bonus <span class="token operator">=</span> bonus<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里定义的方法和域并没有什么特别之处。</p> <p>尽管在 Manager 类中没有显式地定义 getName 和 getHireDay 等方法，但属于 Manager 类的对象却可以使用它们，这是因为 Manager 类自动地继承了超类Employee 中的这些方法。</p> <p>同样，从超类中还继承了 name、salary 和 hireDay 这 3 个域。这样一来，每个 Manager 类对象就包含了 4 个域：name 、 salary、 hireDay 和 bonus。</p> <h3 id="覆盖方法"><a href="#覆盖方法" class="header-anchor">#</a> 覆盖方法</h3> <p>超类中的有些方法对子类 Manager 并不一定适用。具体来说，Manager 类中的 getSalary 方法应该返回薪水和奖金的总和。为此，需要提供一个新的方法来<strong>覆盖</strong>（override）超类中的这个方法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
    <span class="token comment">//...</span>
    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//...</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如何实现这个方法呢？乍看起来似乎很简单，只要返回 salary 和 bonus 域的总和就可以了：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> salary <span class="token operator">+</span> bonus<span class="token punctuation">;</span> <span class="token comment">// won't work</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然而，这个方法并不能运行。这是因为 Manager 类的 getSalary 方法<strong>不能够直接地访问超类的私有域。</strong></p> <p>如果 Manager 类的方法一定要访问私有域，就必须借助于公有的接口，Employee 类中的公有方法 getSalary 正是这样一个接口。</p> <p>现在，再试一下。将对 salary 域的访问替换成调用 getSalary 方法。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">double</span> baseSalary <span class="token operator">=</span> <span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// still won't work</span>
    <span class="token keyword">return</span> baseSalary <span class="token operator">+</span> bonus<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这段代码仍然不能运行。问题出现在调用 getSalary 的语句上，这是因为 Manager类 也有一个 getSalary 方法（就是正在实现的这个方法），所以这条语句将会导致无限次地调用自己，直到整个程序崩溃为止。</p> <p>这里需要指出：我们希望调用超类 Employee 中的 getSalary 方法，而不是当前类的这个方法。 为此，可以使用特定的关键字 super 解决这个问题：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">double</span> baseSalary <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> baseSalary <span class="token operator">+</span> bonus<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p><strong>注释</strong>：有人认为 super 与 this 引用是类似的概念，实际上，这样比较并不太恰当。super 不是一个对象的引用，不能将 super 赋给另一个对象变量，它只是一个指示编译器调用超类方法的特殊关键字。</p></blockquote> <p>在子类中可以增加域、增加方法或覆盖超类的方法，然而绝对不能删除继承的任何域和方法。</p> <blockquote><p><strong>C++ 注释</strong>：在 Java 中使用关键字 super 调用超类的方法，而在 C++ 中则采用超类名加上 <code>::</code> 操作符的形式。例如 <code>Employee::getSalary</code>。</p></blockquote> <h3 id="子类构造器"><a href="#子类构造器" class="header-anchor">#</a> 子类构造器</h3> <p>在例子的最后，我们来提供一个构造器。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token keyword">double</span> salary<span class="token punctuation">,</span> <span class="token keyword">int</span> year<span class="token punctuation">,</span> <span class="token keyword">int</span> month<span class="token punctuation">,</span> <span class="token keyword">int</span> day<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> salary<span class="token punctuation">,</span> year<span class="token punctuation">,</span> month<span class="token punctuation">,</span> day<span class="token punctuation">)</span><span class="token punctuation">;</span>
    bonus <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里的关键字 super 具有不同的含义。语句 <code>super(name, salary, year, month, day);</code> 是 “调用超类 Employee 中含有n、s、year、month 和 day 参数的构造器” 的简写形式。</p> <p>由于 Manager 类的构造器不能访问 Employee 类的私有域，所以必须利用 Employee 类的构造器对这部分私有域进行初始化，我们可以通过 super 实现对超类构造器的调用。使用 super 调用构造器的语句必须是子类构造器的第一条语句。</p> <p>如果子类的构造器没有显式地调用超类的构造器，则将自动地调用超类默认（没有参数）的构造器。如果超类没有不带参数的构造器，并且在子类的构造器中又没有显式地调用超类的其他构造器，则 Java 编译器将报告错误。</p> <blockquote><p><strong>C++ 注释</strong>：在 C++ 的构造函数中，使用初始化列表语法调用超类的构造函数，而不调用 super。</p></blockquote> <p>重新定义 Manager 对象的 getSalary 方法之后，奖金就会自动地添加到经理的薪水中 。</p> <h3 id="继承层次"><a href="#继承层次" class="header-anchor">#</a> 继承层次</h3> <p>继承并不仅限于一个层次。由一个公共超类派生出来的所有类的集合被称为<strong>继承层次</strong>（inheritance hierarchy）。</p> <p>在继承层次中，从某个特定的类到其祖先的路径被称为该类的<strong>继承链</strong>（inheritance chain） 。</p> <blockquote><p><strong>C++ 注释</strong>： Java 不支持多继承。 有关 Java 中多继承功能的实现方式，请参看有关接口的讨论。</p></blockquote> <h3 id="多态"><a href="#多态" class="header-anchor">#</a> 多态</h3> <p>下面给出一个例子，其功能为创建一个新经理，并设置他的奖金：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// construct a Manager object</span>
<span class="token class-name">Manager</span> boss <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token string">&quot;Carl Cracker&quot;</span><span class="token punctuation">,</span> <span class="token number">80000</span><span class="token punctuation">,</span> <span class="token number">1987</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
boss<span class="token punctuation">.</span><span class="token function">setBonus</span><span class="token punctuation">(</span><span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>下面定义一个包含 3 个雇员的数组：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> staff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>将经理和雇员都放到数组中：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// fill the staff array with Manager and Employee objects</span>
staff<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> boss<span class="token punctuation">;</span>
staff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">&quot;Harry Hacker&quot;</span><span class="token punctuation">,</span> <span class="token number">50000</span><span class="token punctuation">,</span> <span class="token number">1989</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
staff<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">&quot;Tommy Tester&quot;</span><span class="token punctuation">,</span> <span class="token number">40000</span><span class="token punctuation">,</span> <span class="token number">1990</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>输出每个人的薪水：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// print out information about all Employee objects</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Employee</span> e <span class="token operator">:</span> staff<span class="token punctuation">)</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;name=&quot;</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;,salary=&quot;</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getSalary</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>运行这条循环语句将会输出下列数据 ：</p> <div class="language- extra-class"><pre class="language-text"><code>name=Carl Cracker,salary=85000.0
name=Harry Hacker,salary=50000.0
name=Tommy Tester,salary=40000.0
</code></pre></div><p>这里的 staff[1] 和 staff[2] 仅输出了基本薪水，这是因为它们对应的是 Employee 对象，而 staff[0] 对应的是 Manager 对象，它的 getSalary 方法将奖金与基本薪水加在了一起。</p> <p>尽管这里将 e 声明为 Employee 类型，但实际上 e 既可以引用 Employee 类型的对象，也可以引用 Manager 类型的对象。</p> <p>当 e 引用 Employee 对象时，e.getSalary() 调用的是 Employee 类中的 getSalary  方法；当 e 引用 Manager 对象时，e.getSalary() 调用的是 Manager 类中的 getSalary 方法。 虚拟机知道 e 实际引用的对象类型，因此能够正确地调用相应的方法 。</p> <p>一个对象变量（例如变量 e）可以指示多种实际类型的现象被称为<strong>多态</strong>（polymorphism）。在运行时能够自动地选择调用哪个方法的现象称为<strong>动态绑定</strong>（dynamic binding）。</p> <blockquote><p><strong>C++ 注释</strong>：在 Java 中，不需要将方法声明为虚拟方法（虚函数）。动态绑定是默认的处理方式。如果不希望让一个方法具有虚拟特征，可以将它标记为 final。</p></blockquote> <p>在 Java 中，对象变量是<strong>多态的</strong>，可以将一个子类的对象赋给超类变量（向上转型）。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Employee</span> e<span class="token punctuation">;</span>
e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Employee object expected</span>
e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK, Manager can be used as well</span>
</code></pre></div><p>然而，不能将一个超类的对象赋给子类变量（向下转型）。</p> <p>在 Java 中，子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换。例如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Manager</span><span class="token punctuation">[</span><span class="token punctuation">]</span> managers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Manager</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> staff <span class="token operator">=</span> managers<span class="token punctuation">;</span> <span class="token comment">// OK</span>
</code></pre></div><p>切记 managers 和 staff 引用的是同一个数组。然而，这样将会发生一些令人惊讶的事情。例如：</p> <div class="language-java extra-class"><pre class="language-java"><code>staff<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">&quot;Harry Hacker&quot;</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
</code></pre></div><p>编译器竟然接纳了这个赋值操作。但在这里，staff[0] 与 managers[0] 引用的是同一个对象。这是一种很忌讳发生的情形，当调用 managers[0].setBonus(1000）的时候，将会导致调用一个不存在的实例域，进而搅乱相邻存储空间的内容。</p> <p>为了确保不发生这类错误，所有数组都要牢记创建它们的元素类型，并负责监督仅将类型兼容的引用存储到数组中。</p> <p>例如，使用 new managers[0] 创建的数组是一个经理数组。如果试图存储一个 Employee 类型的引用就会引发 ArrayStoreException 异常。</p> <h3 id="理解方法调用"><a href="#理解方法调用" class="header-anchor">#</a> 理解方法调用</h3> <p>假设要调用 <code>x.f(args)</code>，隐式参数 x 声明为类 C 的一个对象。下面是调用过程的详细描述：</p> <ol><li>编译器查看对象的声明类型和方法名。需要注意的是：有可能存在多个名字为 f，但参数类型不一样的方法。例如，可能存在方法 <code>f(int)</code> 和方法 <code>f(String)</code>。编译器将会一一列举所有 C 类中名为 f 的方法和其超类中访问属性为 public 且名为 f 的方法（超类的私有方法不可访问）。</li> <li>接下来，编译器将查看调用方法时提供的参数类型。如果在所有名为f的方法中存在一个与提供的参数类型完全匹配，就选择这个方法。这个过程被称为<strong>重载解析</strong>（overloadingresolution）。例如，对于 <code>x.f(&quot;Hello&quot;)</code>，编译器将会挑选 <code>f(String)</code>，而不是 <code>f(int)</code>。由于允许类型转换，这个过程可能很复杂。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报告一个错误。</li> <li>如果是 private 方法、static 方法、final 方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法，我们将这种调用方式为<strong>静态绑定</strong>（static binding）。与此对应的是，调用的方法依赖于隐式参数的实际类型，并在运行时实现<strong>动态绑定</strong>（dynamic binding）。</li> <li>当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与所引用对象的<strong>实际</strong>类型最合适的那个类的方法。假设 x 的实际类型是 D，它是 C 类的子类。如果 D 类定义了方法 f(String)，就直接调用它；否则，将在类的超类中寻找 f(String)，以此类推。</li></ol> <p>每次调用方法都要进行搜索，时间开销相当大因此，虚拟机预先为每个类创建了一个<strong>方法表</strong>（method table），其中列出了所有方法的签名和实际调用的方法。</p> <blockquote><p><strong>警告</strong>：在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别是，如果起类方法是 public，子类方法一定要声明为 public。经常会发生这类错误：在声明子类方法的时候，遗漏了 public 修饰符。此时，编译器将会把它解释为试图提供更严格的访问权限。</p></blockquote> <h3 id="阻止继承-final-类和方法"><a href="#阻止继承-final-类和方法" class="header-anchor">#</a> 阻止继承：final 类和方法</h3> <p>有时候，可能希望阻止人们利用某个类定义子类。不允许扩展的类被称为 final 类。如果在定义类的时候使用了 final 修饰符就表明这个类是 final 类。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Executive</span> <span class="token keyword">extends</span> <span class="token class-name">Manager</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>类中的特定方法可以被声明为final。如果这样做，子类就不能覆盖这个方法（final 类中的所有方法自动地成为 final 方法）。 例如</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p><strong>注释</strong>：如果将一个类声明为 final，只有其中的方法自动地成为 final，而不包括域。</p></blockquote> <p>将方法或类声明为 final 主要目的是：确保它们不会在子类中改变语义。例如，Calendar 类中的 getTime 和 setTime 方法都声明为 final。这表明 Calendar 类的设计者负责实现 Date 类与日历状态之间的转换，而不允许子类处理这些问题。同样地，String 类也是 final 类，这意味着不允许任何人定义 String 的子类。换言之，如果有一个 String 的引用，它引用的一定是一个 String 对象，而不可能是其他类的对象。</p> <h3 id="强制类型转换"><a href="#强制类型转换" class="header-anchor">#</a> 强制类型转换</h3> <p>将一个类型强制转换成另外一个类型的过程被称为类型转换。例如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">double</span> x <span class="token operator">=</span> <span class="token number">3.405</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> nx <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> x<span class="token punctuation">;</span>
</code></pre></div><p>将表达式x的值转换成整数类型，舍弃了小数部分。</p> <p>有时候可能需要将某个类的对象引用转换成另外一个类的对象引用。对象引用的转换语法与数值表达式的类型转换类似，仅需要用一对圆括号将目标类名括起来，并放置在需要转换的对象引用之前。例如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Manager</span> boss <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Manager</span><span class="token punctuation">)</span> staff<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>进行类型转换的唯一原因是：在暂时忽视对象的实际类型之后，使用对象的全部功能。</p> <p>将一个子类的引用赋给一个超类变量，编译器是允许的。将一个超类的引用赋给一个子类变量，必须进行类型转换，这样才能够通过运行时的检查。</p> <p>如果试图在继承链上进行向下的类型转换，并且 “谎报” 有关对象包含的内容，会发生什么情况呢？</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Manager</span> boss <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Manager</span><span class="token punctuation">)</span> staff <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
</code></pre></div><p>运行时系统将报告这个错误，并产生一个 ClassCastException 异常。</p> <p>在将超类转换成子类之前，应该使用 instanceof 进行检查。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>staff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">instanceof</span> <span class="token class-name">Manager</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    boss <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Manager</span><span class="token punctuation">)</span> staff<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p><strong>C++ 注释</strong>：Java 使用的类型转换语法来源于 C 语言 “以往糟糕的日子” ，但处理过程却有些像 C++ 的 dynamic_cast 操作。两者只有一点重要的区别：当类型转换失败时，Java 不会生成一个 null 对象，而是抛出一个异常。</p></blockquote> <h3 id="抽象类"><a href="#抽象类" class="header-anchor">#</a> 抽象类</h3> <p>如果自下而上在类的继承层次结构中上移，位于上层的类更具有通用性，甚至可能更加抽象。从某种角度看，祖先类更加通用，人们只将它作为派生其他类的基类，而不作为想使用的特定的实例类。例如，考虑一下对 Employee 类层次的扩展。一名雇员是一个人，一名学生也是一个人。下面将类 Person 和类 Student 添加到类的层次结构中。</p> <p>为什么要花费精力进行这样高层次的抽象呢？每个人都有一些诸如姓名这样的属性。学生与雇员都有姓名属性，因此可以将 getName 方法放置在位于继承关系较高层次的通用超类中。</p> <p>现在，再增加一个 getDescription 方法，它可以返回对一个人的简短描述。在 Employee 类和 Student 类中实现这个方法很容易。但是在 Person 类中应该提供什么内容呢？除了姓名之外，Person类一无所知。当然，可以让 Person.getDescription() 返回一个空字符串。然而，还有一个更好的方法，就是使用 abstract 关键字，这样就完全不需要实现这个方法了。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token class-name">String</span> <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// no implementation required</span>
</code></pre></div><p>为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token class-name">String</span> <span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>除了抽象方法之外，抽象类还可以包含具体数据和具体方法。</p> <blockquote><p><strong>提示</strong>：许多程序员认为，在抽象类中不能包含具体方法。建议尽量将通用的域和方法（不管是否是抽象的）放在超类（不管是否是抽象类）中。</p></blockquote> <p>抽象方法充当着占位的角色，它的具体实现在子类中。扩展抽象类可以有两种选择。一种是在子类中定义部分抽象类方法或不定义抽象类方法，这样必须将子类也标记为抽象类；另一种是定义全部的抽象方法，这样一来，子类就不是抽象的了。</p> <p>类即使不含抽象方法，也可以将类声明为抽象类。</p> <p>抽象类不能被实例化。也就是说，如果将一个类声明为 abstract，就不能创建这个类的对象。</p> <p>需要注意，可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象。</p> <blockquote><p><strong>C++ 注释</strong>：在 C++ 中，有一种在尾部用 <code>=0</code> 标记的抽象方法，称为纯虚函数。类中只要有一个纯虚函数，这个类就是抽象类。</p></blockquote> <h3 id="受保护访问"><a href="#受保护访问" class="header-anchor">#</a> 受保护访问</h3> <p>大家都知道，最好将类中的域标记为 private，而方法标记为 public。任何声明为 private 的内容对其他类都是不可见的。这对于子类来说也完全适用，即子类也不能访问超类的私有域。</p> <p>然而，在有些时候，人们希望超类中的某些方法允许被子类访问，或允许子类的方法访问超类的某个域。为此，需要将这些方法或域声明为 protected。</p> <p>在实际应用中，要谨慎使用 protected 属性。假设需要将设计的类提供给其他程序员使用，而在这个类中设置了一些受保护域，由于其他程序员可以由这个类再派生出新类，并访问其中的受保护域。如果需要对这个类的实现进行修改，就必须通知所有使用这个类的程序员。这违背了 OOP 提倡的数据封装原则。</p> <p>受保护的方法更具有实际意义。如果需要限制某个方法的使用，就可以将它声明为 protected。这表明子类（可能很熟悉祖先类）得到信任，可以正确地使用这个方法，而其他类则不行。这种方法的一个最好的示例就是 Object 类中的 clone 方法。</p> <blockquote><p><strong>C++ 注释</strong>：事实上，Java 中的受保护部分对所有子类及同一个包中的所有其他类都可见。这与 C++ 中的保护机制稍有不同，Java 中的 protected 概念要比C++ 中的安全性差。</p></blockquote> <h3 id="访问修饰符"><a href="#访问修饰符" class="header-anchor">#</a> 访问修饰符</h3> <p>归纳一下 Java 用于控制可见性的 4 个访问修饰符：</p> <table><thead><tr><th>访问修饰符</th> <th>可见性</th></tr></thead> <tbody><tr><td>private</td> <td>仅对本类可见</td></tr> <tr><td>public</td> <td>对所有类可见</td></tr> <tr><td>protected</td> <td>对本包和所有子类可见</td></tr> <tr><td>默认，不需要修饰符</td> <td>对本包可见</td></tr></tbody></table> <h2 id="_4-2-object-所有类的超类"><a href="#_4-2-object-所有类的超类" class="header-anchor">#</a> 4.2 Object：所有类的超类</h2> <p>Object 类是 Java 中所有类的始祖，在 Java 中每个类都是由它扩展而来的。如果没有明确地指出超类，Object 就被认为是这个类的超类。</p> <p>可以使用 Object 类型的变量引用任何类型的对象：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">&quot;Harry Hacker&quot;</span><span class="token punctuation">,</span> <span class="token number">35000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>当然，Object类型的变量只能用于作为各种值的通用持有者。要想对其中的内容进行具体的操作，还需要清楚对象的原始类型，并进行相应的类型转换：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Employee</span> e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Employee</span><span class="token punctuation">)</span> obj<span class="token punctuation">;</span>
</code></pre></div><p>在Java中，只有基本类型（primitive types）不是对象，例如，数值、字符和布尔类型的值都不是对象。所有的数组类型，不管是对象数组还是基本类型的数组都扩展了 Object 类。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> staff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> staff<span class="token punctuation">;</span> <span class="token comment">// OK</span>
obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// OK</span>
</code></pre></div><blockquote><p><strong>C++ 注释</strong>：在 C++ 中没有所有类的根类，不过，每个指针都可以转换成 <code>void*</code> 指针。</p></blockquote> <h3 id="equals-方法"><a href="#equals-方法" class="header-anchor">#</a> equals 方法</h3> <p>Object 类中的 equals 方法用于检测一个对象是否等于另外一个对象。在 Object 类中，这个方法将判断两个对象是否具有相同的引用。如果两个对象具有相同的引用，它们一定是相等的。从这点上看，将其作为默认操作也是合乎情理的。然而，对于多数类来说，这种判断并没有什么意义。经常需要检测两个对象状态的相等性，如果两个对象的状态相等，就认为这两个对象是相等的。</p> <p>例如，如果两个雇员对象的姓名、薪水和雇佣日期都一样，就认为它们是相等的（在实际的雇员数据库中，比较 ID 更有意义。利用下面这个示例演示 equals 方法的实现机制）。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
	<span class="token comment">// ...</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> otherObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// a quick test to see if the objects are identical</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> otherObject<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

        <span class="token comment">// must return false if the explicit parameter is null</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>otherObject <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

        <span class="token comment">// if the classes don't match, they can't be equal</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> otherObject<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

        <span class="token comment">// now we know otherObject is a non-null Employee</span>
        <span class="token class-name">Employee</span> other <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Employee</span><span class="token punctuation">)</span> otherObject<span class="token punctuation">;</span>

        <span class="token comment">// test whether the fields have identical values</span>
        <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> other<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> salary <span class="token operator">==</span> other<span class="token punctuation">.</span>salary <span class="token operator">&amp;&amp;</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>hireDay<span class="token punctuation">,</span> other<span class="token punctuation">.</span>hireDay<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p><strong>提示</strong>：为了防备 name 或 hireDay 可能为 null 的情况，需要使用 Objects.equals 方法。</p></blockquote> <p>在子类中定义 equals 方法时，首先调用超类的 equals。如果检测失败，对象就不可能相等。如果超类中的域都相等，就需要比较子类中的实例域。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Manager</span> <span class="token keyword">extends</span> <span class="token class-name">Employee</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> otherObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>otherObject<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token class-name">Manager</span> other <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Manager</span><span class="token punctuation">)</span> otherObject<span class="token punctuation">;</span>
        <span class="token comment">// super.equals checked that this and other belong to the same class</span>
        <span class="token keyword">return</span> bonus <span class="token operator">==</span> other<span class="token punctuation">.</span>bonus<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="相等测试与继承"><a href="#相等测试与继承" class="header-anchor">#</a> 相等测试与继承</h3> <p>如果隐式和显式的参数不属于同一个类，equals 方法将如何处理呢？这是一个很有争议的问题。在前面的例子中，如果发现类不匹配，equals 方法就返回 false。但是，许多程序员却喜欢使用 instanceof 进行检测：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>otherObject <span class="token keyword">instanceof</span> <span class="token class-name">Employee</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</code></pre></div><p>这样做不但没有解决 otherObject 是子类的情况，并且还有可能会招致一些麻烦。这就是建议不要使用这种处理方式的原因所在。Java语言规范要求 equals 方法具有下面的特性：</p> <ul><li>自反性：对于任何非空引用 x，x.equals(x) 应该返回 true。</li> <li>对称性：对于任何引用 x 和 y，当且仅当 y.equals(x) 返回 true，x.equals(y) 应该返回 true。</li> <li>传递性：对于任何引用 x、y 和 z，如果 x.equals(y) 返回 true，y.equals(z) 返回 true，x.equals(z) 应该返回 true。</li> <li>一致性：如果 x 和 y 引用的对象没有发生变化，反复调用 x.equals(y) 应该返回同样的结果。</li> <li>对于任意非空引用 x，x.equals(null) 应该返回 false。</li></ul> <p>就对称性来说，当参数不属于同一个类的时候需要仔细地思考一下。请看下面这个调用：</p> <div class="language-java extra-class"><pre class="language-java"><code>e<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span>
</code></pre></div><p>这里 e 是一个 Employee 对象，m 是一个 Manager 对象，且两个对象具有相同的姓名薪水和雇佣日期。如果在 Employee.equals 中用 instanceof 进行检测，则返回 true。 然而这意味着反过来调用：</p> <div class="language-java extra-class"><pre class="language-java"><code>m<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
</code></pre></div><p>也需要返回 true。对称性不允许这个方法调用返回 false，或者抛出异常。</p> <p>这就使得 Manager 类受到了束缚。这个类的 equals 方法必须能够用自己与任何一个 Employee 对象进行比较，而不考虑经理拥有的那部分特有信息！猛然间会让人感觉 instanceof 测试并不是完美无瑕。</p> <p>可以从两个截然不同的情况看一下这个问题：</p> <ul><li>如果子类能够拥有自己的相等概念，则对称性需求将强制采用 getClass 进行检测。</li> <li>如果由超类决定相等的概念，那么就可以使用 instanceof 进行检测，这样可以在不同子类的对象之间进行相等的比较。</li></ul> <p>下面给出编写一个完美的 equals 方法的建议：</p> <ol><li>显式参数命名为 otherObject，稍后需要将它转换成另一个叫做 other 的变量 。</li> <li>检测 this 与 otberObject 是否引用同一个对象：<code>if (this == otherobject) return true;</code>。这条语句只是一个优化。实际上，这是一种经常采用的形式。因为计算这个等式要比一个一个地比较类中的域所付出的代价小得多。</li> <li>检测 otherObject 是否为 null，如果为 null，返回 false。这项检测是很必要的。<code>if (otherobject == null) return false;</code>。</li> <li>比较 this 与 otherObject 是否属于同一个类。如果 equals 的语义在每个子类中有所改变，就使用 getClass 检测：<code>if (getClass() != otherobject.getClass()) return false;</code>。如果所有的子类都拥有统一的语义，就使用 instanceof 检测：<code>if (!(otherobject instanceof ClassName)) return false;</code>。</li> <li>将 otberObject 转换为相应的类类型变量：<code>ClassName other = (ClassName) otherobject;</code>。</li> <li>现在开始对所有需要比较的域进行比较了。使用 <code>==</code> 比较基本类型域，使用 equals 比较对象域。如果所有的域都匹配，就返回 true；否则返回 false。如果在子类中重新定义 equals，就要在其中包含调用 <code>super.equals(other)</code>。</li></ol> <blockquote><p><strong>提示</strong>：对于数组类型的域，可以使用静态的 Arrays.equals 方法检测相应的数组元素是否相等。</p></blockquote> <h3 id="hashcode-方法"><a href="#hashcode-方法" class="header-anchor">#</a> hashCode 方法</h3> <p>散列码（hash code）是由对象导出的一个整型值，是没有规律的。如果 x 和 y 是两个不同的对象，x.hashCode() 与 y.hashCode() 基本上不会相同。</p> <p>String 类使用下列算法计算散列码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    hash <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">*</span> hash <span class="token operator">+</span> <span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>hashCode 方法定义在 Object 类中，因此每个对象都有一个默认的散列码，其值为对象的存储地址。</p> <p>看下面这个例子。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">&quot;Ok&quot;</span><span class="token punctuation">;</span>
<span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; &quot;</span> <span class="token operator">+</span> sb<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;Ok&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">StringBuilder</span> tb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; &quot;</span> <span class="token operator">+</span> tb<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>结果：</p> <div class="language- extra-class"><pre class="language-text"><code>2556 1956725890
2556 356573597
</code></pre></div><p>字符串 s 与 t 拥有相同的散列码，这是因为字符串的散列码是由内容导出的。而字符串缓冲 sb 与 tb 却有不同的散列码，这是因为在 StringBuffer 类中没有定义hashCode 方法，它的散列码是由 Object  类的默认 hashCode 方法导出的对象存储地址。</p> <p>如果重新定义 equals 方法，就必须重新定义 hashCode 方法，以便用户可以将对象插入到散列表中。</p> <p>hashCode 方法应该返回一个整型数值（可以是负数），并合理地组合实例域的散列码，以便能够让各个不同的对象产生的散列码更加均匀。</p> <p>例如，下面是 Employee 类的 hashCode 方法。</p> <p>首先，最好使用 null 安全的方法 Objects.hashCode。如果其参数为 null，这个方法会返回 0，否则返回对参数调用 hashCode 的结果。另外，使用静态方法Double.hashCode 来避免创建 Double 对象：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">7</span> <span class="token operator">*</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
        <span class="token operator">+</span> <span class="token number">11</span> <span class="token operator">*</span> <span class="token class-name">Double</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>salary<span class="token punctuation">)</span> 
        <span class="token operator">+</span> <span class="token number">13</span> <span class="token operator">*</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>hireDay<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>还有更好的做法，需要组合多个散列值时，可以调用 Objects.hash 并提供多个参数。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">hash</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> salary<span class="token punctuation">,</span> hireDay<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Objects.hash 方法会对各个参数调用 Objects.hashCode，并组合这些散列值。</p> <p>Equals 与 hashCode 的定义必须一致：如果 x.equals(y) 返回 true，那么 x.hashCode() 就必须与 y.hashCode() 具有相同的值。</p> <blockquote><p><strong>提示</strong>：如果存在数组类型的域，可以使用静态的 Arrays.hashCode 方法计算一个散列码，这个散列码由数组元素的散列码组成。</p></blockquote> <h3 id="tostring-方法"><a href="#tostring-方法" class="header-anchor">#</a> toString 方法</h3> <p>在 Object 中还有一个重要的方法，就是 toString 方法，它用于返回表示对象值的字符串。下面是一个典型的例子。Point 类的 toString 方法将返回下面这样的字符串：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>awt<span class="token punctuation">.</span></span>Point</span><span class="token punctuation">[</span>x<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span>y<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">]</span>
</code></pre></div><p>绝大多数（不是全部）的 toString 方法都遵循这样的格式：类的名字，随后是一对方括号括起来的域值。Employee 类中的 toString 方法的实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
        <span class="token operator">+</span> <span class="token string">&quot;[name=&quot;</span> <span class="token operator">+</span> name
        <span class="token operator">+</span> <span class="token string">&quot;,salary=&quot;</span> <span class="token operator">+</span> salary
        <span class="token operator">+</span> <span class="token string">&quot;,hireDay=&quot;</span> <span class="token operator">+</span> hireDay
        <span class="token operator">+</span> <span class="token string">&quot;]&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>随处可见 toString 方法的主要原因是：只要对象与一个字符串通过操作符 <code>+</code> 连接起来， Java 编译就会自动地调用 toString 方法，以便获得这个对象的字符串描述。 例如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Point</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> message <span class="token operator">=</span> <span class="token string">&quot;The current position is &quot;</span> <span class="token operator">+</span> p<span class="token punctuation">;</span> <span class="token comment">// automatically invokes p.toString()</span>
</code></pre></div><p>如果 x 是任意一个对象，并调用：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
</code></pre></div><p>println 方法就会直接地调用 x.toString()，并打印输出得到的字符串。</p> <p>Object 类定义了 toString 方法，用来打印输出对象所属的类名和散列码。</p> <p>令人烦恼的是，数组继承了 Object 类的 toString 方法，数组类型将按照旧的格式打印。例如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> luckyNumbers <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">13</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">&quot;&quot;</span> <span class="token operator">+</span> luckyNumbers<span class="token punctuation">;</span>
</code></pre></div><p>生成字符串 &quot;[I@la46e30&quot;（前缀 <code>[I</code> 表明是一个整型数纽）。</p> <p>修正的方式是调用静态方法 Arrays.toString。代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token class-name">TuckyNumbers</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>将生成字符串 &quot;[2,3,5,7,11,13]&quot;。</p> <p>要想打印多维数组（即，数组的数组）则需要调用 Arrays.deepToString 方法。</p> <h2 id="_4-3-接口"><a href="#_4-3-接口" class="header-anchor">#</a> 4.3 接口</h2> <h3 id="接口概念"><a href="#接口概念" class="header-anchor">#</a> 接口概念</h3> <p>在 Java 中，接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。下面给出一个具体的示例。</p> <p>Arrays 类中的 sort 方法承诺可以对对象数组进行排序，但要求满足下列前提：对象所属的类必须实现了 Comparable 接口 。</p> <p>下面是 Comparable 接口的代码 ：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">T</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这就是说，任何实现 Comparable 接口的类都需要包含 compareTo 方法，并且这个方法的参数必须是一个 Object 对象，返回一个整型数值。</p> <p>接口中的所有方法自动地属于 public。因此，在接口中声明方法时，不必提供关键字 public。</p> <p>上面这个接口只有一个方法，而有些接口可能包含多个方法。在接口中还可以定义常量。接口绝不能含有实例域，在 Java SE 8 之前，也不能在接口中实现方法。</p> <p>提供实例域和方法实现的任务应该由实现接口的那个类来完成。因此，可以将接口看成是没有实例域的抽象类。但是这两个概念还是有一定区别的，稍后将给出详细的解释。</p> <p>现在，假设希望使用 Arrays 类的 sort 方法对 Employee 对象数组进行排序， Employee 类就必须实现 Comparable 接口。</p> <p>为了让类实现一个接口，通常需要下面两个步骤：</p> <ul><li>将类声明为实现给定的接口。</li> <li>对接口中的所有方法进行定义。</li></ul> <p>要将类声明为实现某个接口，需要使用关键字 implements：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span>
</code></pre></div><p>当然，这里的 Employee 类需要提供 compareTo 方法。假设希望根据雇员的薪水进行比较。</p> <p>以下是 compareTo 方法的实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Employee</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">Double</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>salary<span class="token punctuation">,</span> other<span class="token punctuation">.</span>salary<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在这里，我们使用了静态 Double.compare 方法，如果第一个参数小于第二个参数，它会返回一个负值；如果二者相等则返回 0；否则返回一个正值。</p> <p>为什么不能在 Employee 类直接提供一个 compareTo 方法，而必须实现 Comparable 接口呢？</p> <p>因为 Java 是一种<strong>强类型</strong>（strongly typed）语言。 在调用方法的时候，编译器将会检查这个方法是否存在。在 sort 方法中可能存在下面这样的语句：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>   <span class="token punctuation">{</span>
    <span class="token comment">// rearrange a[i] and a[j]</span>
<span class="token punctuation">}</span>
</code></pre></div><p>编译器必须确认 a[i] 一定有 compareTo 方法。如果 a 是一个 Comparable 对象的数组，就可以确保拥有 compareTo 方法，因为每个实现 Comparable 接口的类都必须提供这个方法的定义。</p> <h3 id="接口的特性"><a href="#接口的特性" class="header-anchor">#</a> 接口的特性</h3> <p>接口不是类 ，不能使用 new 运算符实例化一个接口：</p> <div class="language-java extra-class"><pre class="language-java"><code>x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Comparable</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token comment">// ERROR</span>
</code></pre></div><p>尽管不能构造接口的对象，却能声明接口的变量 ：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Comparable</span> x<span class="token punctuation">;</span> <span class="token comment">// OK</span>
</code></pre></div><p>接口变量只能引用实现了接口的类对象：</p> <div class="language-java extra-class"><pre class="language-java"><code>x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK provided Employee implements Comparable</span>
</code></pre></div><p>可以使用 instanceof 检查一个对象是否实现了某个特定的接口：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>anObject <span class="token keyword">instanceof</span> <span class="token class-name">Comparable</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>
</code></pre></div><p>接口可以被扩展。这里允许存在多条从具有较高通用性的接口到较高专用性的接口的链。例如，设有一个称为 Moveable 的接口：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Moveable</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以以它为基础扩展一个叫做 Powered 的接口：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Powered</span> <span class="token keyword">extends</span> <span class="token class-name">Moveable</span> <span class="token punctuation">{</span>
    <span class="token keyword">double</span> <span class="token function">milesPerGallon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>虽然在接口中不能包含实例域，但却可以包含常量。 例如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Powered</span> <span class="token keyword">extends</span> <span class="token class-name">Moveable</span> <span class="token punctuation">{</span>
    <span class="token keyword">double</span> <span class="token function">milesPerGallon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">double</span> SPEED_LIMIT <span class="token operator">=</span> <span class="token number">95</span><span class="token punctuation">;</span> <span class="token comment">// a public static final constant</span>
<span class="token punctuation">}</span> 
</code></pre></div><p>与接口中的方法都自动地被设置为 public 一样，接口中的域将被自动设为 public static final。</p> <p>尽管每个类只能够拥有一个超类，但却可以实现多个接口。这就为定义类的行为提供了极大的灵活性。例如，Java 中有一个非常重要的内置接口，称为 Cloneable。如果某个类实现了这个 Cloneable 接口，Object 类中的 clone 方法就可以创建类对象的一个拷贝。如果希望自己设计的类拥有克隆和比较的能力，只要实现这两个接口就可以了。使用逗号将实现的各个接口分隔开。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name">Comparable</span>
</code></pre></div><h3 id="接口与抽象类"><a href="#接口与抽象类" class="header-anchor">#</a> 接口与抽象类</h3> <p>为什么 Java 要不辞辛苦地引入接口概念？为什么不将 Comparable 直接设计成如下所示的抽象类。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Comparable</span> <span class="token punctuation">{</span> <span class="token comment">// why not?</span>
    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后， Employee 类再直接扩展这个抽象类，并提供 compareTo 方法的实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">extends</span> <span class="token class-name">Comparable</span> <span class="token punctuation">{</span> <span class="token comment">// why not?</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">Object</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span> 

</code></pre></div><p>非常遗憾，使用抽象类表示通用属性存在这样一个问题： 每个类只能扩展于一个类。 假设 Employee 类已经扩展于一个类，例如 Person，它就不能再像下面这样扩展第二个类了：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token punctuation">,</span> <span class="token class-name">Comparable</span> <span class="token comment">// Error</span>
</code></pre></div><p>但每个类可以像下面这样实现多个接口：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Comparable</span> <span class="token comment">// OK</span>
</code></pre></div><p>有些程序设计语言允许一个类有多个超类，例如 C++。此特性称为多重继承（multiple inheritance）。而 Java 的设计者选择了不支持多继承，其主要原因是多继承会让语言本身变得非常复杂，效率也会降低。</p> <p>实际上，接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。</p> <blockquote><p><strong>C++ 注释</strong>：C++ 具有多重继承特性，随之带来一些诸如虚基类、控制规则和横向指针类型转换等复杂特性。很少有 C++ 程序员使用多继承，有些程序员建议只对 “混合” 风格的继承使用多继承。在 “混合” 风格中，一个主要的基类描述父对象，其他的基类（因此称为混合）扮演辅助的角色。这种风格类似于 Java 类中从一个基类派生，然后实现若干个辅助接口。</p></blockquote> <h3 id="静态方法"><a href="#静态方法" class="header-anchor">#</a> 静态方法</h3> <p><strong>在 Java SE 8 中，允许在接口中增加静态方法。</strong> 理论上讲，没有任何理由认为这是不合法的。只是有违于将接口作为抽象规范的初衷。</p> <p>目前为止，通常的做法是将静态方法放在伴随类中。在标准库中，能看到成对出现的接口和实用工具类，如 Collection/Collections 或 Path/Paths。</p> <p>Paths 类中只包含两个工厂方法。可以由一个字符串序列构造一个文件或目录的路径，如 Paths.get(&quot;jdk1.8.0&quot;, &quot;jre&quot;, &quot;bin&quot;)。在 Java SE 8 中，可以为 Path 接口增加以下方法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Path</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Path</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">String</span> first<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> more<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">FileSystems</span><span class="token punctuation">.</span><span class="token function">getDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPath</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> more<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样一来 ， Paths 类就不再是必要的了。</p> <p>不过整个 Java 库都以这种方式重构也是不太可能的，但是实现自己的接口时，不再需要为实用工具方法另外提供一个伴随类。</p> <h3 id="默认方法"><a href="#默认方法" class="header-anchor">#</a> 默认方法</h3> <p>可以为接口方法提供一个默认实现。必须用 default 修饰符标记这样一个方法。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">default</span> <span class="token keyword">int</span> <span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token class-name">T</span> other<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token comment">// By default, all elements are the same</span>
<span class="token punctuation">}</span>
</code></pre></div><p>默认方法可以调用任何其他方法。例如， Collection 接口可以定义一个便利方法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Collection</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// An abstract method </span>
    <span class="token keyword">default</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样实现 Collection 的程序员就不用操心实现 isEmpty 方法了。</p> <p>默认方法的一个重要用法是 “接口演化”（interface evolution）。 以 Collection 接口为例 ，这个接口作为 Java 的一部分已经有很多年了 。 假设很久以前你提供了这样一个类：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Bag</span> <span class="token keyword">implements</span> <span class="token class-name">Collection</span>
</code></pre></div><p>后来，在 Java SE 8 中，又为这个接口增加了一个 stream 方法。  如果 stream 方法不是一个默认方法，Bag 类将不能编译，因为它没有实现这个新方法。</p> <h3 id="解决默认方法冲突"><a href="#解决默认方法冲突" class="header-anchor">#</a> 解决默认方法冲突</h3> <p>如果先在一个接口中将一个方法定义为默认方法，而又在超类或另一个接口中定义了同样的方法，会发生什么情况？规则如下：</p> <ul><li>超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。</li> <li>接口冲突。如果一个接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型（不论是否是默认参数） 相同的方法，必须覆盖这个方法来解决冲突。</li></ul> <p>先来看第二个规则。考虑另一个包含 getName 方法的接口：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">interface</span> <span class="token class-name">Named</span> <span class="token punctuation">{</span>
    <span class="token keyword">default</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;_&quot;</span> <span class="token operator">+</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果有一个类同时实现了这两个接口会怎么样呢？</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">implements</span> <span class="token class-name">Person</span><span class="token punctuation">,</span> <span class="token class-name">Named</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>类会继承 Person 和 Named 接口提供的两个不一致的 getName 方法。并不是从中选择一个，Java 编译器会报告一个错误，让程序员来解决这个二义性。只需要在 Student 类中提供一个 getName 方法。 在这个方法中，可以选择两个冲突方法中的一个，如下所示：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">implements</span> <span class="token class-name">Person</span><span class="token punctuation">,</span> <span class="token class-name">Named</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">Person</span><span class="token punctuation">.</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>假设 Named 接口没有为 getName 提供默认实现：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">interface</span> <span class="token class-name">Named</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Student 类会从 Person 接口继承默认方法吗？这好像挺有道理，不过，Java 设计者更强调一致性。两个接口如何冲突并不重要。<strong>如果至少有一个接口提供了一个实现，编译器就会报告错误，程序员就必须解决这个二义性。</strong></p> <blockquote><p><strong>注释</strong>：当然，如果两个接口都没有为共享方法提供默认实现，那么就与 Java SE 8 之前的情况一样，这里不存在冲突。实现类可以有两个选择：实现这个方法，或者干脆不实现。如果是后一种情况，这个类本身就是抽象的。</p></blockquote> <p>现在我们考虑另一种情况，一个类扩展了一个超类，同时实现了一个接口，并从超类和接口继承了相同的方法。例如，假设 Person 是一个类，Student 定义为：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">Named</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
</code></pre></div><p>在这种情况下，只会考虑超类方法，接口的所有默认方法都会被忽略。在我们的例子中， Student 从 Person 继承了 getName 方法， Named 接口是否为 getName 提供了默认实现并不会带来什么区别。这正是 “超类优先” 规则。</p> <h3 id="接口与回调"><a href="#接口与回调" class="header-anchor">#</a> 接口与回调</h3> <p>回调（callback）是一种常见的程序设计模式。在这种模式中，可以指出某个特定事件发生时应该采取的动作。</p> <p>在 java.swing 包中有一个 Timer 类，可以使用它在到达给定的时间间隔时发出通告。例如，假如程序中有一个时钟，就可以请求每秒钟获得一个通告，以便更新时钟的表盘。</p> <p>在构造定时器时，需要设置一个时间间隔，并告之定时器，当到达时间间隔时需要做些什么操作。</p> <p>如何告之定时器做什么呢？在很多程序设计语言中，可以提供一个函数名，定时器周期性地调用它。但是，在 Java 标准类库中的类采用的是面向对象方法。它将某个类的对象传递给定时器，然后，定时器调用这个对象的方法。由于对象可以携带一些附加的信息，所以传递一个对象比传递一个函数要灵活得多。</p> <p>当然，定时器需要知道调用哪一个方法，并要求传递的对象所属的类实现了 java.awt.event 包的 ActionListener 接口。下面是这个接口：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ActionListener</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token function">actionPerformed</span><span class="token punctuation">(</span><span class="token class-name">ActionEvent</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当到达指定的时间间隔时定时器就调用 actionPerformed 方法。</p> <p>假设希望每隔 10 秒钟打印一条信息 &quot;At the tone the time is ...&quot;，然后响一声，就要定义一个实现 ActionListener 接口的类，然后将需要执行的语句放在 actionPerformed 方法中 。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">TimePrinter</span> <span class="token keyword">implements</span> <span class="token class-name">ActionListener</span> <span class="token punctuation">{</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actionPerformed</span><span class="token punctuation">(</span><span class="token class-name">ActionEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;At the tone, the time is &quot;</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token class-name">Toolkit</span><span class="token punctuation">.</span><span class="token function">getDefaultToolkit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">beep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>需要注意 actionPerformed 方法的 ActionEvent 参数。 这个参数提供了事件的相关信息，例如，产生这个事件的源对象。</p> <p>接下来，构造这个类的一个对象，并将它传递给 Timer 构造器。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TimePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Timer</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>
t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Timer 构造器的第一个参数是发出通告的时间间隔，它的单位是毫秒。这里希望每隔 10 秒钟通告一次。第二个参数是监听器对象。</p> <h3 id="comparator-接口"><a href="#comparator-接口" class="header-anchor">#</a> Comparator 接口</h3> <p>我们已经了解如何对一个对象数组排序，前提是这些对象是实现了 Comparable 接口的类的实例。例如，可以对一个字符串数组排序，因为 String 类实现了Comparable&lt;String&gt;，String.compareTo 方法可以按字典顺序比较字符串。</p> <p>假设我们希望按长度递增的顺序对字符串进行排序，而不是按字典顺序进行排序。肯定不能让 String 类用两种不同的方式实现 compareTo 方法一一更何况，String 类也不应由我们来修改。</p> <p>要处理这种情况，Arrays.sort 方法还有第二个版本，有一个数组和一个<strong>比较器</strong>（comparator）作为参数，比较器是实现了 Comparator 接口的类的实例。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">T</span> first<span class="token punctuation">,</span> <span class="token class-name">T</span> second<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>要按长度比较字符串，可以如下定义一个实现 Comparator&lt;String&gt; 的类：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">LengthComparator</span> <span class="token keyword">implements</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">String</span> first<span class="token punctuation">,</span> <span class="token class-name">String</span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>具体完成排序时，需要建立一个实例：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>strings<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LengthComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="对象克隆"><a href="#对象克隆" class="header-anchor">#</a> 对象克隆</h3> <p>本节我们会讨论 Cloneable 接口，这个接口指示一个类提供了一个安全的 clone 方法。</p> <p>耍了解克隆的其体含义，先来回忆为一个包含对象引用的变量建立副本时会发生什么。原变量和副本都是同一个对象的引用。这说明，任何一个变量改变都会影响另一个变量。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Employee</span> original <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">&quot;John Public&quot;</span><span class="token punctuation">,</span> <span class="token number">50000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Employee</span> copy <span class="token operator">=</span> original<span class="token punctuation">;</span>
copy<span class="token punctuation">.</span><span class="token function">raiseSalary</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// oops--also changed original</span>
</code></pre></div><p>如果希望 copy是 一个新对象，它的初始状态与 original 相同，但是之后它们各自会有自己不同的状态，这种情况下就可以使用 clone 方法。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Employee</span> copy <span class="token operator">=</span> original<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
copy<span class="token punctuation">.</span><span class="token function">raiseSalary</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK--original unchanged</span>
</code></pre></div><p>clone 方法是 Object 的一个 protected 方法，我们的代码不能直接调用这个方法。只有 Employee 类可以克隆 Employee 对象。</p> <p>思考 Object 类如何实现 clone。它对这个对象一无所知，所以只能逐个域地进行拷贝。如果对象中的所有数据域都是数值或其他基本类型，拷贝这些域没有任何问题。但是如果对象包含子对象的引用，拷贝域就会得到相同子对象的另一个引用，这样一来，原对象和克隆的对象仍然会共享一些信息。</p> <p>默认的克隆操作是 “浅拷贝”，并没有克隆对象中引用的其他对象。</p> <p>浅拷贝会有什么影响吗？这要看具体情况。如果原对象和浅克隆对象共享的子对象是不可变的，那么这种共享就是安全的。例如子对象属于一个不可变的类，如 String。或者在对象的生命期中，子对象一直包含不变的常量，没有更改器方法会改变它，也没有方法会生成它的引用，同样是安全的。</p> <p>不过，通常子对象都是可变的，必须重新定义 clone 方法来建立一个深拷贝，同时克隆所有子对象。</p> <p>对于每一个类 ， 需要确定 ：</p> <ul><li>默认的 clone 方法是否满足要求；</li> <li>是否可以在可变的子对象上调用 clone 来修补默认的 clone 方法；</li> <li>是否不该使用 clone 。</li></ul> <p>实际上第 3 个选项是默认选项。 如果选择第 1 项或第 2 项，类必须：</p> <ul><li>实现 Cloneable 接口；</li> <li>重新定义 clone 方法 ，并指定 public 访问修饰符。</li></ul> <p>在这里，Cloneable 接口的出现与接口的正常使用并没有关系。具体来说，它没有指定 clone 方法，这个方法是从 Object类 继承的。这个接口只是作为一个标记，指示类设计者了解克隆过程。对象对于克隆很 “偏执”，如果一个对象请求克隆，但没有实现这个接口，就会生成一个受查异常。</p> <blockquote><p><strong>注释</strong>：标记接口不包含任何方法，它唯一的作用就是允许在类型查询中使用 instanceof。</p></blockquote> <p>即使 clone 的默认（浅拷贝）实现能够满足要求，还是需要实现 Cloneable 接口，将 clone 重新定义为 public，再调用 super.clone()。</p> <div class="language-java extra-class"><div class="highlight-lines"><br><br><br><div class="highlighted"> </div><br><br><br><br></div><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{</span>
    <span class="token comment">// raise visibility level to public, change return type</span>
    <span class="token keyword">public</span> <span class="token class-name">Employee</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Employee</span><span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>与 Object.clone 提供的浅拷贝相比，目前的 clone 方法并没有为它增加任何功能，只是让这个方法提升为公有的。要建立深拷贝，还需要做更多工作，克隆对象中可变的实例域。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">public</span> <span class="token class-name">Employee</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span> <span class="token punctuation">{</span>
        <span class="token comment">// call Object.clone()</span>
        <span class="token class-name">Employee</span> cloned <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Employee</span><span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// clone mutable fields</span>
        cloned<span class="token punctuation">.</span>hireDay <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Date</span><span class="token punctuation">)</span> hireDay<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> cloned<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果在一个对象上调用 clone，但这个对象的类并没有实现 Cloneable 接口，Object 类的 clone 方法就会抛出一个 CloneNotSupportedException。</p> <blockquote><p><strong>注释</strong>：所有数组类型都有一个 public 的 clone 方法，而不是 protected 的。可以用这个方法建立一个新数组，包含原数组所有元素的副本。</p></blockquote> <h2 id="_4-4-lambda-表达式"><a href="#_4-4-lambda-表达式" class="header-anchor">#</a> 4.4 lambda  表达式</h2> <h3 id="为什么引入-lambda-表达式"><a href="#为什么引入-lambda-表达式" class="header-anchor">#</a> 为什么引入 lambda 表达式</h3> <p>lambda 表达式是一个可传递的代码块，可以在以后执行一次或多次。具体介绍语法（以及解释这个让人好奇的名字）之前，先思考为什么引入 lambda 表达式。</p> <p>我们已经了解了如何按指定时间间隔完成工作。将这个工作放在一个 ActionListener 的 actionPerformed 方法中：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">TimePrinter</span> <span class="token keyword">implements</span> <span class="token class-name">ActionListener</span> <span class="token punctuation">{</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actionPerformed</span><span class="token punctuation">(</span><span class="token class-name">ActionEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// do some work</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>要反复执行这个代码，可以构造 TimePrinter 类的一个实例。 然后把这个实例提交到一个 Timer 对象。</p> <p>或者可以考虑如何用一个定制比较器完成排序。如果想按长度而不是默认的字典顺序对字符串排序，可以向 sort 方法传入一个 Comparator 对象：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">LengthComparator</span> <span class="token keyword">implements</span> <span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span><span class="token class-name">String</span> first<span class="token punctuation">,</span> <span class="token class-name">String</span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>strings<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">LengthComparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这两个例子有一些共同点，都是将一个代码块传递到某个对象（一个定时器，或者一个 sort 方法）。这个代码块会在将来某个时间调用。</p> <p>到目前为止，在 Java 中传递一个代码段并不容易，不能直接传递代码段。Java 是一种面向对象语言，所以必须构造一个对象，这个对象的类需要有一个方法能包含所需的代码。</p> <p>在其他语言中，可以直接处理代码块。 Java 设计者很长时间以来一直拒绝增加这个特性。毕竟， Java 的强大之处就在于其简单性和一致性 。</p> <p>就现在来说，问题已经不是是否增强 Java 来支持函数式编程，而是要如何做到这一点。设计者们做了多年的尝试，终于找到一种适合 Java 的设计。</p> <h3 id="lambda-表达式的语法"><a href="#lambda-表达式的语法" class="header-anchor">#</a> lambda 表达式的语法</h3> <p>再来考虑上一节讨论的排序例子。我们传入代码来检查一个字符串是否比另一个字符串短。这里要计算：</p> <div class="language-java extra-class"><pre class="language-java"><code>first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Java 是一种强类型语言，我们还要指定 first 和 second 的类型：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token punctuation">(</span><span class="token class-name">String</span> first<span class="token punctuation">,</span> <span class="token class-name">String</span> second<span class="token punctuation">)</span>
	<span class="token operator">-&gt;</span> first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>这就是一个 lambda 表达式。lambda 表达式就是一个代码块，以及必须传入代码的变量规范。</p> <p>如果代码要完成的计算无法放在一个表达式中，就可以像写方法一样，把这些代码放在 <code>{}</code> 中，并包含显式的 return 语句。例如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token punctuation">(</span><span class="token class-name">String</span> first<span class="token punctuation">,</span> <span class="token class-name">String</span> second<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>即使 lambda 表达式没有参数，仍然要提供空括号，就像无参数方法一样：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre></div><p>如果可以推导出一个 lambda 表达式的参数类型，则可以忽略其类型。例如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> comp <span class="token operator">=</span> <span class="token punctuation">(</span>first<span class="token punctuation">,</span> second<span class="token punctuation">)</span> <span class="token comment">// Same as (String first, String second)</span>
    <span class="token operator">-&gt;</span> first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>编译器可以推导出 first 和 second 必然是字符串，因为这个 lambda 表达式将赋给一个字符串比较器。</p> <p>如果方法只有一个参数，而且这个参数的类型可以推导得出，那么甚至还可以省略小括号：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">ActionListener</span> <span class="token operator">=</span> event <span class="token operator">-&gt;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;The time is &quot;</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>无需指定 lambda 表达式的返回类型。lambda 表达式的返回类型总是会由上下文推导得出。</p> <blockquote><p><strong>注释</strong>：如果一个 lambda 表达式只在某些分支返回一个值，而在另外一些分支不返回值，是不合法的。</p></blockquote> <h3 id="函数式接口"><a href="#函数式接口" class="header-anchor">#</a> 函数式接口</h3> <p>前面已经讨论过，Java 中有很多封装代码块的接口，例如 ActionListener 或 Comparator。lambda 表达式与这些接口是兼容的。</p> <p>对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个 lambda 表达式。这种接口称为<strong>函数式接口</strong>（functional interface） 。</p> <p>为了展示 lambda 表达式如何转换为函数式接口，下面考虑 Arrays.sort 方法。 Arrays.sort 方法的第二个参数需要一个 Comparator 实例， Comparator 正是函数式接口，可以提供一个 lambda 表达式：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>words<span class="token punctuation">,</span> <span class="token punctuation">(</span>first<span class="token punctuation">,</span> second<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Arrays.sort 方法会接收实现了 Comparator&lt;String&gt; 的某个类的对象。在这个对象上调用 compare 方法会执行这个 lambda 表达式体。与使用传统的内联类相比，这样可能要高效得多。</p> <p>实际上，在 Java 中，对 lambda 表达式所能做的也只是能转换为函数式接口。其他支持函数字面量的程序设计语言中，可以声明函数类型、声明这些类型的变量以及使用变量保存函数表达式。不过，Java 设计者还是决定保持我们熟悉的接口概念，没有为 Java 语言增加函数类型。</p> <h3 id="方法引用"><a href="#方法引用" class="header-anchor">#</a> 方法引用</h3> <p>有时，可能已经有现成的方法可以完成你想要传递到其他代码的某个动作。例如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Timer</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> event <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>但是，如果直接把 println 方法传递到 Timer 构造器就更好了。具体做法如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Timer</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>表达式 <code>System.out::println</code> 是一个<strong>方法引用</strong>（method reference），等价于 lambda 表达式 <code>event -&gt; System.out.println(event)</code>。</p> <p>再来看一个例子，假设你想对字符串排序，而不考虑字母的大小写。 可以传递以下方法表达式 ：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>strings<span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token operator">::</span><span class="token function">compareToIgnoreCase</span><span class="token punctuation">)</span>
</code></pre></div><p>从这些例子可以看出，要用 <code>::</code> 操作符分隔方法名与对象或类名。主要有3种情况：</p> <ul><li>object::instanceMethod</li> <li>Class::staticMethod</li> <li>Class::instanceMethod</li></ul> <p>在前 2 种情况中，方法引用等价于提供方法参数的 lambda 表达式。前面已经提到，<code>System.out::println</code> 等价于 <code>x -&gt; System.out.println(x)</code>。类似地，<code>Math::pow</code> 等价于 <code>(x, y) -&gt; Math.pow(x, y)</code>。</p> <p>对于第 3 种情况，第 1 个参数会成为方法的目标。例如，String::compareTolgnoreCase 等同于 <code>(x，y) -&gt; x.compareTolgnoreCase(y)</code> 。</p> <blockquote><p><strong>注释</strong>：类似于 lambda 表达式，方法引用不能独立存在，总是会转换为函数式接口的实例。</p></blockquote> <p>可以在方法引用中使用 this 参数。例如，<code>this::equals</code> 等同于 <code>x -&gt; this.equals(x)</code> 。使用 super 也是合法的。方法表达式 <code>super::instanceMethod</code> 使用 this 作为目标，会调用给定方法的超类版本。</p> <h3 id="构造器引用"><a href="#构造器引用" class="header-anchor">#</a> 构造器引用</h3> <p>构造器引用与方法引用很类似，只不过方法名为 new。例如，<code>Person::new</code> 是 Person 构造器的一个引用。哪一个构造器呢？这取决于上下文。</p> <p>可以用数组类型建立构造器引用。例如，<code>int[]::new</code> 是一个构造器引用，有一个参数：即数组的长度。这等价于 lambda 表达式 <code>x -&gt; new int[x]</code> 。</p> <h3 id="访问外部变量"><a href="#访问外部变量" class="header-anchor">#</a> 访问外部变量</h3> <p>你可能希望能够在 lambda 表达式中访问外围方法或类中的变量。考虑下面这个例子：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">repeatMessage</span><span class="token punctuation">(</span><span class="token class-name">String</span> text<span class="token punctuation">,</span> <span class="token keyword">int</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> event <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Toolkit</span><span class="token punctuation">.</span><span class="token function">getDefaultToolkit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">beep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span>delay<span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在来看 lambda 表达式中的变量 text。注意这个变量并不是在这个 lambda 表达式中定义的。实际上，这是 repeatMessage 方法的一个参数变量。</p> <p>这里好像会有问题，尽管不那么明显。lambda 表达式的代码可能会在 repeatMessage 调用返回很久以后才运行，而那时这个参数变量已经不存在了 。</p> <p>lambda 表达式有 3 个部分：</p> <ul><li>一个代码块</li> <li>参数</li> <li>自由变量的值，这是指非参数而且不在代码中定义的变量</li></ul> <p>在上述例子中，这个 lambda 表达式有 1 个自由变量 text。表示 lambda 表达式的数据结构必须存储自由变量的值。我们说它被 lambda 表达式<strong>捕获
（captured）</strong>。</p> <p>在 Java 中，要确保所捕获的值是明确定义的，这里有一个重要的限制。在 lambda 表达式中，只能引用值不会改变的变量。例如，下面的做法是不合法的：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">countDown</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> event <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        start<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">// Error: Can't mutate captured variable </span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>start<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span>delay<span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>之所以有这个限制是有原因的。如果在 lambda 表达式中改变变量，并发执行多个动作时就会不安全。</p> <p>另外如果在 lambda 表达式中引用变量，而这个变量可能在外部改变，这也是不合法的。例如，下面就是不合法的：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token class-name">String</span> text<span class="token punctuation">,</span> <span class="token keyword">int</span> count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> event <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">&quot;: &quot;</span> <span class="token operator">+</span> text<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error: Cannot refer to changing i</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里有一条规则：<strong>lambda 表达式中捕获的变量必须是实际上的最终变量（effectively final）</strong>。实际上的最终变量是指，这个变量初始化之后就不会再为它赋新值。</p> <p>lambda 表达式体适用命名冲突和遮蔽的有关规则。<strong>在 lambda 表达式中声明与一个局部变量同名的参数或局部变量是不合法的。</strong></p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Path</span> first <span class="token operator">=</span> <span class="token class-name">Paths</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;/usr/bin&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Comparator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> comp <span class="token operator">=</span> 
	<span class="token punctuation">(</span>first<span class="token punctuation">,</span> second<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> first<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// Error: Variable first already defined</span>
</code></pre></div><p><strong>在一个 lambda 表达式中使用 this 关键字时，是指创建这个 lambda 表达式的方法的 this 参数。</strong> 例如，考虑下面的代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Application</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> event <span class="token operator">-&gt;</span>
			<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
   <span class="token punctuation">}</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>表达式 this.toString() 会调用 Application 对象的 toString 方法，而不是 ActionListener 实例的方法。</p> <h3 id="处理-lambda-表达式"><a href="#处理-lambda-表达式" class="header-anchor">#</a> 处理 lambda 表达式</h3> <p>使用 lambda 表达式的重点是延迟执行（deferred execution）。之所以希望延迟执行，有很多原因：</p> <ul><li>在一个单独的线程中运行代码</li> <li>多次运行代码</li> <li>在算法的适当位置运行代码（例如，排序中的比较操作）</li> <li>发生某种情况时执行代码 （例如，点击了一个按钮、数据到达等等）</li> <li>只在必要时才运行代码</li></ul> <p>假设你想要重复一个动作 n 次。 将这个动作和重复次数传递到一个 repeat 方法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, World!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
</code></pre></div><p>要接受这个 lambda 表达式，需要选择（偶尔可能需要提供）一个函数式接口。在这里，我们可以使用 Runnable 接口：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">repeat</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token class-name">Runnable</span> action<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> action<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>调用 <code>action.run()</code> 时会执行这个 lambda 表达式的主体。</p> <p>下表列出了 Java API 中提供的最重要的函数式接口 。</p> <table><thead><tr><th>函数式接口</th> <th>参数<br>类型</th> <th>返回<br>类型</th> <th>抽象<br>方法名</th> <th>描述</th></tr></thead> <tbody><tr><td>Runnable</td> <td>无</td> <td>void</td> <td>run</td> <td>作为无参数或返回值的动作运行</td></tr> <tr><td>Supplier&lt;T&gt;</td> <td>无</td> <td>T</td> <td>get</td> <td>提供一个 T 类型的值</td></tr> <tr><td>Consumer&lt;T&gt;</td> <td>T</td> <td>void</td> <td>accept</td> <td>处理一个 T 类型的值</td></tr> <tr><td>BiConsumer&lt;T, U&gt;</td> <td>T, U</td> <td>void</td> <td>accept</td> <td>处理 T 和 U 类型的值</td></tr> <tr><td>Function&lt;T, R&gt;</td> <td>T</td> <td>R</td> <td>apply</td> <td>有一个 T 类型参数的函数</td></tr> <tr><td>BiFunction&lt;T, U, R&gt;</td> <td>T, U</td> <td>R</td> <td>apply</td> <td>有 T 和 U 类型参数的函数</td></tr> <tr><td>UnaryOperator&lt;T&gt;</td> <td>T</td> <td>T</td> <td>apply</td> <td>类型 T 上的一元操作符</td></tr> <tr><td>BinaryOperator&lt;T&gt;</td> <td>T, T</td> <td>T</td> <td>apply</td> <td>类型 T 上的二元操作符</td></tr> <tr><td>Predicate&lt;T&gt;</td> <td>T</td> <td>boolean</td> <td>test</td> <td>布尔值函数</td></tr> <tr><td>BiPredicate&lt;T, U&gt;</td> <td>T, U</td> <td>boolean</td> <td>test</td> <td>有两个参数的布尔值函数</td></tr></tbody></table> <blockquote><p><strong>注释</strong>：如果设计你自己的接口，其中只有一个抽象方法，可以用 ＠FunctionalInterface 注解来标记这个接口。 如果你无意中增加了另一个非抽象方法，编译器会产生一个错误消息 。</p></blockquote> <h3 id="再谈-comparator"><a href="#再谈-comparator" class="header-anchor">#</a> 再谈 Comparator</h3> <p>Comparator 接口有很多方便的静态方法来创建比较器。这些方法可以用于 lambda 表达式或方法引用。</p> <p>静态 comparing 方法取一个 “键提取器” 函数，它将类型 T 映射为一个可比较的类型（如 String）。对要比较的对象应用这个函数，然后对返回的键完成比较。例如，假设有一个 Person 对象数组，可以如下按名字对这些对象排序：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>people<span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token operator">::</span><span class="token function">getName</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>可以把比较器与 thenComparing 方法串起来。例如</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>people<span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token operator">::</span><span class="token function">getLastName</span><span class="token punctuation">)</span>
            <span class="token punctuation">.</span><span class="token function">thenComparing</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token operator">::</span><span class="token function">getFirstName</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果两个人的姓相同，就会使用第二个比较方法。</p> <p>可以为 comparing 和 thenComparing 方法提取的键指定一个比较器。例如，可以如下根据人名长度完成排序：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>people<span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparing</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token operator">::</span><span class="token function">getName</span><span class="token punctuation">,</span>
	<span class="token punctuation">(</span>s<span class="token punctuation">,</span> t<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">compare</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>另外，comparing 和 thenComparing 方法都有变体形式，可以避免 int、long 或 double 值的装箱。要完成前一个操作，还有一种更容易的做法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>people<span class="token punctuation">,</span> <span class="token class-name">Comparator</span><span class="token punctuation">.</span><span class="token function">comparingInt</span><span class="token punctuation">(</span>p <span class="token operator">-&gt;</span> p<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="_4-5-内部类"><a href="#_4-5-内部类" class="header-anchor">#</a> 4.5 内部类</h2> <p>内部类（inner class）是定义在另一个类中的类。为什么需要使用内部类呢？其主要原因有以下三点：</p> <ul><li>内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据。</li> <li>内部类可以对同一个包中的其他类隐藏起来。</li> <li>当想要定义一个回调函数且不想编写大量代码时，使用匿名内部类比较便捷。</li></ul> <h3 id="访问外围类数据域"><a href="#访问外围类数据域" class="header-anchor">#</a> 访问外围类数据域</h3> <p><strong>内部类可以访问创建它的外围类对象的数据域。</strong></p> <div class="language-java extra-class"><div class="highlight-lines"><br><br><br><br><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br></div><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">TalkingClock</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> interval<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">boolean</span> beep<span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token class-name">TalkingClock</span><span class="token punctuation">(</span><span class="token keyword">int</span> interval<span class="token punctuation">,</span> <span class="token keyword">boolean</span> beep<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TimePrinter</span> <span class="token keyword">implements</span> <span class="token class-name">ActionListener</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actionPerformed</span><span class="token punctuation">(</span><span class="token class-name">ActionEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;At the tone, the time is &quot;</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>beep<span class="token punctuation">)</span> <span class="token class-name">Toolkit</span><span class="token punctuation">.</span><span class="token function">getDefaultToolkit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">beep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>内部类的对象总有一个隐式引用，它指向了创建它的外部类对象。</p> <h3 id="内部类的特殊语法规则"><a href="#内部类的特殊语法规则" class="header-anchor">#</a> 内部类的特殊语法规则</h3> <p><strong>表达式 <code>OuterClass.this</code> 表示外围类对象的引用。</strong> 例如，可以像下面这样编写 TimePrinter 内部类的 actionPerformed 方法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actionPerformed</span><span class="token punctuation">(</span><span class="token class-name">ActionEvent</span> event<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">TalkingClock</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>beep<span class="token punctuation">)</span> <span class="token class-name">Toolkit</span><span class="token punctuation">.</span><span class="token function">getDefaultToolkit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">beep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>反过来 ，可以采用表达式 <code>outerObject.new InnerClass(construction parameters)</code> 更加明确地编写内部对象的构造器。例如：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">TimePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在这里，最新构造的 TimePrinter 对象的外围类引用被设置为创建内部类对象的方法中的 this 引用。这是一种最常见的情况。通常，this 限定词是多余的。不过，可以通过显式地命名将外围类引用设置为其他的对象。例如，如果 TimePrinter 是一个公有内部类，对于任意的语音时钟都可以构造一个 TimePrinter:</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">TalkingClock</span> jabberer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TalkingClock</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">TalkingClock<span class="token punctuation">.</span>TimePrinter</span> listener <span class="token operator">=</span> jabberer<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">TimePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>需要注意，在外围类的作用域之外，可以这样引用内部类：<code>OuterClass.InnerClass</code></p> <p><strong>内部类中声明的所有静态域必须是 final</strong>。我们希望一个静态域只有一个实例，但是对于每个外部对象，分别有一个单独的内部类实例。如果这个域不是 final，它可能就不是唯一的。</p> <p><strong>内部类不能有静态方法</strong>。Java 语言规范对这个限制没有做任何解释。如果允许有静态方法，但只能访问外围类的静态域和方法。显然，Java 设计者认为相对于这种复杂性来说，它带来的好处有些得不偿失。</p> <h3 id="内部类是否必要、安全"><a href="#内部类是否必要、安全" class="header-anchor">#</a> 内部类是否必要、安全</h3> <p>当在 Java 1.1 的 Java 语言中增加内部类时，很多程序员都认为这是一项很主要的新特性，但这却违背了 Java 要比 C++ 更加简单的设计理念。内部类的语法很复杂。它与访问控制和安全性等其他的语言特性的没有明显的关联。</p> <p>由于增加了一些看似优美有趣，实属没必要的特性，似乎 Java 也开始走上了许多语言饱受折磨的毁灭性道路上。</p> <p>我们并不打算就这个问题给予一个完整的答案。<strong>内部类是一种编译器现象，与虚拟机无关。</strong> 编译器将会把内部类翻译成以 <code>$</code> 分隔外部类名与内部类名的常规类文件，而虚拟机则对此一无所知。</p> <p>如果编译器能够自动地进行转换，那么能不能自己编写程序实现这种机制呢？让我们试试看。将 TimePrinter 定义成一个常规类，并把它置于 TalkingClock 类的外部。在构造 TimePrinter 对象的时候，将创建该对象的 this 指针传递给它。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">TalkingClock</span> <span class="token punctuation">{</span>
   	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TimePrinter</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Timer</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span>interval<span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>
        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">TimePrinter</span> <span class="token keyword">implements</span> <span class="token class-name">ActionListener</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">TalkingClock</span> outer<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">public</span> <span class="token class-name">TimePrinter</span><span class="token punctuation">(</span><span class="token class-name">TalkingClock</span> clock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        outer <span class="token operator">=</span> clock<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在，看一下 actionPerformed 方法，它需要访问 outer.beep。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>outer<span class="token punctuation">.</span>beep<span class="token punctuation">)</span> <span class="token comment">// Error</span>
</code></pre></div><p>这就遇到了一个问题。内部类可以访问外围类的私有数据，但这里的 TimePrinter 类则不行。</p> <p>内部类拥有访问特权，因此与常规类比较起来功能更加强大。</p> <p>可能有人会好奇，既然内部类可以被翻译成名字很古怪的常规类（而虚拟机对此并不了解），内部类如何管理那些额外的访问特权呢？为了揭开这个谜团，让我们利用 ReflectTest 程序查看 TalkingClock 类：</p> <div class="language-java extra-class"><div class="highlight-lines"><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br></div><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">TalkingClock</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> interval<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token keyword">boolean</span> beep<span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token class-name">TalkingClock</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">boolean</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">static</span> <span class="token keyword">boolean</span> access$<span class="token function">0</span><span class="token punctuation">(</span><span class="token class-name">TalkingClock</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>编译器在外围类添加静态方法 access$0，它将返回作为参数传递给它的对象的私有域 beep。这个方法名取决于编译器。</p> <p>这样做不是存在安全风险吗？这种担心是很有道理的。任何人都可以通过调用 access$0 方法很容易地读取到私有域 beep。当然，access$0 不是 Java 的合法方法名。但熟悉类文件结构的黑客可以使用十六进制编辑器轻松地创建一个用虚拟机指令调用那个方法的类文件。由于隐秘地访问方法需要拥有包可见性，所以攻击代码需要与被攻击类放在同一个包中。</p> <h3 id="局部内部类"><a href="#局部内部类" class="header-anchor">#</a> 局部内部类</h3> <p>如果仔细地阅读 TalkingClock 示例的代码会发现，TimePrinter 这个类名字只在 start 方法中创建这个类型的对象时使用了一次 。当遇到这类情况时，可以在一个方法中定义局部类。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">class</span> <span class="token class-name">TimePrinter</span> <span class="token keyword">implements</span> <span class="token class-name">ActionListener</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actionPerformed</span><span class="token punctuation">(</span><span class="token class-name">ActionEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;At the tone, the time is &quot;</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>beep<span class="token punctuation">)</span> <span class="token class-name">Toolkit</span><span class="token punctuation">.</span><span class="token function">getDefaultToolkit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">beep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TimePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Timer</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span>interval<span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>局部类不能用 public 或 private 访问说明符进行声明。它的作用域被限定在声明这个局部类的块中。</strong></p> <p>局部类有一个优势，对外部世界可以完全地隐藏起来。即使 TalkingClock 类中的其他代码也不能访问它。除 start 方法之外，没有任何方法知道 TimePrinter 类的存在。</p> <p>与其他内部类相比较，局部类还有一个优点。<strong>局部类还不仅能够访问包含它们的外部类，还可以访问局部变量。不过，那些局部变量必须事实上为 final。</strong></p> <p>这里，将 TalkingClock 构造器的 interval、beep 移至 start 方法中。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token keyword">int</span> interval<span class="token punctuation">,</span> <span class="token keyword">boolean</span> beep<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">class</span> <span class="token class-name">TimePrinter</span> <span class="token keyword">implements</span> <span class="token class-name">ActionListener</span> <span class="token punctuation">{</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actionPerformed</span><span class="token punctuation">(</span><span class="token class-name">ActionEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span> out<span class="token punctuation">.</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;At the tone, the time is &quot;</span><span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>beep<span class="token punctuation">)</span> <span class="token class-name">Toolkit</span><span class="token punctuation">.</span><span class="token function">getDefaultToolkit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">beep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TimePrinter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Timer</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span>interval<span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>
    t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>为了能够让 actionPerformed 方法工作，TimePrinter 类在 beep 域释放之前进行备份。</p> <p>编译器必须检测对局部变量的访问，为每一个变量建立相应的数据域，并将局部变量拷贝到构造器中，以将这些数据域初始化为局部的副本。</p> <h3 id="匿名内部类"><a href="#匿名内部类" class="header-anchor">#</a> 匿名内部类</h3> <p>假如只创建这个类的个对象，就不必命名了。这种类被称为匿名内部类（anonymous inner class）。</p> <div class="language-java extra-class"><div class="highlight-lines"><br><br><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><div class="highlighted"> </div><br><br><br><br><br></div><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">TalkingClock</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token keyword">int</span> interval<span class="token punctuation">,</span> <span class="token keyword">boolean</span> beep<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">ActionListener</span> listener <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ActionListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actionPerformed</span><span class="token punctuation">(</span><span class="token class-name">ActionEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;At the tone, the time is &quot;</span> <span class="token operator">+</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>beep<span class="token punctuation">)</span> <span class="token class-name">Toolkit</span><span class="token punctuation">.</span><span class="token function">getDefaultToolkit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">beep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token class-name">Timer</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span>interval<span class="token punctuation">,</span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>
        t<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这种语法确实有些难以理解。它的含义是：创建一个实现 ActionListener 接口的类的新对象，需要实现的方法 actionPerformed 定义在括号 <code>{}</code> 内。</p> <p>通常的语法格式为：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span>construction parameters<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// inner class methods and data</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>SuperType 可以是一个接口，内部类实现这个接口。SuperType 可以是一个类，内部类扩展这个接口。</strong></p> <p>由于构造器的名字必须与类名相同，而匿名类没有类名，因此，匿名类不能有构造器。取而代之的是，将构造器参数传递给超类构造器。 尤其是在内部类实现接口的时候，不能有任何构造参数。</p> <p>多年来，Java 程序员习惯的做法是用匿名内部类实现事件监昕器和其他回调。如今最好还是使用 lambda 表达式，这样会简洁得多。</p> <h3 id="双括号初始化"><a href="#双括号初始化" class="header-anchor">#</a> 双括号初始化</h3> <p>假设要构造一个数组列表，并将它传递到一个方法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> friends <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
friends<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;Harry&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
friends<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;Tony&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">invite</span><span class="token punctuation">(</span>friends<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果不再需要这个数组列表，最好让它作为一个匿名列表。作为一个匿名列表，该如何为它添加元素呢？方法如下：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token function">invite</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">{</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;Harry&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> add <span class="token punctuation">(</span><span class="token string">&quot;Tony&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>注意这里的双括号。外层括号建立了 ArrayList 的一个匿名子类。内层括号则是一个对象构造块。</p> <h3 id="静态内部类"><a href="#静态内部类" class="header-anchor">#</a> 静态内部类</h3> <p>有时，使用内部类只是为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类对象。为此，可以将内部类声明为 static，以便取消产生的引用。</p> <p>与常规内部类不同，静态内部类可以有静态域和方法。</p> <p>声明在接口中的内部类自动成为 static 和 public 类。</p> <h2 id="_4-6-泛型数组列表"><a href="#_4-6-泛型数组列表" class="header-anchor">#</a> 4.6 泛型数组列表</h2> <p>在许多程序设计语言中，例如在 C++ 中，必须在编译时就确定整个数组的大小。程序员对此十分反感，因为这样做将迫使程序员做出一些不情愿的折中。</p> <p>在 Java 中，情况就好多了。它允许在运行时确定数组的大小。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> actualSize <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>
<span class="token class-name">Employee</span><span class="token punctuation">[</span><span class="token punctuation">]</span> staff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">[</span>actualSize<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>这段代码并没有完全解决运行时动态更改数组的问题。一旦确定了数组的大小，改变它就不太容易了。</p> <p>在 Java 中，解决这个问题最简单的方法是使用 Java 中另外一个被称为 ArrayList 的类。它使用起来有点像数组，但在添加或删除元素时，具有自动调节数组容量的功能，而不需要为此编写任何代码。</p> <p>ArrayList 是一个采用类型参数（type parameter）的泛型类（generic class）。为了指定数组列表保存的元素对象类型，需要用一对尖括号将类名括起来加在后面，例如 <code>ArrayList&lt;Employee&gt;</code>。</p> <p>下面声明和构造一个保存 Employee 对象的数组列表：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span> staff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>两边都使用类型参数 Employee，这有些繁琐。在 Java SE 7 中，可以省去右边的类型参数：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span> staff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这被称为 “菱形” 语法，因为空尖括号 <code>&lt;&gt;</code> 就像是一个菱形。可以结合 new 操作符使用菱形语法，编译器会检查新值是什么。如果赋值给一个变量，或传递到某个方法，或者从某个方法返回，编译器会检查这个变量、参数或方法的泛型类型，然后将这个类型放在 <code>&lt;&gt;</code> 中。</p> <p>使用 add 方法可以将元素添加到数组列表中。</p> <div class="language-java extra-class"><pre class="language-java"><code>staff<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">&quot;Carl Cracker&quot;</span><span class="token punctuation">,</span> <span class="token number">75000</span><span class="token punctuation">,</span> <span class="token number">1987</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
staff<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">&quot;Harry Hacker&quot;</span><span class="token punctuation">,</span> <span class="token number">50000</span><span class="token punctuation">,</span> <span class="token number">1989</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>数组列表管理着对象引用的一个内部数组。最终，数组的全部空间有可能被用尽。这就显现出数组列表的操作魅力：如果调用 add 且内部数组已经满了，数组列表就将自动地创建一个更大的数组，并将所有对象从较小的数组中拷贝到较大的数组中。</p> <p>如果已经清楚或能够估计出数组可能存储的元素数量，就可以在填充数组之前调用 ensureCapacity 方法：</p> <div class="language-java extra-class"><pre class="language-java"><code>staff<span class="token punctuation">.</span><span class="token function">ensureCapacity</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这个方法调用将分配一个包含 100 个对象的内部数组。</p> <p>另外，还可以把初始容量传递给 ArrayList 构造器：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Employee</span><span class="token punctuation">&gt;</span></span> staff <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p><strong>注意</strong>：数组列表的容量与数组的大小是有区别的。如果为数组分配 100 个元素的存储空间，数组就有 100 个空位置可以使用。而容量为 100 个元素的数组列表只是拥有保存 100 个元素的潜力。</p></blockquote> <p>size 方法将返回数组列表中包含的实际元素数目。例如</p> <div class="language-java extra-class"><pre class="language-java"><code>staff<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>将返回 staff 数组列表的当前元素数量，它等价于数组 a 的 a.length。</p> <p>一旦确认数组列表的大小不再发生变化，就可以调用 trimToSize 方法。这个方法将存储区域的大小调整为当前元素数量所需要的存储空间数目。垃圾回收器将回收多余的存储空间。一旦整理了数组列表的大小，添加新元素就需要花时间再次移动存储块，所以应该在确认不会添加任何元素时，再调用 trimToSize。</p> <blockquote><p><strong>C++ 注释</strong>：ArrayList 类似于 C++ 的 vector 模板。ArrayList 与 vector 都是泛型类型。但是 C++ 的 vector 模板为了便于访问元素重载了 <code>[]</code> 运算符。由于Java 没有运算符重载，必须调用显式的方法。此外，C++ 向量是值拷贝。赋值操作 a = b 将会构造一个与 b 长度相同的新向量 a，并将所有的元素由 b 拷贝到 a，而在 Java 中，这条赋值语句的操作结果是让 a 和 b 引用同一个数组列表。</p></blockquote> <h3 id="访问数组列表元素"><a href="#访问数组列表元素" class="header-anchor">#</a> 访问数组列表元素</h3> <p>使用 get 和 set 方法实现访问或改变数组元素的操作。</p> <p>例如，要设置第 i 个元素，可以使用：</p> <div class="language-java extra-class"><pre class="language-java"><code>staff<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> harry<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p><strong>警告</strong>：只有 i 小于或等于数组列表的大小时，才能够调用 <code>list.set(i, x)</code>。使用 add 方法为数组添加新元素，而不要使用 set 方法，set 只能替换数组中已经存在的元素内容。</p></blockquote> <p>使用下列格式获得数组列表的元素：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Employee</span> e <span class="token operator">=</span> staff<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>除了在数组列表的尾部追加元素之外，还可以在数组列表的中间插入元素，使用带索引参数的 add 方法。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> n <span class="token operator">=</span> staff<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
staff<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>为了插入一个新元素，位于 n 之后的所有元素都要向后移动一个位置。如果插入新元素后，数组列表的大小超过了容量，数组列表就会被重新分配存储空间。</p> <p>同样地，可以从数组列表中间删除一个元素。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Employee</span> e <span class="token operator">=</span> staff<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>位于这个位置之后的所有元素都向前移动一个位置，并且数组的大小减 1。</p> <p>对数组实施插入和删除元素的操作其效率比较低。对于小型数组来说，这一点不必担心。但如果数组存储的元素数比较多，又经常需要在中间位置插入、删除元素，就应该考虑使用链表了。</p> <h2 id="_4-7-对象包装器与自动装箱"><a href="#_4-7-对象包装器与自动装箱" class="header-anchor">#</a> 4.7 对象包装器与自动装箱</h2> <h3 id="对象包装器"><a href="#对象包装器" class="header-anchor">#</a> 对象包装器</h3> <p>有时需要将基本类型转换为对象。所有的基本类型都有一个与之对应的类，称为<strong>包装器</strong>（wrapper）。这些对象包装器类拥有很明显的名字：Integer、Long、Float、Double、Short、Byte、Character、Void 和 Boolean（<strong>前 6 个类派生于公共的超类 Number</strong>）。<strong>对象包装器类是不可变的，即一旦构造了包装器，就不允许更改包装在其中的值。</strong> 同时，对象包装器类还是 final，因此不能定义它们的子类。</p> <p>假设想定义一个整型数组列表。而尖括号中的类型参数不允许是基本类型，也就是说，不允许写成 <code>ArrayList&lt;int&gt;</code>。这里就用到了 Integer 对象包装器类。我们可以声明一个 Integer 对象的数组列表。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="header-anchor">#</a> 自动装箱和拆箱</h3> <p>幸运的是，有一个很有用的特性，从而更加便于添加 int 类型的元素到 <code>ArrayList&lt;lnteger&gt;</code> 中。</p> <p>下面这个调用</p> <div class="language-java extra-class"><pre class="language-java"><code>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>将自动地变换成</p> <div class="language-java extra-class"><pre class="language-java"><code>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token function">value0f</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这种变换被称为<strong>自动装箱</strong>（autoboxing）。</p> <p>相反地，当将一个 Integer 对象赋给一个 int 值时，将会<strong>自动拆箱</strong>。也就是说，编译器将下列语句：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> n <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>翻译成</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> n <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>甚至在算术表达式中也能够自动地装箱和拆箱。例如，可以将自增操作符应用于一个包装器引用：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Integer</span> n <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
n<span class="token operator">++</span><span class="token punctuation">;</span>
</code></pre></div><p>编译器将自动地插入一条对象拆箱的指令，然后进行自增计算，最后再将结果装箱。</p> <p>大多数情况下，容易有一种假象，即基本类型与它们的对象包装器是一样的，只是它们的相等性不同。<code>==</code> 运算符可以应用于对象包装器对象，不过检测的是对象是否指向同一个存储区域；因此，下面的比较通常不会成立：</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token class-name">Integer</span> a <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
<span class="token class-name">Integer</span> b <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre></div><p>解决这个问题的办法是在两个包装器对象比较时调用 equals 方法。</p> <p>关于自动装箱还有几点需要说明。</p> <ul><li>由于包装器类引用可以为 null ，所以自动装箱有可能会抛出一个 NullPointerException 异常。</li> <li>如果在一个条件表达式中混合使用 Integer 和 Double 类型， Integer 值就会拆箱，提升为 double ，再装箱为 Double。</li> <li>装箱和拆箱是编译器认可的，而不是虚拟机。编译器在生成类的字节码时，插入必要的方法调用。</li></ul> <h2 id="_4-8-参数数量可变的方法"><a href="#_4-8-参数数量可变的方法" class="header-anchor">#</a> 4.8 参数数量可变的方法</h2> <p>在 Java SE 5.0 以前的版本中，每个 Java 方法都有固定数量的参数。然而，现在的版本提供了可以用可变的参数数量调用的方法（有时称为 “变参” 方法）。</p> <p>前面已经看到过 printf 方法。 例如，下面的方法调用：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>和</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d %s&quot;</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token string">&quot;widgets&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这两条语句，尽管一个调用包含两个参数，另一个调用包含三个参数，但它们调用的都是同一个方法。</p> <p>printf 方法是这样定义的：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">PrintStream</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token class-name">String</span> format<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">format</span><span class="token punctuation">(</span>format<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里的省略号 <code>...</code> 是 Java 代码的一部分，表明这个方法可以接收任意数量的对象（除 fmt 参数外）。</p> <p>实际上，printf 方法接收两个参数，一个是格式字符串，另一个是 Object[] 数组，其中保存着所有的参数（如果调用者提供的是基本类型的值，自动装箱功能将把它们转换成对象）。现在将扫描 fmt 字符串，并将第 i 个格式说明符与 args[i] 的值匹配起来。</p> <p>对于 printf 的实现者来说，Object ... 参数类型与 Object[] 完全一样。</p> <p>编译器需要对 printf 的每次调用进行转换，以便将参数绑定到数组上，并在必要的时候进行自动装箱：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d %s&quot;</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;widgets&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>用户自己可以定义可变参数的方法，并将参数指定为任意类型，甚至是基本类型。</p> <p>下面是一个简单的示例，其功能为计算若干个数值的最大值。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">double</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> values<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">double</span> largest <span class="token operator">=</span> <span class="token class-name">Double</span><span class="token punctuation">.</span>NEGATIVE_INFINITY<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">double</span> v <span class="token operator">:</span> values<span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">&gt;</span> largest<span class="token punctuation">)</span> largest <span class="token operator">=</span> v<span class="token punctuation">;</span>
    <span class="token keyword">return</span> largest<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以像下面这样调用这个方法：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">double</span> m <span class="token operator">=</span> max <span class="token punctuation">(</span><span class="token number">3.1</span><span class="token punctuation">,</span> <span class="token number">40.4</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre></div><blockquote><p><strong>注释</strong>：允许将一个数组传递给可变参数方法的最后一个参数。</p></blockquote> <h2 id="_4-9-枚举类"><a href="#_4-9-枚举类" class="header-anchor">#</a> 4.9 枚举类</h2> <p>在前面已经看到如何定义枚举类型。下面是一个典型的例子 ：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Size</span> <span class="token punctuation">{</span> SMALL<span class="token punctuation">,</span> MEDIUM<span class="token punctuation">,</span> LARGE<span class="token punctuation">,</span> EXTRA_LARGE <span class="token punctuation">}</span>
</code></pre></div><p>实际上，这个声明定义的类型是一个类，它刚好有 4 个实例，在此尽量不要构造新对象。</p> <p>因此，在比较两个枚举类型的值时，直接使用 <code>==</code> 就可以了。</p> <p>如果需要的话，可以在枚举类型中添加一些构造器、方法和域。当然，构造器只是在构造枚举常量的时候被调用。下面是一个示例：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Size</span> <span class="token punctuation">{</span>
   <span class="token function">SMALL</span><span class="token punctuation">(</span><span class="token string">&quot;S&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">MEDIUM</span><span class="token punctuation">(</span><span class="token string">&quot;M&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">LARGE</span><span class="token punctuation">(</span><span class="token string">&quot;L&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">EXTRA_LARGE</span><span class="token punctuation">(</span><span class="token string">&quot;XL&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token keyword">private</span> <span class="token class-name">Size</span><span class="token punctuation">(</span><span class="token class-name">String</span> abbreviation<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>abbreviation <span class="token operator">=</span> abbreviation<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getAbbreviation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> abbreviation<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token keyword">private</span> <span class="token class-name">String</span> abbreviation<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>所有的枚举类型都是 Enum 类的子类，继承了这个类的许多方法。</p> <p>toString 方法能够返回枚举常量名。例如，<code>Size.SMALL.toString()</code> 将返回字符串 “SMALL”。</p> <p>toString 的逆方法是静态方法 valueOf。例如，语句：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Size</span> s <span class="token operator">=</span> <span class="token class-name">Enum</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token class-name">Size</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">&quot;SMALL&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>将 s 设置成 Size.SMALL。</p> <p>每个枚举类型都有一个静态的 values 方法，它将返回一个包含全部枚举值的数组。例如，如下调用</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Size</span><span class="token punctuation">[</span><span class="token punctuation">]</span> values <span class="token operator">=</span> <span class="token class-name">Size</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>返回包含元素 Size.SMALL，Size.MEDIUM，Size.LARGE 和 Size.EXTRA_LARGE 的数组。</p> <p>ordinal 方法返回 enum 声明中枚举常量的位置，从 0 开始计数。例如：Size.MEDIUM.ordinal() 返回 1。</p> <h2 id="_4-10-继承的设计技巧"><a href="#_4-10-继承的设计技巧" class="header-anchor">#</a> 4.10 继承的设计技巧</h2> <ol><li><p>将公共操作和域放在超类</p></li> <li><p>不要使用受保护的域：protected 机制并不能够带来更好的保护。第一，子类集合是无限制的，任何一个人都能够由某个类派生一个子类，并编写代码以直接访问protected 的实例域，从而破坏了封装性。第二，在 Java 中，在同一个包中的所有类都可以访问 protected 域，而不管它是否为这个类的子类。</p></li> <li><p>使用继承实现 “is-a” 关系</p></li> <li><p>除非所有继承的方法都有意义 ，否则不要使用继承</p></li> <li><p>在覆盖方法时，不要改变预期的行为</p></li> <li><p>使用多态，而非类型信息：使用多态方法或接口编写的代码比使用对多种类型进行检测的代码更加易于维护和扩展。</p></li> <li><p>不要过多地使用反射：反射是很脆弱的，即编译器很难帮助人们发现程序中的错误，因此只有在运行时才发现错误并导致异常。</p></li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/note-pages/java/5ddf78/" class="prev">
        第3章 对象与类
      </a></span> <span class="next"><a href="/note-pages/java/5ddf7a/">
        第5章 反射机制
      </a>
      →
    </span></p></div> </main> <aside items="[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]" class="right-sidebar"><div style="margin-left:20px; margin-bottom: 10px; text-align: center; font-size:16px;font-weight:bold;">此页内容</div> <div class="right-sidebar-wrap"><ul class="right-sidebar-links"><li id="tab-item0" class="right-sidebar-item active"><a href="#_4-1-类、超类和子类" class="right-sidebar-item-level2">
          4.1 类、超类和子类
        </a></li><li id="tab-item1" class="right-sidebar-item"><a href="#定义子类" class="right-sidebar-item-level3">
          定义子类
        </a></li><li id="tab-item2" class="right-sidebar-item"><a href="#覆盖方法" class="right-sidebar-item-level3">
          覆盖方法
        </a></li><li id="tab-item3" class="right-sidebar-item"><a href="#子类构造器" class="right-sidebar-item-level3">
          子类构造器
        </a></li><li id="tab-item4" class="right-sidebar-item"><a href="#继承层次" class="right-sidebar-item-level3">
          继承层次
        </a></li><li id="tab-item5" class="right-sidebar-item"><a href="#多态" class="right-sidebar-item-level3">
          多态
        </a></li><li id="tab-item6" class="right-sidebar-item"><a href="#理解方法调用" class="right-sidebar-item-level3">
          理解方法调用
        </a></li><li id="tab-item7" class="right-sidebar-item"><a href="#阻止继承-final-类和方法" class="right-sidebar-item-level3">
          阻止继承：final 类和方法
        </a></li><li id="tab-item8" class="right-sidebar-item"><a href="#强制类型转换" class="right-sidebar-item-level3">
          强制类型转换
        </a></li><li id="tab-item9" class="right-sidebar-item"><a href="#抽象类" class="right-sidebar-item-level3">
          抽象类
        </a></li><li id="tab-item10" class="right-sidebar-item"><a href="#受保护访问" class="right-sidebar-item-level3">
          受保护访问
        </a></li><li id="tab-item11" class="right-sidebar-item"><a href="#访问修饰符" class="right-sidebar-item-level3">
          访问修饰符
        </a></li><li id="tab-item12" class="right-sidebar-item"><a href="#_4-2-object-所有类的超类" class="right-sidebar-item-level2">
          4.2 Object：所有类的超类
        </a></li><li id="tab-item13" class="right-sidebar-item"><a href="#equals-方法" class="right-sidebar-item-level3">
          equals 方法
        </a></li><li id="tab-item14" class="right-sidebar-item"><a href="#相等测试与继承" class="right-sidebar-item-level3">
          相等测试与继承
        </a></li><li id="tab-item15" class="right-sidebar-item"><a href="#hashcode-方法" class="right-sidebar-item-level3">
          hashCode 方法
        </a></li><li id="tab-item16" class="right-sidebar-item"><a href="#tostring-方法" class="right-sidebar-item-level3">
          toString 方法
        </a></li><li id="tab-item17" class="right-sidebar-item"><a href="#_4-3-接口" class="right-sidebar-item-level2">
          4.3 接口
        </a></li><li id="tab-item18" class="right-sidebar-item"><a href="#接口概念" class="right-sidebar-item-level3">
          接口概念
        </a></li><li id="tab-item19" class="right-sidebar-item"><a href="#接口的特性" class="right-sidebar-item-level3">
          接口的特性
        </a></li><li id="tab-item20" class="right-sidebar-item"><a href="#接口与抽象类" class="right-sidebar-item-level3">
          接口与抽象类
        </a></li><li id="tab-item21" class="right-sidebar-item"><a href="#静态方法" class="right-sidebar-item-level3">
          静态方法
        </a></li><li id="tab-item22" class="right-sidebar-item"><a href="#默认方法" class="right-sidebar-item-level3">
          默认方法
        </a></li><li id="tab-item23" class="right-sidebar-item"><a href="#解决默认方法冲突" class="right-sidebar-item-level3">
          解决默认方法冲突
        </a></li><li id="tab-item24" class="right-sidebar-item"><a href="#接口与回调" class="right-sidebar-item-level3">
          接口与回调
        </a></li><li id="tab-item25" class="right-sidebar-item"><a href="#comparator-接口" class="right-sidebar-item-level3">
          Comparator 接口
        </a></li><li id="tab-item26" class="right-sidebar-item"><a href="#对象克隆" class="right-sidebar-item-level3">
          对象克隆
        </a></li><li id="tab-item27" class="right-sidebar-item"><a href="#_4-4-lambda-表达式" class="right-sidebar-item-level2">
          4.4 lambda  表达式
        </a></li><li id="tab-item28" class="right-sidebar-item"><a href="#为什么引入-lambda-表达式" class="right-sidebar-item-level3">
          为什么引入 lambda 表达式
        </a></li><li id="tab-item29" class="right-sidebar-item"><a href="#lambda-表达式的语法" class="right-sidebar-item-level3">
          lambda 表达式的语法
        </a></li><li id="tab-item30" class="right-sidebar-item"><a href="#函数式接口" class="right-sidebar-item-level3">
          函数式接口
        </a></li><li id="tab-item31" class="right-sidebar-item"><a href="#方法引用" class="right-sidebar-item-level3">
          方法引用
        </a></li><li id="tab-item32" class="right-sidebar-item"><a href="#构造器引用" class="right-sidebar-item-level3">
          构造器引用
        </a></li><li id="tab-item33" class="right-sidebar-item"><a href="#访问外部变量" class="right-sidebar-item-level3">
          访问外部变量
        </a></li><li id="tab-item34" class="right-sidebar-item"><a href="#处理-lambda-表达式" class="right-sidebar-item-level3">
          处理 lambda 表达式
        </a></li><li id="tab-item35" class="right-sidebar-item"><a href="#再谈-comparator" class="right-sidebar-item-level3">
          再谈 Comparator
        </a></li><li id="tab-item36" class="right-sidebar-item"><a href="#_4-5-内部类" class="right-sidebar-item-level2">
          4.5 内部类
        </a></li><li id="tab-item37" class="right-sidebar-item"><a href="#访问外围类数据域" class="right-sidebar-item-level3">
          访问外围类数据域
        </a></li><li id="tab-item38" class="right-sidebar-item"><a href="#内部类的特殊语法规则" class="right-sidebar-item-level3">
          内部类的特殊语法规则
        </a></li><li id="tab-item39" class="right-sidebar-item"><a href="#内部类是否必要、安全" class="right-sidebar-item-level3">
          内部类是否必要、安全
        </a></li><li id="tab-item40" class="right-sidebar-item"><a href="#局部内部类" class="right-sidebar-item-level3">
          局部内部类
        </a></li><li id="tab-item41" class="right-sidebar-item"><a href="#匿名内部类" class="right-sidebar-item-level3">
          匿名内部类
        </a></li><li id="tab-item42" class="right-sidebar-item"><a href="#双括号初始化" class="right-sidebar-item-level3">
          双括号初始化
        </a></li><li id="tab-item43" class="right-sidebar-item"><a href="#静态内部类" class="right-sidebar-item-level3">
          静态内部类
        </a></li><li id="tab-item44" class="right-sidebar-item"><a href="#_4-6-泛型数组列表" class="right-sidebar-item-level2">
          4.6 泛型数组列表
        </a></li><li id="tab-item45" class="right-sidebar-item"><a href="#访问数组列表元素" class="right-sidebar-item-level3">
          访问数组列表元素
        </a></li><li id="tab-item46" class="right-sidebar-item"><a href="#_4-7-对象包装器与自动装箱" class="right-sidebar-item-level2">
          4.7 对象包装器与自动装箱
        </a></li><li id="tab-item47" class="right-sidebar-item"><a href="#对象包装器" class="right-sidebar-item-level3">
          对象包装器
        </a></li><li id="tab-item48" class="right-sidebar-item"><a href="#自动装箱和拆箱" class="right-sidebar-item-level3">
          自动装箱和拆箱
        </a></li><li id="tab-item49" class="right-sidebar-item"><a href="#_4-8-参数数量可变的方法" class="right-sidebar-item-level2">
          4.8 参数数量可变的方法
        </a></li><li id="tab-item50" class="right-sidebar-item"><a href="#_4-9-枚举类" class="right-sidebar-item-level2">
          4.9 枚举类
        </a></li><li id="tab-item51" class="right-sidebar-item"><a href="#_4-10-继承的设计技巧" class="right-sidebar-item-level2">
          4.10 继承的设计技巧
        </a></li></ul></div></aside></div><div class="global-ui"></div></div>
    <script src="/note-pages/assets/js/app.05dcbd87.js" defer></script><script src="/note-pages/assets/js/3.4a2f67fd.js" defer></script><script src="/note-pages/assets/js/2.ab82720e.js" defer></script><script src="/note-pages/assets/js/140.cbfdbe32.js" defer></script>
  </body>
</html>
