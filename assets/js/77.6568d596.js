(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{1022:function(t,v,_){"use strict";_.r(v);var s=_(14),r=Object(s.a)({},(function(){var t=this,v=t.$createElement,s=t._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"nosql"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nosql"}},[t._v("#")]),t._v(" NoSQL")]),t._v(" "),s("p"),s("div",{staticClass:"table-of-contents"},[s("ul",[s("li",[s("a",{attrs:{href:"#redis"}},[t._v("Redis")]),s("ul",[s("li",[s("a",{attrs:{href:"#redis-为什么那么快"}},[t._v("Redis 为什么那么快")])]),s("li",[s("a",{attrs:{href:"#基本类型的编码和底层数据结构"}},[t._v("基本类型的编码和底层数据结构")])]),s("li",[s("a",{attrs:{href:"#redis-的过期删除策略"}},[t._v("Redis 的过期删除策略")])]),s("li",[s("a",{attrs:{href:"#缓存穿透、击穿、雪崩"}},[t._v("缓存穿透、击穿、雪崩")])]),s("li",[s("a",{attrs:{href:"#缓存与数据库一致性问题"}},[t._v("缓存与数据库一致性问题")])]),s("li",[s("a",{attrs:{href:"#如何解决热-key-问题"}},[t._v("如何解决热 Key 问题")])]),s("li",[s("a",{attrs:{href:"#如何解决大-key-问题"}},[t._v("如何解决大 Key 问题")])]),s("li",[s("a",{attrs:{href:"#redis-的持久化机制"}},[t._v("Redis 的持久化机制")])]),s("li",[s("a",{attrs:{href:"#如何基于-setnx-实现分布式锁"}},[t._v("如何基于 SETNX 实现分布式锁")])])])]),s("li",[s("a",{attrs:{href:"#elasticsearch"}},[t._v("ElasticSearch")]),s("ul",[s("li",[s("a",{attrs:{href:"#倒排索引是什么"}},[t._v("倒排索引是什么")])])])])])]),s("p"),t._v(" "),s("h2",{attrs:{id:"redis"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis"}},[t._v("#")]),t._v(" Redis")]),t._v(" "),s("h3",{attrs:{id:"redis-为什么那么快"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis-为什么那么快"}},[t._v("#")]),t._v(" Redis 为什么那么快")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("内存操作")]),t._v("：Redis 的大部分操作都在内存中完成，而内存读写速度远远快于磁盘操作。")]),t._v(" "),s("li",[s("strong",[t._v("高效的数据结构")]),t._v("：Redis 采用了高效的数据结构，这些数据结构在读写操作上都具有高效性能。")]),t._v(" "),s("li",[s("strong",[t._v("单线程模型")]),t._v("：Redis 采用单线程模型，避免了多线程之间的竞争和同步开销。")]),t._v(" "),s("li",[s("strong",[t._v("I/O 多路复用")]),t._v("：Redis 利用 I/O 多路复用机制，能够处理大量的客户端 Socket 请求。")])]),t._v(" "),s("h3",{attrs:{id:"基本类型的编码和底层数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基本类型的编码和底层数据结构"}},[t._v("#")]),t._v(" 基本类型的编码和底层数据结构")]),t._v(" "),s("div",{staticClass:"tag-group"},[s("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("抖音支付")])],1),s("p",[s("img",{attrs:{src:_(449),alt:"image-20230717153319313.drawio"}})]),t._v(" "),s("h3",{attrs:{id:"redis-的过期删除策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis-的过期删除策略"}},[t._v("#")]),t._v(" Redis 的过期删除策略")]),t._v(" "),s("div",{staticClass:"tag-group"},[s("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("抖音支付")])],1),s("p",[t._v("Redis 选择 "),s("RouterLink",{attrs:{to:"/redis/xv2zdt/#定期删除策略"}},[s("strong",[t._v("惰性删除")])]),t._v("+"),s("RouterLink",{attrs:{to:"/redis/xv2zdt/#惰性删除策略"}},[s("strong",[t._v("定期删除")])]),t._v(" 两种策略配合使用，定期删除策略不在是每次都扫描全部 key，而是随机抽取一部分 key 进行检查，再配合惰性删除策略，以求在合理使用 CPU 和避免内存浪费之间取得平衡。")],1),t._v(" "),s("h3",{attrs:{id:"缓存穿透、击穿、雪崩"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透、击穿、雪崩"}},[t._v("#")]),t._v(" 缓存穿透、击穿、雪崩")]),t._v(" "),s("div",{staticClass:"tag-group"},[s("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("阿里")])],1),s("p",[s("RouterLink",{attrs:{to:"/redis/afqdqg/#_4-1-缓存穿透"}},[s("strong",[t._v("缓存穿透")])]),t._v(" 是指查找的数据在 "),s("strong",[t._v("缓存和数据库中都不存在")]),t._v("，导致每一次请求数据从缓存中都获取不到，而将请求打到数据库服务器。")],1),t._v(" "),s("p",[t._v("解决方案：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("限制非法请求")]),t._v("：判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。")]),t._v(" "),s("li",[s("strong",[t._v("缓存空对象")]),t._v("：存储层未命中，仍将空值存入缓存层，客户端再次访问数据时，缓存层会直接返回空值。")]),t._v(" "),s("li",[s("strong",[t._v("布隆过滤器")]),t._v("：将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。")])]),t._v(" "),s("p",[s("RouterLink",{attrs:{to:"/redis/afqdqg/#_4-2-缓存击穿"}},[s("strong",[t._v("缓存击穿")])]),t._v(" 是指 "),s("strong",[t._v("超级热点数据突然过期")]),t._v("，导致大量针对超级热点的数据请求在过期期间直接打到数据库，引起数据库压力瞬间增大，造成过大压力。")],1),t._v(" "),s("p",[t._v("解决方案：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("永不过期")]),t._v("：热点数据不设置过期时间，所以不会出现上述问题，这是 “物理”上的永不过期。或者为每个数据设置逻辑过期时间，当发现热点数据逻辑过期时，使用单独的线程重建缓存。")]),t._v(" "),s("li",[s("strong",[t._v("加互斥锁")]),t._v("：对数据访问加互斥锁，当一个线程访问该数据时，其他线程只能等待。这个线程访问过后，缓存中的数据将被重建，届时其他线程就可以直接从缓存中取值。")])]),t._v(" "),s("p",[s("RouterLink",{attrs:{to:"/redis/afqdqg/#_4-3-缓存雪崩"}},[s("strong",[t._v("缓存雪崩")])]),t._v(" 是指缓存中 "),s("strong",[t._v("大量缓存数据在同一时间过期")]),t._v(" 或 "),s("strong",[t._v("Redis 实例宕机")]),t._v("，导致大量请求进入数据库。")],1),t._v(" "),s("p",[t._v("大量缓存数据在同一时间过期的解决方案：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("避免数据同时过期")]),t._v("：设置过期时间时，附加一个随机数，避免大量的 key 同时过期。")]),t._v(" "),s("li",[s("strong",[t._v("服务限流、降级")]),t._v("：启动服务限流机制，减少业务应用对缓存服务的访问。若应用访问的不是核心数据，则可以直接返回预定义信息/空值/错误信息。")])]),t._v(" "),s("p",[t._v("Redis 实例宕机的解决方案：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("构建高可用的 Redis 服务")]),t._v("：采用哨兵或者集群模式，部署多个 Redis 实例，个别节点宕机，依然可以保持服务的整体可用。")]),t._v(" "),s("li",[s("strong",[t._v("服务熔断、降级")]),t._v("：启动服务熔断机制，暂停业务应用对缓存服务的访问。若应用访问的不是核心数据，则可以直接返回预定义信息/空值/错误信息。")])]),t._v(" "),s("h3",{attrs:{id:"缓存与数据库一致性问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缓存与数据库一致性问题"}},[t._v("#")]),t._v(" 缓存与数据库一致性问题")]),t._v(" "),s("div",{staticClass:"tag-group"},[s("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("快手商业化")])],1),s("p",[t._v("引入缓存后，需要考虑缓存与数据库一致性问题，可选的方案有： "),s("RouterLink",{attrs:{to:"/redis/afqdqg/#更新缓存"}},[s("strong",[t._v("更新缓存")])]),t._v("、 "),s("RouterLink",{attrs:{to:"/redis/afqdqg/#删除缓存"}},[s("strong",[t._v("删除缓存")])]),t._v("。")],1),t._v(" "),s("p",[t._v("采用 "),s("strong",[t._v("更新缓存")]),t._v(" 方案，在 "),s("strong",[t._v("并发")]),t._v(" 场景下无法保证缓存和数据一致性（详见 "),s("RouterLink",{attrs:{to:"/redis/afqdqg/#更新缓存方案中的并发问题"}},[t._v("更新缓存方案中的并发问题")]),t._v("），解决方案是加 "),s("strong",[t._v("分布锁")]),t._v(" ，但这种方案存在 "),s("strong",[t._v("缓存资源浪费")]),t._v(" 和 "),s("strong",[t._v("机器性能浪费")]),t._v(" 的情况。")],1),t._v(" "),s("p",[t._v("采用 "),s("strong",[t._v("先删除缓存，再更新数据库")]),t._v(" 方案，在 "),s("strong",[t._v("并发")]),t._v(" 场景下依旧有不一致问题（详见 "),s("RouterLink",{attrs:{to:"/redis/afqdqg/#删除缓存方案中的并发问题"}},[t._v("删除缓存方案中的并发问题")]),t._v("），解决方案是 "),s("strong",[t._v("延迟双删")]),t._v(" ，但这个延迟时间很难评估。")],1),t._v(" "),s("p",[t._v("采用 "),s("strong",[t._v("先更新数据库，再删除缓存")]),t._v(" 方案，为了保证两步都成功执行，需配合 "),s("strong",[t._v("消息队列")]),t._v(" 或 "),s("strong",[t._v("订阅变更日志")]),t._v(" 的方案来做，本质是通过 "),s("strong",[t._v("重试")]),t._v(" 的方式保证数据最终一致。")]),t._v(" "),s("p",[t._v("采用 "),s("strong",[t._v("先更新数据库，再删除缓存")]),t._v(" 方案， "),s("strong",[t._v("读写分离 + 主从复制延迟")]),t._v(" 可能导致缓存和数据库不一致（详见 "),s("RouterLink",{attrs:{to:"/redis/afqdqg/#主从复制延迟问题"}},[t._v("主从复制延迟问题")]),t._v("），缓解此问题的方案是 "),s("RouterLink",{attrs:{to:"/redis/afqdqg/#延迟双删"}},[s("strong",[t._v("延迟双删")])]),t._v(" ，发送 "),s("strong",[t._v("延迟消息")]),t._v(" 到队列中，延迟删除缓存，同时要控制主从库延迟，尽可能降低不一致发生的概率。")],1),t._v(" "),s("h3",{attrs:{id:"如何解决热-key-问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何解决热-key-问题"}},[t._v("#")]),t._v(" 如何解决热 Key 问题")]),t._v(" "),s("p",[s("strong",[t._v("什么是热 Key")]),t._v("：在极短的时间内访问频次非常高的 key。")]),t._v(" "),s("p",[s("strong",[t._v("热 Key 产生的影响")]),t._v("：")]),t._v(" "),s("ul",[s("li",[t._v("Redis 节点的网卡带宽被打满，出现丢包重传，请求波动耗时大幅上升。")]),t._v(" "),s("li",[t._v("Redis 节点数据倾斜，缓存服务被打垮，大量的请求穿透到 DB，DB 扛不住宕机。")])]),t._v(" "),s("p",[s("strong",[t._v("如何发现热 Key")]),t._v("：")]),t._v(" "),s("ul",[s("li",[t._v("根据业务 "),s("strong",[t._v("经验")]),t._v(" 预估。")]),t._v(" "),s("li",[t._v("在客户端、Proxy 层、TCP 协议层 "),s("strong",[t._v("监听请求")]),t._v("，将统计数据发送给一个聚合计算的服务进行统计。")]),t._v(" "),s("li",[t._v("Redis 集群监控。如果某个实例 "),s("strong",[t._v("出现 QPS 倾斜")]),t._v("，说明可能存在热 key。")]),t._v(" "),s("li",[t._v("Redis 4.0 执行 "),s("code",[t._v("redis-cli --hotkeys")]),t._v(" 即可。但耗时可能很长，且实时性较差。")])]),t._v(" "),s("p",[s("strong",[t._v("热 Key 的解决方案")]),t._v("：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("本地缓存")]),t._v("，通过 Guava cahce、HashMap 等将热 key 保存在 JVM 中。")]),t._v(" "),s("li",[t._v("添加后缀产生热 key 的 "),s("strong",[t._v("冗余备份")]),t._v("，通过分片特性分散到不同的节点上。客户端访问时随机选择一个 key 访问。缺点是缓存的维护成本大，同时需要维护多个 key。")]),t._v(" "),s("li",[s("strong",[t._v("增加 Slave 节点")]),t._v(" 来分流读请求。缺点是使用机器硬抗热 key 请求，资源耗费严重。")])]),t._v(" "),s("h3",{attrs:{id:"如何解决大-key-问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何解决大-key-问题"}},[t._v("#")]),t._v(" 如何解决大 Key 问题")]),t._v(" "),s("p",[s("strong",[t._v("什么是大 Key")]),t._v("：value 占用内存空间大的 key。")]),t._v(" "),s("p",[s("strong",[t._v("大 Key 产生的影响")]),t._v("：")]),t._v(" "),s("ul",[s("li",[t._v("性能下降、内存不足、数据倾斜以及主从同步延迟。")])]),t._v(" "),s("p",[s("strong",[t._v("如何发现大 Key")]),t._v("：")]),t._v(" "),s("ul",[s("li",[t._v("通过使用 Redis 的 "),s("strong",[t._v("SCAN 命令")]),t._v("，我们可以逐步遍历数据库中的所有 Key。结合其他命令（如 STRLEN、LLEN、SCARD、HLEN 等）可以识别出大 Key。SCAN 命令的优势在于它可以在不阻塞 Redis 实例的情况下进行遍历。")]),t._v(" "),s("li",[t._v("执行 "),s("code",[t._v("redis-cli --hotkeys")]),t._v(" 即可。")]),t._v(" "),s("li",[t._v("使用开源工具 "),s("strong",[t._v("Redis RDB Tool")]),t._v("s，分析 RDB 文件，扫描出 Redis 大 key。")])]),t._v(" "),s("p",[s("strong",[t._v("大 Key 的解决方案")]),t._v("：")]),t._v(" "),s("ul",[s("li",[t._v("大 key 非热 key，如果不是必要的信息，可以 "),s("strong",[t._v("直接删除")]),t._v("（del 或 unlink）。\n"),s("blockquote",[s("p",[t._v("4.0 之前，使用（scan/sscan/hscan/zscan）将大 key 逐步找出并删除（ltrim/zremrangebyscore/hdel/srem）。4.0 之后，使用 unlink，后台线程会将大 key 异步删除。")])])]),t._v(" "),s("li",[t._v("业务拆分，"),s("strong",[t._v("将 key 的含义更细粒度化")]),t._v("，避免大 key 出现。")]),t._v(" "),s("li",[s("strong",[t._v("数据结构上拆分")]),t._v("。如果大 key 是个 json，可以通过 MSET 命令，将这个 key 的内容打散到各个实例中，减小大 key 对数据量倾斜的影响；如果是大 list，可以拆成多个 list；其他数据结构同理。")]),t._v(" "),s("li",[t._v("对大 key 的 value "),s("strong",[t._v("压缩")]),t._v("。其中 google 提出的 "),s("strong",[t._v("snappy")]),t._v(" 算法较常用。")]),t._v(" "),s("li",[t._v("Redis 没有开启非同步删除机制时，设置过期时间一定要 "),s("strong",[t._v("避免大批量键同时过期的现象")]),t._v("。如果有这种情况，最好给过期时间加个随机范围，缓解大量键同时过期，造成客户端等待超时的现象。")]),t._v(" "),s("li",[t._v("对于长文本，建议使用文档型数据库，例如 "),s("strong",[t._v("MongoDB")]),t._v(" 等。")]),t._v(" "),s("li",[t._v("对一致性要求不高的场景，尝试使用 "),s("strong",[t._v("客户端缓存")]),t._v("。")])]),t._v(" "),s("h3",{attrs:{id:"redis-的持久化机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redis-的持久化机制"}},[t._v("#")]),t._v(" Redis 的持久化机制")]),t._v(" "),s("div",{staticClass:"tag-group"},[s("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("抖音支付")]),s("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("腾讯PCG")])],1),s("p",[t._v("Redis 共有两种数据持久化的方式：")]),t._v(" "),s("p",[s("RouterLink",{attrs:{to:"/redis/ln38f6/#_5-1-rdb-日志"}},[s("strong",[t._v("AOF 日志")])]),t._v("：每执行一条 "),s("strong",[t._v("写操作命令")]),t._v("，就把该命令以 "),s("strong",[t._v("追加")]),t._v(" 的方式写入到一个文件里；")],1),t._v(" "),s("p",[s("RouterLink",{attrs:{to:"/redis/ln38f6/#_5-2-aof-日志"}},[s("strong",[t._v("RDB 快照")])]),t._v("：将某一时刻的 "),s("strong",[t._v("内存数据")]),t._v("，以 "),s("strong",[t._v("二进制")]),t._v(" 的方式写入磁盘；")],1),t._v(" "),s("p",[s("strong",[t._v("混合持久化")]),t._v("：混合持久化工作在 AOF 日志重写过程，前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据。")]),t._v(" "),s("h3",{attrs:{id:"如何基于-setnx-实现分布式锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何基于-setnx-实现分布式锁"}},[t._v("#")]),t._v(" 如何基于 SETNX 实现分布式锁")]),t._v(" "),s("p",[t._v("https://www.yuque.com/hollis666/uzgwh1/feovxr7gr8ois5yt")]),t._v(" "),s("h2",{attrs:{id:"elasticsearch"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#elasticsearch"}},[t._v("#")]),t._v(" ElasticSearch")]),t._v(" "),s("h3",{attrs:{id:"倒排索引是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#倒排索引是什么"}},[t._v("#")]),t._v(" 倒排索引是什么")]),t._v(" "),s("div",{staticClass:"tag-group"},[s("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("阿里飞猪")])],1),s("p",[t._v("倒排索引用于快速查找包含某个特定词语（或关键字）的文档集合。它的原理是将文档集合中的每个文档进行分词处理，然后对每个词语建立一个索引，索引中记录了包含该词语的文档列表。")])])}),[],!1,null,null,null);v.default=r.exports},449:function(t,v,_){t.exports=_.p+"assets/img/image-20230717153319313.drawio.7bf015b9.png"}}]);