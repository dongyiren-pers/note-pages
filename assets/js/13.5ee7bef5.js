(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{1071:function(_,v,o){"use strict";o.r(v);var r=o(14),t=Object(r.a)({},(function(){var _=this,v=_.$createElement,r=_._self._c||v;return r("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[r("h1",{attrs:{id:"第6章-缓存"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第6章-缓存"}},[_._v("#")]),_._v(" 第6章 缓存")]),_._v(" "),r("h2",{attrs:{id:"_6-1-什么是-buffer-pool"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-什么是-buffer-pool"}},[_._v("#")]),_._v(" 6.1 什么是 Buffer Pool")]),_._v(" "),r("p",[_._v("Buffer Pool 即 "),r("strong",[_._v("缓冲池")]),_._v("，简称 BP，BP 以 Page 页为单位，缓存最热的数据页（data page）与索引页（index page），Page 页默认大小 16K，BP 的底层采用链表数据结构管理 Page。")]),_._v(" "),r("p",[_._v("对数据页的读写操作都需要通过 buffer pool 进行：")]),_._v(" "),r("ul",[r("li",[_._v("innodb 读操作：先从 buffer pool 中查看数据的数据页是否存在，如果不存在，则将 page 从磁盘读取到 buffer pool 中。")]),_._v(" "),r("li",[_._v("innodb 写操作：先把数据和日志写入 buffer pool 和 log buffer，再由后台线程以一定频率将 buffer 中的内容刷到磁盘，"),r("strong",[_._v("这个刷盘机制叫做 Checkpoint")]),_._v("。")])]),_._v(" "),r("blockquote",[r("p",[_._v("写操作的事务持久性由 redo log 落盘保证，buffer pool 只是为了提高读写效率。")])]),_._v(" "),r("p",[_._v("Buffer Pool 缓存表数据与索引数据，把磁盘上的数据加载到缓冲池，避免每次访问都进行磁盘 IO。")]),_._v(" "),r("p",[_._v("Buffer Pool 是一块内存区域，是一种 "),r("strong",[_._v("降低磁盘访问的机制")]),_._v("。")]),_._v(" "),r("p",[_._v("Buffer Pool 默认大小 128M。")]),_._v(" "),r("div",{staticClass:"language-mysql extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[_._v("show variables like 'innodb_buffer%';\n")])])]),r("h2",{attrs:{id:"_6-2-buffer-pool-的控制块"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-buffer-pool-的控制块"}},[_._v("#")]),_._v(" 6.2 Buffer Pool 的控制块")]),_._v(" "),r("p",[_._v("Buffer Pool 中缓存的是数据页，数据页大小跟磁盘默认数据页大小一样（16K），为了更好管理的缓存页，Buffer Pool 有一个 "),r("strong",[_._v("描述数据的区域")]),_._v("  ：")]),_._v(" "),r("p",[_._v("InnoDB 为每一个缓存的数据页都创建了一个单独的区域，记录的数据页的元数据信息，包括数据页所属表空间、数据页编号、缓存页在 Buffer Pool 中的地址，链表节点信息、一些锁信息以及 LSN 信息等，这个区域被称之为 "),r("strong",[_._v("控制块")]),_._v("。")]),_._v(" "),r("p",[_._v("控制块和缓存页是一一对应的，它们都被存放到 Buffer Pool 中，其中控制块被存放到 Buffer Pool 的前面，缓存页被存放到 Buffer Pool 后面。")]),_._v(" "),r("p",[r("img",{attrs:{src:o(769),alt:"img"}})]),_._v(" "),r("blockquote",[r("p",[_._v("控制块大概占缓存页大小的 5%，16 * 1024 * 0.05 = 819 个字节左右。")])]),_._v(" "),r("p",[_._v("数据页大小为 16KB，控制块大概为 800 字节，当我们划分好所有的控制块与数据页后，可能会有剩余的空间不够一对控制块和缓存页的大小，这部分就是多余的碎片空间。如果把 Buffer Pool 的大小设置的刚刚好的话，可能不会产生碎片。")]),_._v(" "),r("h2",{attrs:{id:"_6-3-buffer-pool-的管理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-buffer-pool-的管理"}},[_._v("#")]),_._v(" 6.3 Buffer Pool 的管理")]),_._v(" "),r("p",[_._v("Buffer Pool 里有三个链表，LRU 链表、free 链表、flush 链表，InnoDB 正是通过这三个链表的使用来控制数据页的更新与淘汰的。")]),_._v(" "),r("h3",{attrs:{id:"buffer-pool-的初始化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#buffer-pool-的初始化"}},[_._v("#")]),_._v(" Buffer Pool 的初始化")]),_._v(" "),r("p",[_._v("当启动 Mysql 服务器的时候，需要完成对 Buffer Pool 的初始化过程，即分配 Buffer Pool 的内存空间，把它划分为若干对控制块和缓存页。")]),_._v(" "),r("ul",[r("li",[r("strong",[_._v("申请空间")]),_._v("：Mysql 服务器启动，就会根据设置的 Buffer Pool 大小（innodb_buffer_pool_size）超出一些，去操作系统 "),r("strong",[_._v("申请一块连续内存区域")]),_._v(" 作为 Buffer Pool 的内存区域。 这里之所以申请的内存空间会比 innodb_buffer_pool_size 大一些，主要是因为里面还要存放每个缓存页的控制块。")]),_._v(" "),r("li",[r("strong",[_._v("划分空间")]),_._v("：当内存区域申请完毕之后，数据库就会按照默认的缓存页的 16KB 的大小以及对应的 800 个字节左右的控制块的大小，在 Buffer Pool 中划分成若干个控制块和缓冲页对。")])]),_._v(" "),r("p",[_._v("划分空间后 Buffer Pool 的缓存页是都是空的，里面什么都没有，当要对数据执行增删改查的操作的时候，才会把数据对应的页从磁盘文件里读取出来，放入 Buffer Pool 中的缓存页中。")]),_._v(" "),r("h3",{attrs:{id:"free-链表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#free-链表"}},[_._v("#")]),_._v(" Free 链表")]),_._v(" "),r("p",[r("strong",[_._v("在 Buffer pool 刚被初始化出来的时候，里面的数据页以及控制块都是空的")]),_._v("，当执行读写的时候磁盘的数据页会加载到 Buffer pool 的数据页中，当 Buffer pool 中间有的页数据持久化到硬盘后，这些数据页又会被空闲出来。")]),_._v(" "),r("blockquote",[r("p",[_._v("以上的过程中会有一个问题，如何知道那些数据页是空的，那些是有数据的，只有找到空的数据页，才能把数据写进去。")])]),_._v(" "),r("p",[r("strong",[_._v("Free 链表即空闲链表，是一个双向链表，由一个基础节点和若干个子节点组成，记录空闲的数据页对应的控制块信息")]),_._v("。如下")]),_._v(" "),r("p",[r("img",{attrs:{src:o(770),alt:"img"}})]),_._v(" "),r("p",[r("strong",[_._v("基节点")]),_._v("：是一块单独申请的内存空间（约占 40 字节）。并不在 Buffer Pool 的连续内存空间里。包含链表中子节点中头节点地址，尾节点地址，以及当前链表中节点的数量等信息。")]),_._v(" "),r("p",[r("strong",[_._v("子节点")]),_._v("："),r("strong",[_._v("每个节点就是个空闲缓存页的控制块，即只要一个缓存页空闲，那它的控制块就会被放入 free 链表")]),_._v("。每个控制块里都有两个指针 free_pre（指向上一个节点）、free_next（指向下一个节点）。")]),_._v(" "),r("p",[_._v("Free 链表存在的意义就是描述 Buffer Pool 中的数据页，因此 Free 链表跟数据页的是一一对应的关系。")]),_._v(" "),r("p",[_._v("free 链表本身其实就是由 Buffer Pool 里的控制块组成的，前文中说到每个控制块里都有 free_pre/free_next 两个指针，分别指向自己的上一个 free 链表的节点，以及下一个 free 链表的节点。Buffer Pool 中的控制块通过两个指针，就可以把所有的控制块串成一个 free 链表。")]),_._v(" "),r("p",[r("img",{attrs:{src:o(771),alt:"img"}})]),_._v(" "),r("div",{staticClass:"subtitle"},[r("p",[_._v("磁盘页加载到 Buffer Pool 的流程")])]),r("p",[_._v("通过 free 链表只需要三步就可以将磁盘页加载到 BufferPool 的缓存中：")]),_._v(" "),r("p",[r("strong",[_._v("步骤一")]),_._v("：从 free 链表中取出一个空闲的控制块以及对应缓冲页。")]),_._v(" "),r("p",[r("img",{attrs:{src:o(772),alt:"img"}})]),_._v(" "),r("p",[r("strong",[_._v("步骤二")]),_._v("：把磁盘上的数据页读取到对应的缓存页，同时把相关的一些描述数据写入缓存页的控制块（例如：页所在的表空间、页号之类的信息）。")]),_._v(" "),r("p",[r("img",{attrs:{src:o(773),alt:"img"}})]),_._v(" "),r("p",[r("strong",[_._v("步骤三")]),_._v("：把该控制块对应的 free 链表节点从链表中移除，表示该缓冲页已经被使用了。")]),_._v(" "),r("p",[r("img",{attrs:{src:o(774),alt:"img"}})]),_._v(" "),r("div",{staticClass:"subtitle"},[r("p",[_._v("如何确定数据页是否被缓存")])]),r("p",[_._v("数据库提供了一个数据页缓存哈希表，以表空间号+数据页号作为 key、缓存页控制块的地址作为 value。")]),_._v(" "),r("p",[_._v("当使用数据页时，会先在数据页缓存哈希表中查找，如果找到了，则直接根据 value 定位控制块，然后根据控制块找到缓存页，如果没有找到，则读取磁盘数据页写入缓存，最后写入数据页缓存哈希表。")]),_._v(" "),r("p",[r("strong",[_._v("在这个过程中一条语句要执行，大致会经历以下几个过程")]),_._v("：")]),_._v(" "),r("ul",[r("li",[_._v("通过sql语句中的数据库名和表名可以知道要加载的数据页处于哪个表空间。")]),_._v(" "),r("li",[r("strong",[_._v("根据表空间号，表名称本身通过一致性算法得到索引根节点数据页号")]),_._v("。")]),_._v(" "),r("li",[_._v("进而根据根节点数据页号，找到下一层的数据页，可以从数据页缓存哈希表得到对应缓存页地址。")]),_._v(" "),r("li",[_._v("通过缓存页地址就可以在 Buffer Pool 池中定位到缓存页。")])]),_._v(" "),r("h3",{attrs:{id:"lru-链表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#lru-链表"}},[_._v("#")]),_._v(" LRU 链表")]),_._v(" "),r("p",[_._v("Buffer pool 作为一个 innodb 自带的一个缓存池，数据的读写都是 buffer pool 中进行的，操作的都是 Buffer pool 中的数据页，但是 Buffer Pool  的大小是有限的（默认 128MB），所以对于一些频繁访问的数据是希望能够一直留在 Buffer Pool 中，而一些访问比较少的数据，我们希望能将它够释放掉，空出数据页缓存其他数据。")]),_._v(" "),r("p",[r("strong",[_._v("基于此，InnoBD 采用了 LRU（Least recently used）算法，将频繁访问的数据放在链表头部，而不怎么访问的数据链表末尾，空间不够的时候就从尾部开始淘汰，从而腾出空间")]),_._v("。")]),_._v(" "),r("p",[r("strong",[_._v("LRU 链表本质上也是由控制块组成的")]),_._v("。")]),_._v(" "),r("div",{staticClass:"subtitle"},[r("p",[_._v("LRU 链表的写入过程")])]),r("p",[r("strong",[_._v("当数据库从磁盘加载一个数据页到 Buffer Pool 中的时候，会将一些变动信息也写到控制块中，并且将控制块从 Free 链表中脱离加入到 LRU 链表中")]),_._v("。过程如下：")]),_._v(" "),r("p",[r("img",{attrs:{src:o(775),alt:"img"}})]),_._v(" "),r("p",[_._v("梳理一下整个过程：")]),_._v(" "),r("ul",[r("li",[_._v("步骤一：根据表空间号、表名称本身通过一致性算法得到数据页号（这里省略了树状查找过程）。")]),_._v(" "),r("li",[_._v("步骤二：通过数据页缓存哈希表判断数据页是否被加载。")]),_._v(" "),r("li",[_._v("步骤三：从 Free 链表中获取一个控制块。")]),_._v(" "),r("li",[_._v("步骤四：读取磁盘数据。")]),_._v(" "),r("li",[_._v("步骤六：将数据写到空闲的缓存页中。")]),_._v(" "),r("li",[_._v("步骤七：将缓存页的信息写回控制块。")]),_._v(" "),r("li",[_._v("步骤八：将回控制块从 Free 链表中移除。")]),_._v(" "),r("li",[_._v("步骤九：将从 Free 中移除的控制块节点加入到 LRU 链表中。")])]),_._v(" "),r("div",{staticClass:"subtitle"},[r("p",[_._v("LRU 链表的淘汰机制")])]),r("p",[_._v("LRU 算法的设计思路就是：链表头部的节点是最近使用的，链表末尾的节点是最久没被使用的，当空间不够的时候就淘汰末尾最久没被使用的节点，从而腾出空间。")]),_._v(" "),r("p",[_._v("LRU 算法的目的就是为让最近被访问的缓存页能够尽量排到靠前的位置。")]),_._v(" "),r("ul",[r("li",[_._v("当访问的页在 Buffer Pool  里，就将该页对应的控制块移动到 LRU 链表的头部节点。")]),_._v(" "),r("li",[_._v("当访问的页不在 Buffer Pool 里，除了要把控制块放入到 LRU 链表的头部，还要淘汰  LRU 链表末尾的节点。")])]),_._v(" "),r("p",[_._v("以上就是 LUR 链表的实现过程，但是这种方式对于 MySQL 来说会有问题，所以 MySQL 并没有直接使用 LRU 链表的简单实现，而是对其做了一些改进，具体做了哪些改进，我们在下文中继续解释。")]),_._v(" "),r("h3",{attrs:{id:"flush链表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#flush链表"}},[_._v("#")]),_._v(" Flush链表")]),_._v(" "),r("p",[_._v("前面解释了我们对数据的读写都是先对 Buffer Pool 中的缓存页进行操作，然后在通过后台线程将脏页写入到磁盘，持久化到磁盘中，即 "),r("strong",[_._v("刷脏")]),_._v("。")]),_._v(" "),r("blockquote",[r("p",[_._v("脏页：当执行写入操作时，先更新的是缓存页，此时缓存页跟磁盘页的数据就会不一致，这就是常说的脏页。")])]),_._v(" "),r("p",[_._v("Flush 链表与 Free 链表的结构很类似，也由基节点与子节点组成。")]),_._v(" "),r("p",[_._v("Flush 链表是一个双向链表，链表结点是被修改过的缓存页对应的控制块（更新过的缓存页）。")]),_._v(" "),r("p",[_._v("Flush 链表作用：帮助定位脏页，需要刷盘的缓存页。")]),_._v(" "),r("p",[r("strong",[_._v("基节点")]),_._v("：和 free 链表一样，链接首尾结点，并存储了有多少个描述信息块。")]),_._v(" "),r("p",[r("strong",[_._v("子节点")]),_._v("："),r("strong",[_._v("每个节点是脏页对应的控制块，即只要一个缓存页被修改，那它的控制块就会被放入 Flush 链表")]),_._v("每个控制块块里都有两个指针 pre（指向上一个节点）、next（指向下一个节点）。")]),_._v(" "),r("div",{staticClass:"subtitle"},[r("p",[_._v("Flush 链表写入过程")])]),r("p",[_._v("当我们在写入数据的时候，我们知道磁盘 IO 的效率很慢，所以 MySQL 不会直接更新直接更新磁盘，而是经过以下两个步骤：")]),_._v(" "),r("ul",[r("li",[_._v("第一步：更新 Buffer Pool 中的数据页，一次内存操作；")]),_._v(" "),r("li",[_._v("第二步：将更新操作顺序写 Redo log，一次磁盘顺序写操作；")])]),_._v(" "),r("blockquote",[r("p",[_._v("这样的效率是最高的。顺序写 Redo log，每秒几万次，问题不大。")])]),_._v(" "),r("p",[r("img",{attrs:{src:o(776),alt:"img"}})]),_._v(" "),r("p",[_._v("当控制块被加入到Flush 链表后，后台线程就可以遍历 Flush 链表，将脏页写入到磁盘。")]),_._v(" "),r("h3",{attrs:{id:"buffer-pool-的数据页"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#buffer-pool-的数据页"}},[_._v("#")]),_._v(" Buffer Pool 的数据页")]),_._v(" "),r("p",[r("img",{attrs:{src:o(777),alt:"img"}})]),_._v(" "),r("ul",[r("li",[r("strong",[_._v("Free Page（空闲页）")]),_._v(" 表示此数据页 "),r("strong",[_._v("未被使用")]),_._v("，是空的，其控制块位于 Free 链表；")]),_._v(" "),r("li",[r("strong",[_._v("Clean Page（干净页）")]),_._v(" 表示此数据页 "),r("strong",[_._v("已被使用")]),_._v("，缓存了数据，其控制块位于 LRU 链表。")]),_._v(" "),r("li",[_._v("**Dirty Page（脏页）**表示此数据页 "),r("strong",[_._v("已被使用")]),_._v(" 且 "),r("strong",[_._v("已经被修改")]),_._v("，数据页中数据和磁盘上的数据已经不一致。 当脏页上的数据写入磁盘后，内存数据和磁盘数据一致，那么该页就变成了干净页。 "),r("strong",[_._v("脏页的控制块同时存在于 LRU 链表和 Flush 链表")]),_._v("。")])]),_._v(" "),r("h2",{attrs:{id:"_6-4-mysql-对-lru-算法的改进"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-mysql-对-lru-算法的改进"}},[_._v("#")]),_._v(" 6.4 MySQL 对 LRU 算法的改进")]),_._v(" "),r("p",[_._v("在前文中我们说到了简单的 LRU 算法会对于 MySQL 来说会有问题，因此 MySQL 对 LRU 算法进行了改进，接下来就来看看 LRU 算法存在什么问题，MySQL 又是怎么改进的。")]),_._v(" "),r("p",[_._v("先来说说 LRU 算法存在的问题：")]),_._v(" "),r("ul",[r("li",[r("strong",[_._v("预读失效")])]),_._v(" "),r("li",[r("strong",[_._v("Buffer Pool  污染")])])]),_._v(" "),r("h3",{attrs:{id:"什么是预读"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是预读"}},[_._v("#")]),_._v(" 什么是预读")]),_._v(" "),r("p",[_._v("前面说到，为了减少磁盘 IO，innoDB 会把数据从磁盘读取到内存中使用，一般而言，数据的读取会遵循 "),r("strong",[_._v("集中读写")]),_._v(" 的原则，也就是当我们使用一些数据的时候，很大概率也会使用附近的数据，即 "),r("strong",[_._v("局部性原理")]),_._v(" ，它表明提前加载是有效的，能够减少磁盘 IO。因此：")]),_._v(" "),r("p",[_._v("磁盘数据读取到内存，并不是按需读取，而是按页读取，一次至少读一页数据（16K），如果未来要读取的数据就在页中，直接读取内存即可，不需要磁盘 IO，提高效率 。这就是常说的 "),r("strong",[_._v("预读")]),_._v("。")]),_._v(" "),r("h3",{attrs:{id:"什么是预读失效"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是预读失效"}},[_._v("#")]),_._v(" 什么是预读失效")]),_._v(" "),r("p",[_._v("解释了什么是预读，那预读失效就很好理解了， "),r("strong",[_._v("被提前加载进来的数据页并一直没有被访问，即预读失效")]),_._v(" 。")]),_._v(" "),r("p",[_._v("通过简单的 LRU 链表的实现过程我们知道，预读的数据会被放到 LRU 链表头部，而当  Buffer Pool 空间不够的时候，需要把末尾的页淘汰掉。如果这些预读的数据一直没有被使用，而把被使用的数据挤到了链表的尾部，进而被淘汰，那缓存的命中率就会大大降低。这样的话，预读就适得其反了。")]),_._v(" "),r("h3",{attrs:{id:"如何提高缓存的命中率"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何提高缓存的命中率"}},[_._v("#")]),_._v(" 如何提高缓存的命中率")]),_._v(" "),r("p",[_._v("预读的数据被使用到的时候，会减少磁盘 IO，但是预读失效的时候，也会降低缓存的命中率，不能因为预读失效，而将预读机制去掉，所以我们要在保留预读这个机制的前提下提高缓存的命中率。")]),_._v(" "),r("p",[_._v("前面将在 LRU 链表的时候就解释了我们在读到数据之后，把对应的数据页放到 LRU 链表头部，因此想要提高缓存的命中率，只需要 "),r("strong",[_._v("让真正被访问的页才移动到 LRU 链表的头部，使其在 Buffer Pool 里停留的时间尽可能长，尽可能缩短预读的页停留在 Buffer Pool 里的时间")]),_._v(" 。")]),_._v(" "),r("p",[_._v("MySQL 基于这种设计思路对 LRU 算法进行了改进，将 LRU 划分了 2 个区域：")]),_._v(" "),r("p",[r("strong",[_._v("划分 old 和 young 两个区域后，预读的页会被加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部")]),_._v(" 。")]),_._v(" "),r("blockquote",[r("p",[_._v("如果预读的页一直没有被访问，会一直存在 old 区域，直到被移除，不会影响 young 区域中的热点数据。")])]),_._v(" "),r("p",[r("strong",[_._v("old 区域")]),_._v(" ：在 LRU 链表的后半部分")]),_._v(" "),r("p",[r("strong",[_._v("young 区域")]),_._v(" ：在 LRU 链表的前半部分")]),_._v(" "),r("p",[r("img",{attrs:{src:o(778),alt:"img"}})]),_._v(" "),r("p",[_._v("old 区域占整个 LRU 链表长度的比例可以通过 "),r("code",[_._v("innodb_old_blocks_pc")]),_._v(" 参数来设置，默认是 37，代表整个 LRU 链表中 young 区域与 old 区域比例是 63：37 。")]),_._v(" "),r("div",{staticClass:"language-javascript extra-class"},[r("pre",{pre:!0,attrs:{class:"language-javascript"}},[r("code",[_._v("show variables like "),r("span",{pre:!0,attrs:{class:"token string"}},[_._v("'%innodb_old_blocks_pc%'")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n")])])]),r("h3",{attrs:{id:"什么是-buffer-pool-污染"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是-buffer-pool-污染"}},[_._v("#")]),_._v(" 什么是 Buffer Pool  污染")]),_._v(" "),r("p",[_._v("预读失效的问题解决了，接下来看看什么是 Buffer Pool  污染。")]),_._v(" "),r("p",[_._v("当 SQL 执行的时候， "),r("strong",[_._v("数据会加载到 Buffer Pool ，而 Buffer Pool 的大小是有限的，如果加载大量数据（例如对大表进行全表扫描），就会将 Buffer Pool 里的所有页都替换出去，导致原本的热数据被淘汰")]),_._v(" 。下次访问的时候，又要重新去磁盘读取，导致数据库性能下降，这个过程就是 "),r("strong",[_._v("Buffer Pool  污染")]),_._v(" 。")]),_._v(" "),r("h3",{attrs:{id:"如何解决-buffer-pool-污染"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#如何解决-buffer-pool-污染"}},[_._v("#")]),_._v(" 如何解决 Buffer Pool 污染")]),_._v(" "),r("blockquote",[r("p",[_._v("Buffer Pool 污染跟预读失效都是一样的会导致 LRU 的热点数据被替换和淘汰。")])]),_._v(" "),r("p",[_._v("针对以上全表扫描的情况进行分析，全表扫描之所以会替换淘汰原有的 LRU 链表 young 区域数据，主要是因为我们将原本只会访问一次的数据页加载到 young 区。这些数据实际上刚刚从磁盘被加载到 Buffer Pool，然后就被访问，之后就不会用，基于此，我们是不是可以将数据放 young 区的门槛提高点，从而把这种访问一次就不会用的数据过滤掉，把它挡在 old 区，这样就不会污染 young 区的热点数据了。")]),_._v(" "),r("p",[_._v("解决 Buffer Pool 污染方案：MySQL 解决方式就是提高了数据从 Old 区域进入到 young 区域门槛： "),r("strong",[_._v("先设定一个间隔时间 innodb_old_blocks_time，然后将 Old 区域数据页的第一次访问时间在其对应的控制块中记录下来")]),_._v(" 。 这样看，其实 "),r("strong",[_._v("这个间隔时间 innodb_old_blocks_time 就是数据页必须在 old 区域停留的时间")]),_._v(" 。")]),_._v(" "),r("ul",[r("li",[_._v("如果后续的访问时间与第一次访问的时间 "),r("strong",[_._v("小于 innodb_old_blocks_time")]),_._v(" ，则 "),r("strong",[_._v("不将该缓存页从 old 区域移动到 young 区域")]),_._v(" 。")]),_._v(" "),r("li",[_._v("如果后续的访问时间与第一次访问的时间 "),r("strong",[_._v("大于 innodb_old_blocks_time")]),_._v(" ，才 "),r("strong",[_._v("会将该缓存页移动到 young 区域的头部")]),_._v(" 。")])]),_._v(" "),r("div",{staticClass:"language-javascript extra-class"},[r("pre",{pre:!0,attrs:{class:"language-javascript"}},[r("code",[_._v("show variables like "),r("span",{pre:!0,attrs:{class:"token string"}},[_._v("'%innodb_old_blocks_time%'")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[_._v(";")]),_._v("\n")])])]),r("p",[_._v("innodb_old_blocks_time 默认是 1s。")]),_._v(" "),r("p",[_._v("即：当同时满足 "),r("strong",[_._v("数据页被访问")]),_._v(" 与 "),r("strong",[_._v("数据页在 old 区域停留时间超过 1 秒")]),_._v(" 两个条件，才会被插入到 young 区域头部。")]),_._v(" "),r("p",[_._v("通过这种方式，就过滤了上述那种全表扫描导致的将只会访问一次的数据页加载到 young 区造成的 Buffer Pool  污染的问题 。")]),_._v(" "),r("h3",{attrs:{id:"young-区域优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#young-区域优化"}},[_._v("#")]),_._v(" young 区域优化")]),_._v(" "),r("p",[_._v("MySQL 为了防止 young 区域节点频繁移动到头部，对 young 区域也做了一个优化：young 区域前面 1/4 被访问不会移动到链表头部，只有后面的 3/4 被访问了才会。")]),_._v(" "),r("h2",{attrs:{id:"_6-5-脏页的刷盘时机"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-脏页的刷盘时机"}},[_._v("#")]),_._v(" 6.5 脏页的刷盘时机")]),_._v(" "),r("p",[_._v("通过对上述三种链表的描述，我们知道 "),r("strong",[_._v("当我们对数据进行修改时，其实修改的是 Buffer Pool 中数据所在缓存页，修改后将其设置为脏页，并将脏页的控制块同时存在于 LRU 链表和 Flush 链表")]),_._v("。然后通过刷脏将修改同步至磁盘。")]),_._v(" "),r("p",[_._v("刷脏不是每次修改都进行的，那样性能会很差，因此刷脏是通过一定的时机触发进行批量刷盘的。")]),_._v(" "),r("p",[_._v("脏页的刷盘时机总的来说就分为以下种：")]),_._v(" "),r("ul",[r("li",[_._v("Redo log 日志满了的情况下，会主动触发脏页刷新到磁盘。")]),_._v(" "),r("li",[_._v("MySQL 正常关闭之前，会把所有的脏页刷入到磁盘。")]),_._v(" "),r("li",[_._v("Buffer Pool 空间不足时，会淘汰一部分数据页，如果淘汰的是脏页，需要先将其同步到磁盘。")]),_._v(" "),r("li",[_._v("MySQL 空闲时，后台线程会定期脏页刷盘。")])]),_._v(" "),r("h3",{attrs:{id:"buffer-pool-内存不足触发刷脏"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#buffer-pool-内存不足触发刷脏"}},[_._v("#")]),_._v(" Buffer Pool 内存不足触发刷脏")]),_._v(" "),r("p",[_._v("刷脏的目的是将修改的数据同步磁盘，释放 Buffer Pool 内存空间 。因此需要将访问的最少的数据页刷回磁盘，释放其数据页内存。 "),r("strong",[_._v("基于这样的原则，我们只需要根据 LRU 链表，将其 Old 区域尾部节点输盘即可")]),_._v(" 。")]),_._v(" "),r("p",[_._v("对于修改的数据页的控制块同时存在于 LRU 链表和 Flush 链表，对于只有读取访问的数据页的控制块存在于 LRU 链表 。")]),_._v(" "),r("p",[r("img",{attrs:{src:o(779),alt:"img"}})]),_._v(" "),r("p",[_._v("如上图，Buffer Pool 内存不足脏页刷盘分为两种情况：")]),_._v(" "),r("ul",[r("li",[_._v("若缓存页同时在 flush 链表和 LRU 链表中，表示数据被修改过，则需要刷脏，释放掉缓存页的内存，将控制块重新添加到 free 链表中。")]),_._v(" "),r("li",[_._v("若缓存页只是存在于 LRU 链表中，表示数据没有被修改过，则不需要刷脏，直接释放掉缓存页的内存，将控制块重新添加到 free 链表中。")])]),_._v(" "),r("h3",{attrs:{id:"后台线程定期脏页刷盘"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#后台线程定期脏页刷盘"}},[_._v("#")]),_._v(" 后台线程定期脏页刷盘")]),_._v(" "),r("p",[_._v("为了避免缓冲池内存不够，MySQL 在后台有一个定时任务，通过单独的后台线程，不断从 LRU 链表 Old 区尾部的缓存页刷回至磁盘中并同时释放缓存页。")]),_._v(" "),r("p",[r("img",{attrs:{src:o(780),alt:"img"}})])])}),[],!1,null,null,null);v.default=t.exports},769:function(_,v,o){_.exports=o.p+"assets/img/1200-16883149854453.673e34b6.png"},770:function(_,v,o){_.exports=o.p+"assets/img/1200-16883622787381.69cdeadf.png"},771:function(_,v,o){_.exports=o.p+"assets/img/1200-16883622787382.b645f14f.png"},772:function(_,v,o){_.exports=o.p+"assets/img/1200-16883622787383.dbe354b3.png"},773:function(_,v,o){_.exports=o.p+"assets/img/1200-16883622787394.0a395f55.png"},774:function(_,v,o){_.exports=o.p+"assets/img/1200-16883622787395.2951fdb2.png"},775:function(_,v,o){_.exports=o.p+"assets/img/1200-16883622787396.5d468bd4.png"},776:function(_,v,o){_.exports=o.p+"assets/img/1200-16883622787398.67c8c270.png"},777:function(_,v,o){_.exports=o.p+"assets/img/1200-16883622787399.51236044.png"},778:function(_,v,o){_.exports=o.p+"assets/img/1200-168836227873910.9b950ab4.png"},779:function(_,v,o){_.exports=o.p+"assets/img/1200-168836227874014.5ec913a8.png"},780:function(_,v,o){_.exports=o.p+"assets/img/1200-168836227874015.c2bbf6e4.png"}}]);