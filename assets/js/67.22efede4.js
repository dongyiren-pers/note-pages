(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{1027:function(t,v,_){"use strict";_.r(v);var s=_(14),r=Object(s.a)({},(function(){var t=this,v=t.$createElement,s=t._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"基础"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[t._v("#")]),t._v(" 基础")]),t._v(" "),s("p"),s("div",{staticClass:"table-of-contents"},[s("ul",[s("li",[s("a",{attrs:{href:"#计算机网络"}},[t._v("计算机网络")]),s("ul",[s("li",[s("a",{attrs:{href:"#网络分层结构"}},[t._v("网络分层结构")])]),s("li",[s("a",{attrs:{href:"#在浏览器输入-url-回车之后发生了什么"}},[t._v("在浏览器输入 URL 回车之后发生了什么")])]),s("li",[s("a",{attrs:{href:"#arp-协议的工作过程"}},[t._v("ARP 协议的工作过程")])]),s("li",[s("a",{attrs:{href:"#tcp-和-udp-的区别"}},[t._v("TCP 和 UDP 的区别")])]),s("li",[s("a",{attrs:{href:"#tcp-三次握手"}},[t._v("TCP 三次握手")])]),s("li",[s("a",{attrs:{href:"#两次握手为什么不行"}},[t._v("两次握手为什么不行")])]),s("li",[s("a",{attrs:{href:"#tcp-四次挥手"}},[t._v("TCP 四次挥手")])]),s("li",[s("a",{attrs:{href:"#第四次挥手为什么要等待-2msl"}},[t._v("第四次挥手为什么要等待 2MSL")])]),s("li",[s("a",{attrs:{href:"#tcp-如何实现可靠传输"}},[t._v("TCP 如何实现可靠传输")])]),s("li",[s("a",{attrs:{href:"#tcp-流量控制"}},[t._v("TCP 流量控制")])]),s("li",[s("a",{attrs:{href:"#tcp-拥塞控制"}},[t._v("TCP 拥塞控制")])]),s("li",[s("a",{attrs:{href:"#http-报文格式"}},[t._v("HTTP 报文格式")])]),s("li",[s("a",{attrs:{href:"#get-和-post-的区别"}},[t._v("GET 和 POST 的区别")])]),s("li",[s("a",{attrs:{href:"#http-状态码"}},[t._v("HTTP 状态码")])]),s("li",[s("a",{attrs:{href:"#http-短连接和长连接"}},[t._v("HTTP 短连接和长连接")])]),s("li",[s("a",{attrs:{href:"#http-协议版本"}},[t._v("HTTP 协议版本")])]),s("li",[s("a",{attrs:{href:"#https-与-http-的区别"}},[t._v("HTTPS 与 HTTP 的区别")])]),s("li",[s("a",{attrs:{href:"#什么是数字证书"}},[t._v("什么是数字证书")])]),s("li",[s("a",{attrs:{href:"#tls-握手协议"}},[t._v("TLS 握手协议")])]),s("li",[s("a",{attrs:{href:"#dns-域名解析过程"}},[t._v("DNS 域名解析过程")])])])]),s("li",[s("a",{attrs:{href:"#操作系统"}},[t._v("操作系统")]),s("ul",[s("li",[s("a",{attrs:{href:"#进程间的通信方式"}},[t._v("进程间的通信方式")])]),s("li",[s("a",{attrs:{href:"#进程、线程与协程的区别"}},[t._v("进程、线程与协程的区别")])]),s("li",[s("a",{attrs:{href:"#进程的调度策略"}},[t._v("进程的调度策略")])]),s("li",[s("a",{attrs:{href:"#select、poll-和-epoll-的区别"}},[t._v("select、poll 和 epoll 的区别")])])])])])]),s("p"),t._v(" "),s("h2",{attrs:{id:"计算机网络"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#计算机网络"}},[t._v("#")]),t._v(" 计算机网络")]),t._v(" "),s("h3",{attrs:{id:"网络分层结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#网络分层结构"}},[t._v("#")]),t._v(" 网络分层结构")]),t._v(" "),s("p",[s("strong",[t._v("五层模型")]),t._v(" 自下而上为物理层、数据链路层、网络层、传输层、应用层。")]),t._v(" "),s("ul",[s("li",[t._v("物理层：传输单位是 "),s("strong",[t._v("比特")]),t._v("，任务是 "),s("strong",[t._v("透明地传输比特流")]),t._v("。")]),t._v(" "),s("li",[t._v("数据链路层：数据链路层的传输单位是 "),s("strong",[t._v("帧")]),t._v("，任务是将网络层传来的 IP 数据报 "),s("strong",[t._v("组装成帧")]),t._v("。")]),t._v(" "),s("li",[t._v("网络层：网络层的传输单位是 "),s("strong",[t._v("数据报")]),t._v("，任务是把网络层的 "),s("strong",[t._v("协议数据单元（分组）")]),t._v(" 从源端传到目的端。")]),t._v(" "),s("li",[t._v("传输层：负责主机中 "),s("strong",[t._v("两个进程")]),t._v(" 的通信。传输单位是报文段（TCP）或用户数据报（UDP）。")]),t._v(" "),s("li",[t._v("应用层：为特定类型的网络应用提供交互服务。")])]),t._v(" "),s("p",[s("RouterLink",{attrs:{to:"/network/a918ca/#osi-参考模型"}},[s("strong",[t._v("OSI 参考模型")])]),t._v(" 有 7 层，自下而上为物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。")],1),t._v(" "),s("p",[s("RouterLink",{attrs:{to:"/network/a918ca/#tcp-ip-参考模型"}},[s("strong",[t._v("TCP/IP 参考模型")])]),t._v(" 有 4 层，自下而上为网络接口层、网络层、传输层、应用层。")],1),t._v(" "),s("h3",{attrs:{id:"在浏览器输入-url-回车之后发生了什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在浏览器输入-url-回车之后发生了什么"}},[t._v("#")]),t._v(" 在浏览器输入 URL 回车之后发生了什么")]),t._v(" "),s("div",{staticClass:"tag-group"},[s("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("哔哩哔哩")])],1),s("p",[s("strong",[t._v("URL 解析")])]),t._v(" "),s("ul",[s("li",[t._v("地址解析：首先判断输入的是一个合法的 URL 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。")]),t._v(" "),s("li",[s("strong",[s("RouterLink",{attrs:{to:"/http/3djudn/#hsts"}},[t._v("HSTS")])],1),t._v("：由于安全隐患，会使用 HSTS 强制客户端使用 HTTPS 访问页面。")]),t._v(" "),s("li",[t._v("其他操作：浏览器还会进行一些额外的操作，比如安全检查、访问限制。")]),t._v(" "),s("li",[t._v("检查缓存：浏览器检查缓存，判断本地是否已经缓存了请求的资源。如果缓存中已经有该资源并且缓存未过期，浏览器将从缓存中获取资源，否则就需要向服务器发送请求以获取最新的资源。")])]),t._v(" "),s("p",[s("strong",[t._v("DNS 查询")])]),t._v(" "),s("ul",[s("li",[t._v("检查缓存：浏览器缓存 → 操作系统缓存 → 路由器缓存 → ISP DNS 缓存（首选 DNS 服务器）。")]),t._v(" "),s("li",[t._v("域名解析：本地 DNS 服务器将请求转发到互联网上的根域（详见 "),s("RouterLink",{attrs:{to:"/network/jn809u/#域名解析过程"}},[s("strong",[t._v("域名解析过程")])]),t._v("）。")],1)]),t._v(" "),s("p",[s("strong",[t._v("建立 TCP 连接")])]),t._v(" "),s("ul",[s("li",[t._v("TCP 三次握手建立连接。详见 "),s("RouterLink",{attrs:{to:"/network/o252om/#tcp-连接的建立"}},[s("strong",[t._v("TCP 连接的建立")])]),t._v("。")],1)]),t._v(" "),s("p",[s("strong",[t._v("发送 HTTP 请求")])]),t._v(" "),s("ul",[s("li",[t._v("发送 HTTP 请求报文。")])]),t._v(" "),s("p",[s("strong",[t._v("服务器处理请求")])]),t._v(" "),s("ul",[s("li",[t._v("以 Spring MVC 为例，详见 "),s("RouterLink",{attrs:{to:"/interview/Spring.html#springmvc-请求处理流程"}},[s("strong",[t._v("SpringMVC 请求处理流程")])]),t._v("。")],1)]),t._v(" "),s("p",[s("strong",[t._v("浏览器接受 HTTP 响应")])]),t._v(" "),s("ul",[s("li",[t._v("浏览器接收到来自服务器的响应资源后，会对资源进行分析。")]),t._v(" "),s("li",[t._v("首先查看响应头，根据不同状态码做不同的事（比如重定向）。")]),t._v(" "),s("li",[t._v("如果响应资源进行了压缩（比如 gzip），还需要进行解压。")]),t._v(" "),s("li",[t._v("然后，对响应资源做缓存。")]),t._v(" "),s("li",[t._v("接下来，根据响应资源里的 MIME 类型去解析响应内容。")])]),t._v(" "),s("p",[s("strong",[t._v("释放 TCP 连接")])]),t._v(" "),s("ul",[s("li",[t._v("TCP 四次挥手释放连接。详见 "),s("RouterLink",{attrs:{to:"/network/o252om/#tcp-连接的释放"}},[s("strong",[t._v("TCP 连接的释放")])]),t._v("。")],1)]),t._v(" "),s("p",[s("strong",[t._v("渲染页面")])]),t._v(" "),s("ul",[s("li",[t._v("后端不做考察。")])]),t._v(" "),s("h3",{attrs:{id:"arp-协议的工作过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#arp-协议的工作过程"}},[t._v("#")]),t._v(" ARP 协议的工作过程")]),t._v(" "),s("p",[t._v("无论网络层使用什么协议， 在实际网络的链路上传送数据帧时， 最终必须使用硬件地址。 因此需要一种方法来完成 IP 地址到 MAC 地址的映射， 即 "),s("strong",[t._v("地址解析协议（Address Resolution Protocol, ARP）")]),t._v("。")]),t._v(" "),s("p",[t._v("ARP 工作在网络层， 其工作原理如下： 主机 A 欲向本局域网上的某台主机 B 发送 IP 数据报时，先在其 "),s("strong",[t._v("ARP 高速缓存")]),t._v(" 中查看有无主机 B 的 IP 地址。")]),t._v(" "),s("ul",[s("li",[t._v("如果有， 就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧， 然后通过局域网将该 MAC 帧发往此硬件地址。")]),t._v(" "),s("li",[t._v("如果没有，就通过使用目的 MAC 地址为 FF-FF-FF-FF-FF-FF 的帧来封装并广播 ARP 请求分组（广播发送），使同一个局域网里的所有主机都收到此 ARP 请求。 主机 B 收到该 ARP 请求后， 向主机 A 发出 ARP 响应分组（单播发送）， 分组中包含主机 B 的 IP 与 MAC 地址的映射关系， 主机 A 收到 ARP 响应分组后就将此映射写入 ARP 缓存， 然后按查询到的硬件地址发送 MAC 帧。")])]),t._v(" "),s("h3",{attrs:{id:"tcp-和-udp-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-和-udp-的区别"}},[t._v("#")]),t._v(" TCP 和 UDP 的区别")]),t._v(" "),s("div",{staticClass:"tag-group"},[s("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("美团到店")])],1),s("p",[t._v("UDP 和 TCP 都是互联网协议栈中传输层协议，其在数据传输方面有以下区别：")]),t._v(" "),s("p",[s("strong",[t._v("连接方式：")])]),t._v(" "),s("ul",[s("li",[t._v("TCP 是一种 "),s("strong",[t._v("面向连接")]),t._v(" 的协议，传输前需要建立连接，传输结束后需要释放连接；")]),t._v(" "),s("li",[t._v("UDP 是一种 "),s("strong",[t._v("无连接")]),t._v(" 的协议，传输数据前不需要建立连接。")])]),t._v(" "),s("p",[s("strong",[t._v("可靠传输：")])]),t._v(" "),s("ul",[s("li",[t._v("TCP 提供 "),s("strong",[t._v("可靠交付的服务")]),t._v("，保证传送的数据无差错、不丢失、不重复且有序。")]),t._v(" "),s("li",[t._v("UDP 使用最大努力交付，即 "),s("strong",[t._v("不保证可靠交付")]),t._v("。")])]),t._v(" "),s("p",[s("strong",[t._v("传输速度：")])]),t._v(" "),s("ul",[s("li",[t._v("TCP 由于需要进行连接建立、确认等操作，传输速度相对较慢。")]),t._v(" "),s("li",[t._v("UDP 是无连接的，传输速度较快，但数据可能会丢失或者顺序错乱。")])]),t._v(" "),s("p",[s("strong",[t._v("传输单位：")])]),t._v(" "),s("ul",[s("li",[t._v("TCP 是 "),s("strong",[t._v("面向字节流")]),t._v(" 的，没有数据报大小限制，数据按照字节序列发送。")]),t._v(" "),s("li",[t._v("UDP 是 "),s("strong",[t._v("面向报文")]),t._v(" 的，每个 UDP 数据报都有固定的大小限制。最大传输单元为 65535 字节。")])]),t._v(" "),s("p",[s("strong",[t._v("适用场景：")])]),t._v(" "),s("ul",[s("li",[t._v("TCP 适用于要求数据可靠传输、传输数据量较大的场景，如文件传输、电子邮件等。")]),t._v(" "),s("li",[t._v("UDP 适用于实时性要求高、数据量较小的场景，如音视频传输、游戏等。")])]),t._v(" "),s("p",[t._v("综上，TCP 适合要求数据可靠传输的场景，UDP 适合要求实时性较高的场景。")]),t._v(" "),s("h3",{attrs:{id:"tcp-三次握手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-三次握手"}},[t._v("#")]),t._v(" TCP 三次握手")]),t._v(" "),s("div",{staticClass:"tag-group"},[s("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("美团")])],1),s("ul",[s("li",[s("strong",[t._v("第一步")]),t._v("：客户机的 TCP 首先向服务器的 TCP 发送连接请求报文段。这个特殊报文段的首部中的 "),s("strong",[t._v("同步位 SYN 置 1")]),t._v("，同时选择一个 "),s("strong",[t._v("初始序号 seq = x")]),t._v("。 TCP 规定， SYN 报文段不能携带数据，但要消耗掉一个序号。这时，TCP 客户进程进入 "),s("strong",[s("u",[t._v("SYN-SENT（同步已发送）")])]),t._v(" 状态。")]),t._v(" "),s("li",[s("strong",[t._v("第二步")]),t._v("：服务器的 TCP 收到连接请求报文段后，如同意建立连接，则向客户机发回确认，并为该 TCP 连接分配缓存和变量。在确认报文段中，"),s("strong",[t._v("把 SYN 位和 ACK 位都置 1，确认号是 ack = x + 1")]),t._v("。同时为自己选择一个 "),s("strong",[t._v("初始序号 seq = y")]),t._v("。注意，确认报文段不能携带数据，但也要消耗掉一个序号。这时， TCP 服务器进程进入 "),s("strong",[s("u",[t._v("SYN-RCVD（同步收到）")])]),t._v(" 状态。")]),t._v(" "),s("li",[s("strong",[t._v("第三步")]),t._v("：当客户机收到确认报文段后，还要向服务器给出确认，并为该 TCP 连接分配缓存和变量。确认报文段的 "),s("strong",[t._v("ACK 位置 1，确认号 ack = y + 1，序号 seq =x + 1")]),t._v("。该报文段可以携带数据，若不携带数据则不消耗序号。这时，TCP 客户进程进入 "),s("strong",[s("u",[t._v("ESTABLISHED（已建立连接）")])]),t._v(" 状态。")])]),t._v(" "),s("h3",{attrs:{id:"两次握手为什么不行"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#两次握手为什么不行"}},[t._v("#")]),t._v(" 两次握手为什么不行")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("三次握手才可以阻止重复历史连接的初始化（首要原因）")]),t._v("：在两次握手的情况下，被动发起方没有中间状态给主动发起方来阻止历史连接，导致被动发起方可能建立一个历史连接，造成资源浪费。")]),t._v(" "),s("li",[s("strong",[t._v("三次握手才可以同步双方的初始序列号")]),t._v("：在两次握手的情况下，只保证了发起方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。")]),t._v(" "),s("li",[s("strong",[t._v("三次握手才可以避免资源浪费")]),t._v("：在两次握手的情况下，如果客户端的 SYN 阻塞了，重复发送多次 SYN 报文，服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。")])]),t._v(" "),s("h3",{attrs:{id:"tcp-四次挥手"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-四次挥手"}},[t._v("#")]),t._v(" TCP 四次挥手")]),t._v(" "),s("div",{staticClass:"tag-group"},[s("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("美团")])],1),s("ul",[s("li",[s("strong",[t._v("第一步")]),t._v("：客户机发送一个 "),s("strong",[t._v("FIN")]),t._v("（结束）报文段给服务器。这个报文段表明客户机已经发送完数据，请求关闭连接，并指定一个 "),s("strong",[t._v("序号 seq = u")]),t._v("。此时，客户机进入 "),s("strong",[s("u",[t._v("FIN-WAIT-1（等待对方 ACK）")])]),t._v(" 状态。")]),t._v(" "),s("li",[s("strong",[t._v("第二步")]),t._v("：服务器收到 FIN 报文段后，发送一个确认 "),s("strong",[t._v("ACK")]),t._v(" 报文段作为回应，"),s("strong",[t._v("确认号 ack = u + 1")]),t._v("，同时指定一个 "),s("strong",[t._v("序号 seq = v")]),t._v("。这个报文段表明服务器已经收到关闭请求，并进入 "),s("strong",[s("u",[t._v("CLOSE-WAIT（等待自己关闭）")])]),t._v(" 状态。")]),t._v(" "),s("li",[s("strong",[t._v("第三步")]),t._v("：服务器发送一个 "),s("strong",[t._v("FIN-ACK")]),t._v(" 报文段给客户机，请求关闭连接，同时指定一个 "),s("strong",[t._v("序号 seq = w")]),t._v("。此时，服务器进入 "),s("strong",[s("u",[t._v("LAST-ACK（等待最后 ACK）")])]),t._v(" 状态。")]),t._v(" "),s("li",[s("strong",[t._v("第四步")]),t._v("：客户机收到 FIN 报文段后，发送一个确认 "),s("strong",[t._v("ACK")]),t._v(" 报文段作为回应，"),s("strong",[t._v("确认号 ack = w + 1")]),t._v("。此时，客户机进入 "),s("strong",[s("u",[t._v("TIME-WAIT（等待一段时间）")])]),t._v(" 状态。在这个状态下，客户机等待 "),s("strong",[t._v("2MSL")]),t._v("，确保服务器收到了确认，防止可能的重传。完成等待后，客户机离开 TIME-WAIT 状态，完成四次挥手过程。")])]),t._v(" "),s("h3",{attrs:{id:"第四次挥手为什么要等待-2msl"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第四次挥手为什么要等待-2msl"}},[t._v("#")]),t._v(" 第四次挥手为什么要等待 2MSL")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("确保服务器收到了确认，防止可能的重传")]),t._v("：如果 ACK 丢失，服务器会超时重传 FIN-ACK，然后客户机再次确认，最终双方正常关闭。如果客户端不等待 2MSL，ACK 丢失后服务器无法正常关闭连接。")]),t._v(" "),s("li",[s("strong",[t._v("确保通信双方的滞留报文都失效")]),t._v("：最坏情况下，ACK 经历了 1 MSL 才到达服务器，在 ACK 到达前一瞬间，服务端重传了 FIN 并发生了滞留，需要等待 1 MSL 才可让其失效。")])]),t._v(" "),s("h3",{attrs:{id:"tcp-如何实现可靠传输"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-如何实现可靠传输"}},[t._v("#")]),t._v(" TCP 如何实现可靠传输")]),t._v(" "),s("div",{staticClass:"tag-group"},[s("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("美团到店")]),s("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("阿里云计算平台")])],1),s("p",[t._v("TCP 使用了 "),s("strong",[t._v("校验、序号、确认和重传")]),t._v(" 等机制实现可靠传输。")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("校验")]),t._v("：TCP 校验机制与 "),s("RouterLink",{attrs:{to:"/network/o252om/#udp-校验"}},[t._v("UDP 校验")]),t._v(" 一样。发送方按二进制反码计算出 TCP 报文每 16 位字的和，将此和的二进制反码写入校验和字段，并发送给接收方。接收方同样按二进制反码求 TCP 报文每 16 位字的和。当无差错时其结果应为全 1，否则就表明有差错出现。")],1),t._v(" "),s("li",[s("strong",[t._v("序号")]),t._v("：TCP 首部的序号字段用来保证数据能有序提交给应用层，TCP 把数据视为一个无结构但有序的字节流，序号建立在传送的字节流之上，而不建立在报文段之上。")]),t._v(" "),s("li",[s("strong",[t._v("确认")]),t._v("：TCP 首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号。发送方缓存区会继续存储那些已发送但未收到确认的报文段，以便在需要时重传。")]),t._v(" "),s("li",[s("strong",[t._v("重传")]),t._v("：有两种事件会导致 TCP 对报文段进行重传： "),s("RouterLink",{attrs:{to:"/network/o252om/#重传"}},[t._v("超时")]),t._v(" 和 "),s("RouterLink",{attrs:{to:"/network/o252om/#重传"}},[t._v("冗余 ACK")]),t._v("。")],1)]),t._v(" "),s("h3",{attrs:{id:"tcp-流量控制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-流量控制"}},[t._v("#")]),t._v(" TCP 流量控制")]),t._v(" "),s("p",[t._v("TCP 提供一种基于 "),s("strong",[t._v("滑动窗口协议")]),t._v(" 的流量控制机制。")]),t._v(" "),s("p",[t._v("在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，这称为 "),s("strong",[t._v("接收窗口 rwnd")]),t._v("。即调整 TCP 报文段首部中的 “窗口” 字段值，来限制发送方向网络注入报文的速率。")]),t._v(" "),s("h3",{attrs:{id:"tcp-拥塞控制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp-拥塞控制"}},[t._v("#")]),t._v(" TCP 拥塞控制")]),t._v(" "),s("p",[t._v("因特网建议标准定义了进行拥塞控制的 4 种算法：慢开始、拥塞避免、快重传和快恢复。")]),t._v(" "),s("p",[s("img",{attrs:{src:_(454),alt:"image-20221120234254876"}})]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("慢开始")]),t._v("：开始发送 TCP 报文段时，令拥塞窗口 cwnd = 1，即一个最大报文段长度 MSS。每收到一个对新报文段的确认后，将 cwnd 加倍（指数级增长）。")]),t._v(" "),s("li",[s("strong",[t._v("拥塞避免")]),t._v("：每经过一个往返时延 RTT 就把发送方的拥塞窗口 cwnd 加 1（线性增长），使拥塞窗口 cwnd 按线性规律缓慢增长。")]),t._v(" "),s("li",[s("strong",[t._v("快重传")]),t._v("：当发送方连续收到三个重复的 ACK 报文时，直接重传对方尚未收到的报文段，不必等待那个报文段设置的重传计时器超时。")]),t._v(" "),s("li",[s("strong",[t._v("快恢复")]),t._v("：当发送方连续收到三个冗余 ACK (即重复确认） 时， 执行 “乘法减小” 算法， 把慢开始门限 ssthresh 设置为此时发送方 cwnd 的一半。")])]),t._v(" "),s("h3",{attrs:{id:"http-报文格式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http-报文格式"}},[t._v("#")]),t._v(" HTTP 报文格式")]),t._v(" "),s("p",[t._v("HTTP 请求由 "),s("strong",[t._v("请求行、请求头部、空行和请求体")]),t._v(" 四个部分组成。")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("请求行")]),t._v("：包括 "),s("RouterLink",{attrs:{to:"/http/xbo9wy/#请求方法"}},[s("strong",[t._v("请求方法")])]),t._v("、访问的资源 URL、协议版本。")],1),t._v(" "),s("li",[s("strong",[t._v("请求头")]),t._v("：格式为 "),s("code",[t._v("属性名:属性值")]),t._v("，服务端根据请求头获取客户端的信息，主要有 Cookie、Host、Connection、Accept-Language、Accept-Encoding、User-Agent。")]),t._v(" "),s("li",[s("strong",[t._v("请求体")]),t._v("：用户的请求数据。")])]),t._v(" "),s("p",[s("strong",[t._v("请求报文示例")]),t._v("：")]),t._v(" "),s("div",{staticClass:"language-http extra-class"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token request-line"}},[s("span",{pre:!0,attrs:{class:"token method property"}},[t._v("POST")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token request-target url"}},[t._v("/xxx")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token http-version property"}},[t._v("HTTP/1.1")])]),t._v(" \t\t\t\t\t\t\t\t请求行\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Accept")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("image/gif.image/jpeg\t\t\t\t\t\t请求头")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Accept-Language")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("zh-cn")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Connection")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("Keep-Alive")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Host")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("localhost")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("User-Agent")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("Mozila/4.0(compatible;MSIE5.01;Window NT5.0)")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Accept-Encoding")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("gzip,deflate\n\t\t\t\t\t\t\t\t\t\t\t\t空行")])]),t._v("\nusername=dabin \t\t\t\t\t\t\t\t\t请求体\n")])])]),s("p",[t._v("HTTP 响应同样由四个部分组成，分别是："),s("strong",[t._v("状态行、响应头、空行和响应体")]),t._v("。")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("状态行")]),t._v("：协议版本、状态码及状态描述。")]),t._v(" "),s("li",[s("strong",[t._v("响应头")]),t._v("：响应头字段主要有 Connection、Content-Type、Content-Encoding、Content-Length、Set-Cookie、Last-Modified、Cache-Control、Expires。")]),t._v(" "),s("li",[s("strong",[t._v("响应体")]),t._v("：服务器返回给客户端的内容。")])]),t._v(" "),s("p",[s("strong",[t._v("响应报文示例")]),t._v("：")]),t._v(" "),s("div",{staticClass:"language-http extra-class"},[s("pre",{pre:!0,attrs:{class:"language-http"}},[s("code",[s("span",{pre:!0,attrs:{class:"token response-status"}},[s("span",{pre:!0,attrs:{class:"token http-version property"}},[t._v("HTTP/1.1")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token status-code number"}},[t._v("200")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token reason-phrase string"}},[t._v("OK\t\t\t\t\t\t\t\t\t状态行")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Server")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("Apache Tomcat/5.0.12\t\t\t\t\t\t响应头")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Date")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("Mon,6Oct2003 13:23:42 GMT")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token header"}},[s("span",{pre:!0,attrs:{class:"token header-name keyword"}},[t._v("Content-Length")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token header-value"}},[t._v("112\n\t\t\t\t\t\t\t\t\t\t\t\t空行")])]),t._v("\n<html>\t\t\t\t\t\t\t\t\t\t\t响应体\n    <body>响应体</body>\n</html>\n")])])]),s("h3",{attrs:{id:"get-和-post-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#get-和-post-的区别"}},[t._v("#")]),t._v(" GET 和 POST 的区别")]),t._v(" "),s("ul",[s("li",[t._v("GET 请求参数通过 URL 传递，POST 的参数放在请求体中。")]),t._v(" "),s("li",[t._v("GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。")]),t._v(" "),s("li",[t._v("GET 产生一个 TCP 数据包，POST 产生两个 TCP 数据包。对于 GET，浏览器把请求头和请求体一并发送出去；而对于 POST，浏览器先发送请求头，服务器响应 100 continue，浏览器再发送请求体。")]),t._v(" "),s("li",[t._v("GET 请求会被浏览器主动缓存，而 POST 不会，除非手动设置。")])]),t._v(" "),s("h3",{attrs:{id:"http-状态码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http-状态码"}},[t._v("#")]),t._v(" HTTP 状态码")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",{staticStyle:{"text-align":"center"}},[t._v("状态码")]),t._v(" "),s("th",[t._v("描述")])])]),t._v(" "),s("tbody",[s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("1XX")]),t._v(" "),s("td",[t._v("服务器收到请求，需要请求者继续执行操作")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("2XX")]),t._v(" "),s("td",[t._v("请求正常处理完毕")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("3XX")]),t._v(" "),s("td",[t._v("重定向，需要进一步操作已完成请求")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("4XX")]),t._v(" "),s("td",[t._v("客户端错误，服务器无法处理请求")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("5XX")]),t._v(" "),s("td",[t._v("服务器处理请求出错")])])])]),t._v(" "),s("h3",{attrs:{id:"http-短连接和长连接"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http-短连接和长连接"}},[t._v("#")]),t._v(" HTTP 短连接和长连接")]),t._v(" "),s("p",[s("strong",[t._v("HTTP 短连接")]),t._v("：浏览器和服务器每进行一次 HTTP 操作，就建立一次 TCP 连接，任务结束就中断连接。HTTP1. 0 默认使用的是短连接。")]),t._v(" "),s("p",[s("strong",[t._v("HTTP 长连接")]),t._v("：指的是 "),s("strong",[t._v("复用 TCP 连接")]),t._v("。多个 HTTP 请求可以复用同一个 TCP 连接，这就节省了 TCP 连接建立和断开的消耗。")]),t._v(" "),s("p",[t._v("通过在头部（请求和响应头）设置 "),s("strong",[t._v("Connection")]),t._v(" 字段指定为 "),s("strong",[t._v("keep-alive")]),t._v("，HTTP/1.0 协议支持，但是是默认关闭的，从 HTTP/1.1 以后，连接默认都是长连接。")]),t._v(" "),s("h3",{attrs:{id:"http-协议版本"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http-协议版本"}},[t._v("#")]),t._v(" HTTP 协议版本")]),t._v(" "),s("div",{staticClass:"tag-group"},[s("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("百度")])],1),s("div",{staticClass:"anchor",attrs:{id:"http-2-0-与-http-1-1-的区别"}},[t._v("HTTP/2.0 与 HTTP/1.1 的区别")]),s("p",[t._v("HTTP/2.0 相比 HTTP/1.1 支持的特性：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("二进制格式")]),t._v("：HTTP/1.1 基于 "),s("strong",[t._v("文本格式")]),t._v(" 传输；HTTP/2.0 基于 "),s("strong",[t._v("二进制格式")]),t._v(" 传输，解析更高效。")]),t._v(" "),s("li",[s("strong",[t._v("多路复用")]),t._v("：在一个连接里，允许同时发送多个请求或响应，"),s("strong",[t._v("并且这些请求或响应能够并行的传输而不被阻塞")]),t._v("，避免 HTTP/1.1 出现的 “队头堵塞” 问题。")]),t._v(" "),s("li",[s("strong",[t._v("头部压缩")]),t._v("：HTTP/1.1 的 header 带有大量信息，而且每次都要重复发送；HTTP/2.0 "),s("strong",[t._v("把 header 从数据中分离")]),t._v("，并封装成头帧和数据帧，使用特定算法压缩头帧，有效减少头信息大小。HTTP/2.0 在客户端和服务器端记录了之前发送的键值对，"),s("strong",[t._v("对于相同的数据，不会重复发送")]),t._v("。比如请求 a 发送了所有的头信息字段，请求 b 则只需要发送差异数据，这样可以减少冗余数据，降低开销。")]),t._v(" "),s("li",[s("strong",[t._v("服务端推送")]),t._v("：HTTP/2.0 允许服务器向客户端推送资源，无需客户端发送请求到服务器获取。")])]),t._v(" "),s("div",{staticClass:"anchor",attrs:{id:"http-3-0-与-http-2-0-的区别"}},[t._v("HTTP/3.0 与 HTTP/2.0 的区别")]),s("p",[t._v("HTTP/3.0 基于 UDP 协议，即 "),s("strong",[t._v("QUIC")]),t._v(" （Quick UDP Internet Connections）。")]),t._v(" "),s("p",[t._v("HTTP/3.0 相比 HTTP/2.0 支持的特性：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("队头阻塞问题的解决更为彻底")]),t._v("：理论上，HTTP/2.0 不同的流之间相互独立，不会相互影响，但在实际传输方面，数据还是要一帧一帧的发送和接收，一旦某一个流的数据有丢包，则同样会阻塞在它之后传输的流数据传输。而基于 UDP 的 QUIC 协议则可以更为彻底地解决这样的问题，让不同的流之间真正的实现相互独立传输，互不干扰。")]),t._v(" "),s("li",[s("strong",[t._v("切换网络时的连接保持")]),t._v("：基于 TCP 的协议，由于切换网络之后，IP 会改变，因而之前的连接不能继续保持。而基于 UDP 的 QUIC 协议，则可以内建与 TCP 中不同的连接标识方法，从而在网络完成切换之后，恢复之前与服务器的连接。")])]),t._v(" "),s("h3",{attrs:{id:"https-与-http-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#https-与-http-的区别"}},[t._v("#")]),t._v(" HTTPS 与 HTTP 的区别")]),t._v(" "),s("ul",[s("li",[t._v("HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS "),s("strong",[t._v("在 TCP 和 HTTP 层之间加入了 SSL/TLS 安全协议")]),t._v("，使得报文能够加密传输。")]),t._v(" "),s("li",[t._v("HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。HTTPS "),s("strong",[t._v("在 TCP 三次握手之后，还需进行 SSL/TLS 握手")]),t._v("，才可进入加密报文传输。")]),t._v(" "),s("li",[t._v("两者的默认端口不一样，HTTP 默认端口号是 80，"),s("strong",[t._v("HTTPS 默认端口号是 443。")])]),t._v(" "),s("li",[s("strong",[t._v("HTTPS 协议需要向 CA（证书权威机构）申请数字证书")]),t._v("，来保证服务器的身份是可信的。")])]),t._v(" "),s("h3",{attrs:{id:"什么是数字证书"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是数字证书"}},[t._v("#")]),t._v(" 什么是数字证书")]),t._v(" "),s("p",[t._v("数字证书认证机构（CA）使用自己的私钥对服务器的公钥和服务器信息进行 "),s("RouterLink",{attrs:{to:"/http/3djudn/#摘要算法与数字签名"}},[s("strong",[t._v("数字签名")])]),t._v("，然后将这个签名和公钥一起打包成 "),s("RouterLink",{attrs:{to:"/http/3djudn/#数字证书"}},[s("strong",[t._v("数字证书")])]),t._v("。"),s("strong",[t._v("数字证书可以包含服务器信息、公钥和数字签名等信息。")])],1),t._v(" "),s("p",[t._v("当客户端连接服务器时，服务器会将数字证书发送给客户端，客户端会使用 CA 的公钥来解密数字签名，以验证数字证书的合法性。如果数字证书是合法的，客户端就可以信任公钥，并使用该公钥进行通信。")]),t._v(" "),s("h3",{attrs:{id:"tls-握手协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tls-握手协议"}},[t._v("#")]),t._v(" TLS 握手协议")]),t._v(" "),s("div",{staticClass:"anchor",attrs:{id:"1、clienthello"}},[t._v("1、ClientHello")]),s("p",[t._v("首先，由客户端向服务器发起加密通信请求，即 ClientHello 请求。")]),t._v(" "),s("p",[t._v("在这一步，客户端主要向服务器发送以下信息：")]),t._v(" "),s("ul",[s("li",[t._v("客户端支持的 TLS 协议版本，如 TLS 1.2 版本。")]),t._v(" "),s("li",[t._v("客户端生产的随机数（Client Random），后面用于生成 “会话秘钥” 条件之一。")]),t._v(" "),s("li",[t._v("客户端支持的密码套件列表，如 RSA 加密算法。")])]),t._v(" "),s("div",{staticClass:"anchor",attrs:{id:"2、severhello"}},[t._v("2、SeverHello")]),s("p",[t._v("服务器收到客户端请求后，向客户端发出响应，即 SeverHello。服务器回应的内容有如下内容：")]),t._v(" "),s("ul",[s("li",[t._v("确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。")]),t._v(" "),s("li",[t._v("服务器生产的随机数（Server Random），后面用于生成 “会话秘钥” 条件之一。")]),t._v(" "),s("li",[t._v("确认的密码套件列表，如 RSA 加密算法。")]),t._v(" "),s("li",[s("strong",[t._v("服务器的数字证书。")])])]),t._v(" "),s("div",{staticClass:"anchor",attrs:{id:"3、客户端回应"}},[t._v("3、客户端回应")]),s("p",[t._v("客户端收到服务器回应后，首先通过浏览器或者操作系统中的 CA 公钥确认服务器的数字证书的真实性。")]),t._v(" "),s("p",[t._v("如果验证通过，客户端会 "),s("strong",[t._v("从数字证书中取出服务器的公钥")]),t._v("，使用它加密报文，向服务器发送如下信息：")]),t._v(" "),s("ul",[s("li",[t._v("一个随机数（pre-master key）。该随机数会被服务器公钥加密。")]),t._v(" "),s("li",[t._v("加密通信算法改变通知，表示随后的信息都将用 “会话秘钥” 加密通信。")]),t._v(" "),s("li",[t._v("客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。")])]),t._v(" "),s("p",[s("strong",[t._v("服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的 “会话秘钥” 。")])]),t._v(" "),s("div",{staticClass:"anchor",attrs:{id:"4、服务器的最后回应"}},[t._v("4、服务器的最后回应")]),s("p",[t._v("服务器收到客户端的第三个随机数（pre-master key）之后，通过协商的加密算法，计算出本次通信的 “会话秘钥” 。")]),t._v(" "),s("p",[t._v("然后，向客户端发送最后的信息：")]),t._v(" "),s("ul",[s("li",[t._v("加密通信算法改变通知，表示随后的信息都将用 “会话秘钥” 加密通信。")]),t._v(" "),s("li",[t._v("服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。")])]),t._v(" "),s("p",[t._v("至此，整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用 “会话秘钥” 加密内容。")]),t._v(" "),s("h3",{attrs:{id:"dns-域名解析过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#dns-域名解析过程"}},[t._v("#")]),t._v(" DNS 域名解析过程")]),t._v(" "),s("p",[t._v("当客户端需要域名解析时， 通过本机的 DNS 客户端构造一个 DNS 请求报文，以 UDP 数据报方式发往本地域名服务器。")]),t._v(" "),s("p",[t._v("域名解析有两种方式：递归查询和递归与迭代相结合的査询。")]),t._v(" "),s("p",[s("img",{attrs:{src:_(455),alt:"image-20221121001329829"}})]),t._v(" "),s("h2",{attrs:{id:"操作系统"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#操作系统"}},[t._v("#")]),t._v(" 操作系统")]),t._v(" "),s("h3",{attrs:{id:"进程间的通信方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程间的通信方式"}},[t._v("#")]),t._v(" 进程间的通信方式")]),t._v(" "),s("div",{staticClass:"tag-group"},[s("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("淘天")])],1),s("ul",[s("li",[s("strong",[t._v("管道（共享文件）")]),t._v("：管道的本质就是内核在内存中开辟了一个缓冲区，这个缓冲区与管道文件相关联，对管道文件的操作，被内核转换成对这块缓冲区的操作。")]),t._v(" "),s("li",[s("strong",[t._v("消息队列（消息传递）")]),t._v("：消息队列的本质就是存放在内存中的消息的链表，而消息本质上是用户自定义的数据结构。如果进程从消息队列中读取了某个消息，这个消息就会被从消息队列中删除。")]),t._v(" "),s("li",[s("strong",[t._v("共享内存（共享存储）")]),t._v("：共享内存就是允许不相干的进程将同一段物理内存连接到它们各自的地址空间中，使得这些进程可以访问同一个物理内存，这个物理内存就成为共享内存。")]),t._v(" "),s("li",[s("strong",[t._v("信号量和 PV 操作")]),t._v("：进程的同步与互斥其实是一种对进程通信的保护机制，并不是用来传输进程之间真正通信的内容的，但是由于它们会传输信号量，因此被纳入进程通信的范畴，称为低级通信。")]),t._v(" "),s("li",[s("strong",[t._v("信号")]),t._v("：通过发送指定信号来通知进程某个异步事件的发送，以迫使进程执行信号处理程序。信号处理完毕后，被中断进程将恢复执行。")]),t._v(" "),s("li",[s("strong",[t._v("套接字（Socket）")]),t._v("：Socket 的本质其实是一个编程接口（API），是应用层与 TCP/IP 协议族通信的中间软件抽象层，它对 TCP/IP 进行了封装，把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面。")])]),t._v(" "),s("h3",{attrs:{id:"进程、线程与协程的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程、线程与协程的区别"}},[t._v("#")]),t._v(" 进程、线程与协程的区别")]),t._v(" "),s("div",{staticClass:"tag-group"},[s("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("美团到店")]),s("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("腾讯PCG")])],1),s("style",[t._v("\n                        .table-column-x-x-container-q16vz304 table th:nth-of-type(1) {\n                            width: 10.81081081081081%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-q16vz304 table th:nth-of-type(2) {\n                            width: 29.72972972972973%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-q16vz304 table th:nth-of-type(3) {\n                            width: 29.72972972972973%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-q16vz304 table th:nth-of-type(4) {\n                            width: 29.72972972972973%;\n                            word-wrap: break-word;\n                        }\n                    ")]),s("div",{staticClass:"table-column-x-x-container-q16vz304"},[s("table",[s("thead",[s("tr",[s("th",{staticStyle:{"text-align":"center"}}),t._v(" "),s("th",[t._v("进程")]),t._v(" "),s("th",[t._v("线程")]),t._v(" "),s("th",[t._v("协程（用户态线程）")])])]),t._v(" "),s("tbody",[s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("根本区别")]),t._v(" "),s("td",[t._v("操作系统进行 "),s("strong",[t._v("资源分配的最小单元")])]),t._v(" "),s("td",[t._v("操作系统进行 "),s("strong",[t._v("CPU 调度的最小单元")])]),t._v(" "),s("td",[t._v("用户程序进行 "),s("strong",[t._v("任务调度的最小单元")])])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("拥有资源")]),t._v(" "),s("td",[t._v("每个进程 "),s("strong",[t._v("有自己的内存和资源")])]),t._v(" "),s("td",[s("strong",[t._v("共享")]),t._v(" 进程的内存和资源")]),t._v(" "),s("td",[s("strong",[t._v("共享")]),t._v(" 进程的内存和资源")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("开销不同")]),t._v(" "),s("td",[t._v("进程的 "),s("strong",[t._v("创建、销毁和切换的开销")]),t._v(" 都远大于线程")]),t._v(" "),s("td",[t._v("中")]),t._v(" "),s("td",[t._v("低")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("切换时机")]),t._v(" "),s("td",[t._v("根据操作系统自己的切换策略，用户不感知")]),t._v(" "),s("td",[t._v("操作系统根据自己的切换策略决定，用户不感知")]),t._v(" "),s("td",[t._v("用户（的程序）决定")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("切换效率")]),t._v(" "),s("td",[t._v("低，陷入内核态")]),t._v(" "),s("td",[t._v("中，陷入内核态")]),t._v(" "),s("td",[t._v("高，不会陷入内核态")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("从属关系")]),t._v(" "),s("td",[t._v("进程中包含线程")]),t._v(" "),s("td",[t._v("线程中包含协程")]),t._v(" "),s("td",[t._v("协程是一个函数")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("影响范围")]),t._v(" "),s("td",[t._v("子进程无法影响父进程")]),t._v(" "),s("td",[t._v("子线程可以影响父线程")]),t._v(" "),s("td",[t._v("子协程可以影响父协程")])])])])]),s("h3",{attrs:{id:"进程的调度策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进程的调度策略"}},[t._v("#")]),t._v(" 进程的调度策略")]),t._v(" "),s("div",{staticClass:"tag-group"},[s("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("大疆")])],1),s("ul",[s("li",[s("strong",[t._v("先来先服务（First-Come, First-Served，FCFS）")]),t._v("：按照进程到达顺序进行调度。一旦一个进程开始执行，它会一直运行直到完成或阻塞。")]),t._v(" "),s("li",[s("strong",[t._v("最短作业优先（Shortest Job Next，SJN）")]),t._v("： 选择估计运行时间最短的进程进行执行。这可以最小化平均等待时间，但需要对进程的运行时间有准确的预测。")]),t._v(" "),s("li",[s("strong",[t._v("最高响应比优先（Highest Response Ratio Next，HRRN）")]),t._v("：选择响应比最高的进程执行，综合考虑进程等待时间和预测的执行时间，以最大程度地减少长作业的等待时间。"),s("strong",[t._v("响应比 = 1 + 等待时间 / 预测执行时间")])]),t._v(" "),s("li",[s("strong",[t._v("最高优先级优先（Highest Priority First，HPF）")]),t._v("： 每个进程都有一个优先级，操作系统选择优先级最高的进程执行。这可以保证高优先级任务被及时处理，但可能导致低优先级任务饥饿。")]),t._v(" "),s("li",[s("strong",[t._v("时间片轮转（Round Robin，RR）")]),t._v("：每个进程被分配一个固定的时间片，时间片用完之后，系统切换到下一个进程。这可以实现公平调度，但可能导致上下文切换开销过大。")]),t._v(" "),s("li",[s("strong",[t._v("多级反馈队列（Multilevel Feedback Queue，MLFQ）")]),t._v("： 将进程分为多个优先级队列，每个队列具有不同的时间片大小。当一个进程在一个队列中用完时间片后，它可以降低优先级并进入下一个队列。")])]),t._v(" "),s("h3",{attrs:{id:"select、poll-和-epoll-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#select、poll-和-epoll-的区别"}},[t._v("#")]),t._v(" select、poll 和 epoll 的区别")]),t._v(" "),s("div",{staticClass:"tag-group"},[s("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("腾讯PCG")])],1),s("style",[t._v("\n                        .table-column-x-x-container-6ii9e5bo table th:nth-of-type(1) {\n                            width: 16.666666666666664%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-6ii9e5bo table th:nth-of-type(2) {\n                            width: 27.77777777777778%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-6ii9e5bo table th:nth-of-type(3) {\n                            width: 27.77777777777778%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-6ii9e5bo table th:nth-of-type(4) {\n                            width: 27.77777777777778%;\n                            word-wrap: break-word;\n                        }\n                    ")]),s("div",{staticClass:"table-column-x-x-container-6ii9e5bo"},[s("div",{staticStyle:{"font-size":"14px"}},[s("table",[s("thead",[s("tr",[s("th",[t._v("系统调用")]),t._v(" "),s("th",[t._v("select")]),t._v(" "),s("th",[t._v("poll")]),t._v(" "),s("th",[t._v("epoll")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("事件集合")]),t._v(" "),s("td",[t._v("通过 3 个参数传入感兴趣的 "),s("strong",[t._v("可读、可写及异常")]),t._v(" 等事件，内核通过对这些参数的修改来反馈其中的就绪事件。这使得用户每次调用 select 都要重置这 3 个参数。")]),t._v(" "),s("td",[t._v("只需 "),s("strong",[t._v("1 个事件集")]),t._v(" 参数，通过 pollfd.events 传入感兴趣的事件，内核通过修改 pollfd.revents 反馈其中就绪的事件。")]),t._v(" "),s("td",[t._v("内核通过 "),s("strong",[t._v("事件表")]),t._v(" 直接管理用户注册的事件。因此，每次调用 epoll_wait "),s("strong",[t._v("无须反复传入感兴趣的事件")]),t._v("。epoll_wait 系统调用的参数 events 仅用来反馈就绪的事件。")])]),t._v(" "),s("tr",[s("td",[t._v("索引就绪文件描述符的时间复杂度")]),t._v(" "),s("td",[s("strong",[t._v("O(n)")])]),t._v(" "),s("td",[s("strong",[t._v("O(n)")])]),t._v(" "),s("td",[s("strong",[t._v("O(1)")])])]),t._v(" "),s("tr",[s("td",[t._v("最大支持文件描述符数")]),t._v(" "),s("td",[t._v("受 fd_set 大小限制，32 位系统最多监听 "),s("strong",[t._v("1024")]),t._v(" 个 fd，64 位最多监听 2048 个。")]),t._v(" "),s("td",[t._v("65535")]),t._v(" "),s("td",[t._v("65535")])]),t._v(" "),s("tr",[s("td",[t._v("工作模式")]),t._v(" "),s("td",[t._v("LT")]),t._v(" "),s("td",[t._v("LT")]),t._v(" "),s("td",[t._v("支持 ET 高效模式")])]),t._v(" "),s("tr",[s("td",[t._v("内核实现")]),t._v(" "),s("td",[t._v("通过 "),s("strong",[t._v("轮询")]),t._v(" 来检测就绪事件，时间复杂度为 "),s("strong",[t._v("O(n)")])]),t._v(" "),s("td",[t._v("通过 "),s("strong",[t._v("轮询")]),t._v(" 来检测就绪事件，时间复杂度为 "),s("strong",[t._v("O(n)")])]),t._v(" "),s("td",[t._v("通过 "),s("strong",[t._v("回调")]),t._v(" 来检测就绪事件，时间复杂度为 O(1)")])])])])])])])}),[],!1,null,null,null);v.default=r.exports},454:function(t,v,_){t.exports=_.p+"assets/img/image-20221120234254876.e1173893.png"},455:function(t,v,_){t.exports=_.p+"assets/img/image-20221121001329829.b51a550d.png"}}]);