(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{1004:function(a,e,r){"use strict";r.r(e);var t=r(14),s=Object(t.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"第2章-一致性算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第2章-一致性算法"}},[a._v("#")]),a._v(" 第2章 一致性算法")]),a._v(" "),t("h2",{attrs:{id:"_2-1-paxos-算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-paxos-算法"}},[a._v("#")]),a._v(" 2.1 Paxos 算法")]),a._v(" "),t("p",[a._v("Paxos 算法解决的正是分布式一致性问题，即分布式系统中的各个进程如何就某个值（决议）达成一致。")]),a._v(" "),t("p",[a._v("Paxos 算法运行在允许宕机故障的异步系统中，不要求可靠的消息传递，可容忍消息丢失、延迟、乱序以及重复。它利用大多数 （Majority） 机制保证了 2F+1 的容错能力，即 2F+1 个节点的系统最多允许 F 个节点同时出现故障。")]),a._v(" "),t("h3",{attrs:{id:"角色"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#角色"}},[a._v("#")]),a._v(" 角色")]),a._v(" "),t("p",[a._v("Paxos 将系统中的角色分为 Proposer、Acceptor 和 Learner。")]),a._v(" "),t("ul",[t("li",[t("strong",[a._v("Proposer")]),a._v("：将 Client 的请求作为一个 value 包装成一个 proposal 发送给所有的 Acceptor，由 Acceptor 来做仲裁。")]),a._v(" "),t("li",[t("strong",[a._v("Acceptor")]),a._v("：当 "),t("strong",[a._v("超过半数")]),a._v(" 的 Acceptor 都 accept 了某个 proposal 时，这个 proposal 中的 value 就会被唯一选定，且不会再改变。")]),a._v(" "),t("li",[t("strong",[a._v("Learner")]),a._v("：不参与决策，从 Proposers/Acceptors 学习最新达成一致的提案（Value）。")])]),a._v(" "),t("p",[a._v("在多副本状态机中，每个副本同时具有 Proposer、Acceptor、Learner 三种角色。")]),a._v(" "),t("p",[a._v("在一个 Proposer 提出 proposal 之前，应当先检查是否已经有一个选定的 value，如果有了就不再提出新的 value 了，这种先检查后提交的方式，正是 2PC。")]),a._v(" "),t("h3",{attrs:{id:"运行流程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#运行流程"}},[a._v("#")]),a._v(" 运行流程")]),a._v(" "),t("p",[a._v("至此我们知道了 Basic Paxos 算法种包含的各种角色，考虑并解决了种种可能出错的情况，接下来通过一张图，疏通一下 Basic Paxos 整体运行流程：")]),a._v(" "),t("p",[t("img",{attrs:{src:r(615),alt:"image-20230827163739718.drawio"}})]),a._v(" "),t("h2",{attrs:{id:"_2-2-raft-算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-raft-算法"}},[a._v("#")]),a._v(" 2.2 Raft 算法")]),a._v(" "),t("p",[a._v("Raft 将一致性分解为多个子问题：Leader 选举、日志同步、安全性、日志压缩、成员变更等。")]),a._v(" "),t("p",[a._v("同时，Raft 算法使用了更强的假设来减少了需要考虑的状态，使之变的易于理解和实现。")]),a._v(" "),t("h3",{attrs:{id:"角色-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#角色-2"}},[a._v("#")]),a._v(" 角色")]),a._v(" "),t("p",[a._v("Raft 将系统中的角色分为 Leader、Follower 和 Candidate：")]),a._v(" "),t("ul",[t("li",[t("strong",[a._v("Leader")]),a._v("：接受客户端请求，并向 Follower 同步请求日志，当日志同步到大多数节点上后告诉 Follower 提交日志。")]),a._v(" "),t("li",[t("strong",[a._v("Follower")]),a._v("：接受并持久化 Leader 同步的日志，在 Leader 告之日志可以提交之后，提交日志。")]),a._v(" "),t("li",[t("strong",[a._v("Candidate")]),a._v("：选举过程中的临时角色。")])]),a._v(" "),t("p",[a._v("Raft 要求系统在任意时刻最多只有一个 Leader，正常工作期间只有 Leader 和 Followers。")]),a._v(" "),t("h3",{attrs:{id:"leader-选举"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#leader-选举"}},[a._v("#")]),a._v(" Leader 选举")]),a._v(" "),t("p",[a._v("Raft 使用心跳（heartbeat）触发 Leader 选举。当服务器启动时，初始化为 Follower。Leader 向所有 Followers 周期性发送 heartbeat。如果 Follower 在选举超时时间内没有收到 Leader 的 heartbeat，就会等待一段随机的时间后发起一次 Leader 选举。")]),a._v(" "),t("p",[a._v("Follower 将其当前任期（term）加一然后转换为 Candidate。它首先给自己投票并且给集群中的其他节点发送 "),t("strong",[a._v("RequestVote RPC")]),a._v("。结果有以下三种情况：")]),a._v(" "),t("ul",[t("li",[t("strong",[a._v("选举成功")]),a._v("：Candidate 从整个集群的 "),t("strong",[a._v("大多数（N/2+1）")]),a._v(" 节点获得了针对同一 term 的选票时，就赢得了这次选举，立刻将自己的身份转变为 Leader 并开始向其它节点发送心跳来维持自己的权威。")]),a._v(" "),t("li",[t("strong",[a._v("选举失败")]),a._v("：Candidate 等待回复时，可能收到其它自称 Leader 的节点发送的心跳包，如果这个心跳包的 term 不小于 Candidate 当前的 term，Candidate 会承认这个 leader，并将身份切回 Follower。")]),a._v(" "),t("li",[t("strong",[a._v("选举超时")]),a._v("：如果有多个 Follower 同时成为 Candidate，且没有任何一个 Candidate 能得到大多数节点的支持，那么每个 Candidate 都会超时。"),t("strong",[a._v("此时 Candidate 增加自己的 term，然后发起新一轮选举。")])])]),a._v(" "),t("p",[a._v("选举出 Leader 后，Leader 通过定期向所有 Followers 发送心跳信息维持其统治。若 Follower 一段时间未收到 Leader 的心跳则认为 Leader 可能已经挂了，再次发起 Leader 选举过程。")]),a._v(" "),t("h3",{attrs:{id:"日志同步"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#日志同步"}},[a._v("#")]),a._v(" 日志同步")]),a._v(" "),t("p",[a._v("Leader 被票选出来后，就承担起领导整个集群的责任了，开始接收客户端请求，并将操作包装成日志，并复制到其它节点上去。")]),a._v(" "),t("p",[a._v("整体流程如下：")]),a._v(" "),t("ul",[t("li",[a._v("Leader 为客户端提供服务，客户端的每个请求都包含一条即将被状态复制机执行的指令。")]),a._v(" "),t("li",[a._v("Leader 把该指令作为一条新的日志附加到自身的日志集合，然后向其它节点发起 "),t("strong",[a._v("附加条目请求 AppendEntries RPC")]),a._v("，要求它们将这条日志附加到各自本地的日志集合。")]),a._v(" "),t("li",[a._v("当这条日志已经确保被 "),t("strong",[a._v("安全的复制")]),a._v("，即 "),t("strong",[a._v("大多数（N/2+1）")]),a._v(" 节点都已经复制后，Leader 会将该日志 "),t("strong",[a._v("apply")]),a._v(" 到它本地的状态机中，然后把操作成功的结果返回给客户端。")])]),a._v(" "),t("p",[a._v("每条日志除了存储状态机的操作指令外，还会拥有一个唯一的整数索引值 log index 来表明它在日志集合中的位置。此外，每条日志还会存储一个 term 号，该 term 表示 leader 收到这条指令时的当前任期，term 相同的 log 是由同一个 leader 在其任期内发送的。")]),a._v(" "),t("h2",{attrs:{id:"_2-3-zab-算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-zab-算法"}},[a._v("#")]),a._v(" 2.3 ZAB 算法")]),a._v(" "),t("p",[a._v("ZAB 协议全称：Zookeeper Atomic Broadcast（Zookeeper 原子广播协议）。")]),a._v(" "),t("h3",{attrs:{id:"消息广播"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#消息广播"}},[a._v("#")]),a._v(" 消息广播")]),a._v(" "),t("p",[a._v("ZAB 协议的消息广播过程使用的是一个原子广播协议，类似一个二阶段提交过程。")]),a._v(" "),t("p",[a._v("对于客户端发送的写请求，全部由 Leader 接收，Leader 将请求封装成一个事务 Proposal，将其发送给所有 Follwer ，然后，根据所有 Follwer 的反馈，如果超过半数成功响应，则执行 commit 操作（先提交自己，再发送 commit 给所有 Follwer）。")]),a._v(" "),t("h3",{attrs:{id:"崩溃恢复"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#崩溃恢复"}},[a._v("#")]),a._v(" 崩溃恢复")]),a._v(" "),t("p",[t("strong",[a._v("崩溃恢复的主要任务就是选举 Leader（Leader Election）")]),a._v("，Leader 选举分两个场景：")]),a._v(" "),t("ul",[t("li",[a._v("Zookeeper 服务器启动时 Leader 选举。")]),a._v(" "),t("li",[a._v("Zookeeper 集群运行过程中 Leader 崩溃后的 Leader 选举。")])]),a._v(" "),t("div",{staticClass:"anchor",attrs:{id:"选举参数"}},[a._v("选举参数")]),t("p",[a._v("在介绍选举流程之前，需要介绍几个参数，")]),a._v(" "),t("ul",[t("li",[t("strong",[a._v("myid")]),a._v("：服务器 ID，在安装 Zookeeper 时配置的。myid 越大，则该节点器在选举中被选为 Leader 的优先级会越大。"),t("strong",[a._v("ZAB 算法中通过 myid 来规避了多个节点可能有相同 zxid 问题，注意可以对比之前的 Raft 算法，Raft 算法中通过随机的 timeout 来规避多个节点可能同时成为 Leader 的问题。")])]),a._v(" "),t("li",[t("strong",[a._v("zxid")]),a._v("：事务 ID，这个是由 Zookeeper 集群中的 Leader 节点进行 Proposal 时生成的全局唯一的事务 ID，由于只有 Leader 才能进行 Proposal，所以这个 zxid 很容易做到全局唯一且自增。因为 Follower 没有生成 zxid 的权限。zxid 越大，表示当前节点上提交成功了最新的事务。")]),a._v(" "),t("li",[t("strong",[a._v("epoch")]),a._v("：投票轮次，每完成一次 Leader 选举的投票，当前 Leader 节点的 epoch 会增加一次。在没有 Leader 时，本轮此的 epoch 会保持不变。")])]),a._v(" "),t("p",[a._v("在选举的过程中，每个节点的当前状态会在以下几种状态之中进行转变。")]),a._v(" "),t("ul",[t("li",[a._v("LOOKING：竞选状态。")]),a._v(" "),t("li",[a._v("FOLLOWING：随从状态，同步 Leader 状态，参与 Leader 选举的投票过程。")]),a._v(" "),t("li",[a._v("OBSERVING：观察状态，同步 Leader 状态，不参与 Leader 选举的投票过程。")]),a._v(" "),t("li",[a._v("LEADING：领导者状态。")])]),a._v(" "),t("div",{staticClass:"anchor",attrs:{id:"选举流程"}},[a._v("选举流程")]),t("p",[a._v("选举的流程如下：")]),a._v(" "),t("ul",[t("li",[a._v("节点进入 LOOKING 状态：所有节点都开始进入 LOOKING 状态，表示它们正在寻找新的 Leader。")]),a._v(" "),t("li",[a._v("提名自己：每个节点首先会为自己投票，将自己作为 Leader 候选人。")]),a._v(" "),t("li",[a._v("发送选票：节点会向集群中的其他节点发送选票，包含候选人的信息以及与之关联的 ZXID（ZooKeeper Transaction ID）。")]),a._v(" "),t("li",[a._v("收集选票：节点收到其他节点的选票后，会比较各个候选人的 ZXID，选择具有最大 ZXID 的节点作为 Leader 候选人。如果 ZXID 相同，比较 myid。")]),a._v(" "),t("li",[a._v("统计选票：节点需要等待一段时间来收集更多的选票。如果某个候选人收到了多数节点的选票（过半数），那么该候选人将成为新的 Leader。")]),a._v(" "),t("li",[a._v("完成选举：一旦某个候- 选人获得了多数选票，它就会被宣布为新的 Leader，然后其他节点会成为 Follower。")])]),a._v(" "),t("h2",{attrs:{id:"_2-4-一致性-hash-算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-一致性-hash-算法"}},[a._v("#")]),a._v(" 2.4 一致性 Hash 算法")]),a._v(" "),t("h3",{attrs:{id:"hash-环"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#hash-环"}},[a._v("#")]),a._v(" Hash 环")]),a._v(" "),t("p",[a._v("使用常见的 hash 算法可以把一个 key 值哈希到一个具有 2^32 个桶的空间中。即将 key 值哈希到 [0，2^32) 的一个数字空间中。我们假设这个是个首尾连接的环形空间。如下图：")]),a._v(" "),t("p",[t("img",{attrs:{src:r(616),alt:"image-20230823173448905"}})]),a._v(" "),t("p",[a._v("假设现在有 key1，key2，key3，key4 四个 key 值，我们通过一定的 hash 算法，将其对应到上面的环形 hash 空间中。")]),a._v(" "),t("p",[t("img",{attrs:{src:r(617),alt:"image-20230823173354970"}})]),a._v(" "),t("p",[a._v("同样的，假设我们有 3 台 cache 服务器，把缓存服务器通过 hash 算法，加入到上述的环中。一般情况下是根据机器的 IP 地址或者唯一的计算机别名进行哈希。")]),a._v(" "),t("p",[t("img",{attrs:{src:r(618),alt:"image-20230823173736518"}})]),a._v(" "),t("p",[a._v("接下来就是数据如何存储到 cache 服务器上了，key 值哈希之后的结果 "),t("strong",[a._v("顺时针")]),a._v(" 找上述环形 hash 空间中距离自己最近的机器节点，然后将数据存储到上面，如下图所示，k1 存储到 c3 服务器上，k4，k3 存储到 c1 服务器上，k2 存储在 c2 服务器上。")]),a._v(" "),t("p",[t("img",{attrs:{src:r(619),alt:"image-20230823174115974"}})]),a._v(" "),t("h3",{attrs:{id:"删除节点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#删除节点"}},[a._v("#")]),a._v(" 删除节点")]),a._v(" "),t("p",[a._v("假设 cache3 服务器宕机，这时候需要从集群中将其摘除。那么，之前存储再 c3 上的 k1，将会 "),t("strong",[a._v("顺时针")]),a._v(" 寻找距离它最近的一个节点，即 c1 节点，这样，k1 就会存储到 c1 上了。")]),a._v(" "),t("p",[t("img",{attrs:{src:r(620),alt:"image-20230823174330242"}})]),a._v(" "),t("p",[a._v("摘除 c3 节点之后，只影响到了原先存储再 c3 上的 k1，而 k3、k4、k2 都没有受到影响，意味着解决了普通 Hash 算法中可能带来的雪崩问题。")]),a._v(" "),t("h3",{attrs:{id:"增加节点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#增加节点"}},[a._v("#")]),a._v(" 增加节点")]),a._v(" "),t("p",[a._v("新增 c4 节点之后，原先存储到 c1 的 k4，迁移到了 c4，分担了 c1 上的存储压力和流量压力。")]),a._v(" "),t("p",[t("img",{attrs:{src:r(621),alt:"image-20230823175611885"}})]),a._v(" "),t("h3",{attrs:{id:"不平衡问题和虚拟节点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#不平衡问题和虚拟节点"}},[a._v("#")]),a._v(" 不平衡问题和虚拟节点")]),a._v(" "),t("p",[a._v("简单的一致性 hash 的方案在某些情况下但依旧存在问题：一个节点宕机之后，数据需要落到距离他最近的节点上，会导致下个节点的压力突然增大，可能导致雪崩，整个服务挂掉。")]),a._v(" "),t("p",[a._v("为了解决雪崩现象和数据倾斜现象，提出了虚拟节点这个概念。")]),a._v(" "),t("p",[t("strong",[a._v("虚拟节点")]),a._v("（virtual node）是实际节点（机器）在 hash 空间的复制品（replica），一实际个节点（机器）对应了若干个虚拟节点，虚拟节点在 hash 空间中以 hash 值排列。")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("hash(Visual100)—> V100  —> Real1\nhash(Visual101)—> V101  —> Real1\nhash(Visual200)—> V200  —> Real2\nhash(Visual201)—> V201  —> Real2\nhash(Visual300)—> V300  —> Real3\nhash(Visual301)—> V301  —> Real3\n")])])]),t("p",[t("img",{attrs:{src:r(622),alt:"image-20230823180300059"}})]),a._v(" "),t("p",[a._v("这样就解决了不平衡问题，某个节点宕机之后，存储及流量压力并没有全部转移到某台机器上，而是分散到了多台节点上。解决了节点宕机可能存在的雪崩问题。")])])}),[],!1,null,null,null);e.default=s.exports},615:function(a,e,r){a.exports=r.p+"assets/img/image-20230827163739718.drawio.d0ec1d74.png"},616:function(a,e,r){a.exports=r.p+"assets/img/image-20230823173448905.63f227bf.png"},617:function(a,e,r){a.exports=r.p+"assets/img/image-20230823173354970.c86818ca.png"},618:function(a,e,r){a.exports=r.p+"assets/img/image-20230823173736518.20317f3c.png"},619:function(a,e,r){a.exports=r.p+"assets/img/image-20230823174115974.f712ddef.png"},620:function(a,e,r){a.exports=r.p+"assets/img/image-20230823174330242.0cf8a3b2.png"},621:function(a,e,r){a.exports=r.p+"assets/img/image-20230823175611885.f4379d47.png"},622:function(a,e,r){a.exports=r.p+"assets/img/image-20230823180300059.e2737f8b.png"}}]);