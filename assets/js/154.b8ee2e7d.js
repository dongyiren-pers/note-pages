(window.webpackJsonp=window.webpackJsonp||[]).push([[154],{1085:function(e,s,t){"use strict";t.r(s);var r=t(14),a=Object(r.a)({},(function(){var e=this,s=e.$createElement,t=e._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"第2章-redis-线程模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第2章-redis-线程模型"}},[e._v("#")]),e._v(" 第2章 Redis 线程模型")]),e._v(" "),t("blockquote",[t("p",[e._v("对于一个 DB 来说，CPU 通常不会是瓶颈，因为大多数请求不会是 CPU 密集型的，而是 I/O 密集型。具体到 Redis 的话，如果不考虑 RDB/AOF 等持久化方案，Redis 是完全的纯内存操作，执行速度是非常快的，因此这部分操作通常不会是性能瓶颈，Redis 真正的性能瓶颈在于网络 I/O，即客户端和服务端之间的网络传输延迟，因此 Redis 选择了单线程的 I/O 多路复用来实现它的核心网络模型。")])]),e._v(" "),t("h2",{attrs:{id:"_2-1-单线程模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-单线程模型"}},[e._v("#")]),e._v(" 2.1 单线程模型")]),e._v(" "),t("p",[e._v("Redis 的单线程主要是指 Redis 的 "),t("strong",[e._v("网络 IO")]),e._v(" 和 "),t("strong",[e._v("键值对读写")]),e._v(" 是由一个线程来完成的，Redis 在处理客户端的请求时包括获取 （socket 读）、解析、执行、内容返回 （socket 写） 等都由一个顺序串行的主线程处理，这就是所谓的 “单线程”。这也是 Redis 对外提供键值存储服务的主要流程。")]),e._v(" "),t("p",[e._v("但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等等，其实是由额外的线程执行的。可以这么说，Redis 工作线程是单线程的。但是，整个 Redis 来说，是多线程的。")]),e._v(" "),t("h2",{attrs:{id:"_2-3-多线程模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-多线程模型"}},[e._v("#")]),e._v(" 2.3 多线程模型")]),e._v(" "),t("p",[e._v("Redis 4.0 之后引入多线程来做一些异步操作，比如以前 DEL 命令在删除 big key 和大量 key 时是阻塞操作，为了解决这个问题引入多线程使得部分命令支持多线程的异步操作，比如 UNLINK、FLUSHALL ASYNC、FLUSHDB ASYNC，此时的网络 I/O 模型仍然是单线程的（单 Reactor 模型）。")]),e._v(" "),t("p",[e._v("Redis 6.0 之后才引入多线程的网络 I/O 模型（多 Reactor 模型，但不是标准的多 Reactor 模型），总的流程还是跟单线程模型一样，只是把读取客户端命令和回写响应数据的操作交由 I/O 线程去执行异步化，"),t("strong",[e._v("I/O 线程仅仅是读取和解析客户端命令而不会真正去执行命令，客户端命令的执行最终还是要在主线程上完成")]),e._v("。")])])}),[],!1,null,null,null);s.default=a.exports}}]);