(window.webpackJsonp=window.webpackJsonp||[]).push([[128],{1029:function(t,s,v){"use strict";v.r(s);var _=v(14),r=Object(_.a)({},(function(){var t=this,s=t.$createElement,v=t._self._c||s;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"数据库"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据库"}},[t._v("#")]),t._v(" 数据库")]),t._v(" "),v("p"),v("div",{staticClass:"table-of-contents"},[v("ul",[v("li",[v("a",{attrs:{href:"#mysql"}},[t._v("MySQL")]),v("ul",[v("li",[v("a",{attrs:{href:"#mysql-的存储引擎"}},[t._v("MySQL 的存储引擎")])]),v("li",[v("a",{attrs:{href:"#innodb-与-myisam-的区别"}},[t._v("InnoDB 与 MyISAM 的区别")])]),v("li",[v("a",{attrs:{href:"#sql-的执行流程"}},[t._v("SQL 的执行流程")])]),v("li",[v("a",{attrs:{href:"#索引的分类"}},[t._v("索引的分类")])]),v("li",[v("a",{attrs:{href:"#为什么-innodb-选择-b-树作为索引"}},[t._v("为什么 InnoDB 选择 B+ 树作为索引")])]),v("li",[v("a",{attrs:{href:"#什么是覆盖索引"}},[t._v("什么是覆盖索引")])]),v("li",[v("a",{attrs:{href:"#什么是索引下推"}},[t._v("什么是索引下推")])]),v("li",[v("a",{attrs:{href:"#什么是索引合并"}},[t._v("什么是索引合并")])]),v("li",[v("a",{attrs:{href:"#索引失效的场景"}},[t._v("索引失效的场景")])]),v("li",[v("a",{attrs:{href:"#如何通过-explain-分析执行计划"}},[t._v("如何通过 EXPLAIN 分析执行计划")])]),v("li",[v("a",{attrs:{href:"#事务的四个特性"}},[t._v("事务的四个特性")])]),v("li",[v("a",{attrs:{href:"#如何保证事务的-acid-特性"}},[t._v("如何保证事务的 ACID 特性")])]),v("li",[v("a",{attrs:{href:"#事务隔离级别"}},[t._v("事务隔离级别")])]),v("li",[v("a",{attrs:{href:"#读已提交和可重复读是如何实现的"}},[t._v("读已提交和可重复读是如何实现的")])]),v("li",[v("a",{attrs:{href:"#mysql-的锁有哪些"}},[t._v("MySQL 的锁有哪些")])]),v("li",[v("a",{attrs:{href:"#bin-log、redo-log-和-undo-log-的功能"}},[t._v("bin log、redo log 和 undo log 的功能")])]),v("li",[v("a",{attrs:{href:"#mysql-的主从复制"}},[t._v("MySQL 的主从复制")])])])])])]),v("p"),t._v(" "),v("h2",{attrs:{id:"mysql"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql"}},[t._v("#")]),t._v(" MySQL")]),t._v(" "),v("h3",{attrs:{id:"mysql-的存储引擎"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql-的存储引擎"}},[t._v("#")]),t._v(" MySQL 的存储引擎")]),t._v(" "),v("div",{staticClass:"tag-group"},[v("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("阿里健康")])],1),v("p",[v("strong",[t._v("InnoDB")]),t._v("：InnoDB 是 MySQL 的默认存储引擎，也是最常用的存储引擎之一。它 "),v("strong",[t._v("支持事务处理、行级锁和外键约束")]),t._v(" 等高级功能。InnoDB 提供了较好的并发性能和数据完整性，适用于大多数应用场景。")]),t._v(" "),v("p",[v("strong",[t._v("MyISAM")]),t._v("：MyISAM 是 MySQL 早期版本中的一种常用存储引擎。它对于读密集型应用具有较好的性能，但 "),v("strong",[t._v("不支持事务处理、行级锁和外键约束")]),t._v("。MyISAM 适用于只读或很少更新的应用，例如博客等。")]),t._v(" "),v("p",[v("strong",[t._v("MEMORY")]),t._v(" ：该存储引擎将数据存储在内存中，因此读写速度非常快。它适用于临时表、缓存数据或其他需要快速访问的数据。然而，由于数据存储在内存中，一旦数据库重启，数据将丢失。")]),t._v(" "),v("h3",{attrs:{id:"innodb-与-myisam-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#innodb-与-myisam-的区别"}},[t._v("#")]),t._v(" InnoDB 与 MyISAM 的区别")]),t._v(" "),v("div",{staticClass:"tag-group"},[v("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("字节")])],1),v("ul",[v("li",[v("strong",[t._v("InnoDB 支持事务处理、行级锁和外键约束等高级功能，而 MyISAM 不支持。")])]),t._v(" "),v("li",[v("strong",[t._v("InnoDB 是聚集索引，MyISAM 是非聚集索引")]),t._v("。InnoDB 的 B+ 树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而 MyISAM 的 B+ 树主键索引和辅助索引的叶子节点都是数据文件的地址指针。")]),t._v(" "),v("li",[v("strong",[t._v("InnoDB 不保存表的总行数")]),t._v("，因此执行 "),v("code",[t._v("SELECT COUNT(*) FROM table")]),t._v(" 时需要对整个表进行全表扫描，而 "),v("strong",[t._v("MyISAM 通过一个变量保存总行数")]),t._v("，因此执行这条语句时速度更快。InnoDB 不保存表的具体行数的原因是因为它的事务特性。在同一时刻，对于不同的事务而言，表中的行数可能是不一样的。")])]),t._v(" "),v("h3",{attrs:{id:"sql-的执行流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#sql-的执行流程"}},[t._v("#")]),t._v(" SQL 的执行流程")]),t._v(" "),v("div",{staticClass:"tag-group"},[v("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("腾讯PCG")])],1),v("p",[v("strong",[t._v("SQL 查询语句的执行流程")]),t._v("：连接器 → 分析器 → 优化器 → 执行器 → 存储引擎")]),t._v(" "),v("p",[v("strong",[t._v("SQL 更新语句的执行流程")]),t._v("：与 SQL 查询语句相似，此外会涉及到写 binlog、redolog 和 undolog 日志。")]),t._v(" "),v("h3",{attrs:{id:"索引的分类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引的分类"}},[t._v("#")]),t._v(" 索引的分类")]),t._v(" "),v("div",{staticClass:"tag-group"},[v("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("快手本地生活")])],1),v("p",[t._v("常见的索引分类如下：")]),t._v(" "),v("ul",[v("li",[t._v("根据字段特性划分：普通索引、唯一索引、主键索引、全文索引")]),t._v(" "),v("li",[t._v("根据物理实现划分：聚簇索引、非聚簇索引")]),t._v(" "),v("li",[t._v("根据数据结构划分：B+ 树索引、B 树索引、Hash 索引、Full-text 索引")]),t._v(" "),v("li",[t._v("根据字段个数划分：单列索引、联合索引（又称复合索引、组合索引）")])]),t._v(" "),v("h3",{attrs:{id:"为什么-innodb-选择-b-树作为索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么-innodb-选择-b-树作为索引"}},[t._v("#")]),t._v(" 为什么 InnoDB 选择 B+ 树作为索引")]),t._v(" "),v("div",{staticClass:"tag-group"},[v("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("快手商业化")])],1),v("ul",[v("li",[v("strong",[t._v("与非平衡二叉树相比")]),t._v("：数据量过大时，非平衡二叉树的 "),v("strong",[t._v("高度很高")]),t._v("，磁盘 IO 次数过多。此外，极端情况下二叉树可能 "),v("strong",[t._v("退化成链表")]),t._v("，此时查找效率为 O(n)。")]),t._v(" "),v("li",[v("strong",[t._v("与红黑树相比")]),t._v("：红黑树通过自旋解决了二叉树退化成链表的问题，但在数据量过大的情况下，红黑树的 "),v("strong",[t._v("高度仍然很高")]),t._v("，磁盘 IO 次数仍然过多。")]),t._v(" "),v("li",[v("strong",[t._v("与 B 树索引相比")]),t._v("："),v("RouterLink",{attrs:{to:"/mysql/wfs82l/#b--树"}},[v("strong",[t._v("B+ 树")])]),t._v(" "),v("strong",[t._v("非叶子节点不存储数据")]),t._v("，只存储索引，可以存储更多的索引。当 B+ 树为三层的情况下，最多可以存放 1170 * 1170 * 16 = 21,902,400 条数据（16KB / (8B + 6B) = 1170 个）。即 "),v("strong",[t._v("千万级别")]),t._v(" 的表，只要经过 "),v("strong",[t._v("3 次磁盘 IO")]),t._v(" 就可以拿到想要的数据了。")],1),t._v(" "),v("li",[v("strong",[t._v("与哈希索引相比")]),t._v("：如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过⼀次算法即可找到相应的键值。如果是 "),v("strong",[t._v("范围查询检索")]),t._v("，这时候 哈希索引就 "),v("strong",[t._v("毫无用武之地")]),t._v(" 了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索。")])]),t._v(" "),v("h3",{attrs:{id:"什么是覆盖索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是覆盖索引"}},[t._v("#")]),t._v(" 什么是覆盖索引")]),t._v(" "),v("p",[t._v("从非主键索引中就能查到的记录，而不需要查询主键索引中的记录，避免了回表的产生，减少了树的搜索次数，显著提升性能。详见 "),v("RouterLink",{attrs:{to:"/mysql/wfs82l/#覆盖索引"}},[v("strong",[t._v("覆盖索引")])]),t._v("。")],1),t._v(" "),v("h3",{attrs:{id:"什么是索引下推"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是索引下推"}},[t._v("#")]),t._v(" 什么是索引下推")]),t._v(" "),v("p",[t._v("当执行一个包含 "),v("strong",[t._v("索引列条件")]),t._v(" 的查询时，MySQL 5.6 可以在存储引擎层级执行部分查询条件，从而减少从存储引擎返回到 Server 层的数据，"),v("strong",[t._v("进而减少回表次数")]),t._v("。详见 "),v("RouterLink",{attrs:{to:"/mysql/wfs82l/#索引下推"}},[v("strong",[t._v("索引下推")])]),t._v("。")],1),t._v(" "),v("h3",{attrs:{id:"什么是索引合并"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是索引合并"}},[t._v("#")]),t._v(" 什么是索引合并")]),t._v(" "),v("div",{staticClass:"tag-group"},[v("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("美团")])],1),v("p",[t._v("从 MySQL 5.1 开始，引入了 "),v("strong",[t._v("index merge")]),t._v(" 优化技术，对同一个表可以使用多个索引分别进行条件扫描，然后将结果进行合并处理。详见 "),v("RouterLink",{attrs:{to:"/mysql/wfs82l/#索引合并"}},[v("strong",[t._v("索引合并")])]),t._v("。")],1),t._v(" "),v("p",[t._v("合并方式分为三种："),v("strong",[t._v("intersection")]),t._v("（取交集）、"),v("strong",[t._v("union")]),t._v("（取并集）、"),v("strong",[t._v("Sort-Union")]),t._v("（取有序并集）。")]),t._v(" "),v("h3",{attrs:{id:"索引失效的场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引失效的场景"}},[t._v("#")]),t._v(" 索引失效的场景")]),t._v(" "),v("ul",[v("li",[v("RouterLink",{attrs:{to:"/mysql/wfs82l/#不满足最左前缀原则"}},[v("strong",[t._v("不满足最左前缀原则")])]),t._v("：最左边的字段没有出现在查询条件中。")],1),t._v(" "),v("li",[v("RouterLink",{attrs:{to:"/mysql/wfs82l/#select-的范围查询"}},[v("strong",[t._v("SELECT * 的范围查询")])]),t._v("：对 "),v("strong",[t._v("非聚簇索引列进行范围查询且结果列不满足覆盖索引条件")]),t._v(" 时，有极大概率不走索引。")],1),t._v(" "),v("li",[v("RouterLink",{attrs:{to:"/mysql/wfs82l/#模糊匹配占位符位于条件首部"}},[v("strong",[t._v("模糊匹配占位符位于条件首部")])]),t._v("：模糊查询时（LIKE 语句），模糊匹配占位符位于条件首部。")],1),t._v(" "),v("li",[v("RouterLink",{attrs:{to:"/mysql/wfs82l/#索引列参与运算"}},[v("strong",[t._v("索引列参与运算")])]),t._v("：索引列 "),v("strong",[t._v("参与了运算")]),t._v("，会导致全表扫描，索引失效。")],1),t._v(" "),v("li",[v("RouterLink",{attrs:{to:"/mysql/wfs82l/#索引列作为函数参数"}},[v("strong",[t._v("索引列作为函数参数")])]),t._v("：索引列 "),v("strong",[t._v("参与了函数处理")]),t._v("，会导致全表扫描，索引失效。")],1),t._v(" "),v("li",[v("RouterLink",{attrs:{to:"/mysql/wfs82l/#索引列发生类型隐式转换"}},[v("strong",[t._v("索引列发生类型隐式转换")])]),t._v("：参数类型与索引列类型不匹配，导致索引列发生类型隐式转换，索引失效。")],1),t._v(" "),v("li",[v("RouterLink",{attrs:{to:"/mysql/wfs82l/#使用-or-关键字"}},[v("strong",[t._v("使用 OR 关键字")])]),t._v("：查询条件使用 OR 关键字，而 "),v("strong",[t._v("其中一个字段没有创建索引")]),t._v("，则会导致整个查询语句索引失效。")],1),t._v(" "),v("li",[v("RouterLink",{attrs:{to:"/mysql/wfs82l/#对两列进行对比操作"}},[v("strong",[t._v("对两列进行对比操作")])]),t._v("：如果两个列数据都有索引，但在查询条件中 "),v("strong",[t._v("对两列数据进行了对比操作")]),t._v("，则会导致索引失效。")],1),t._v(" "),v("li",[v("RouterLink",{attrs:{to:"/mysql/wfs82l/#not-exists"}},[v("strong",[t._v("NOT EXISTS")])]),t._v("：查询条件使用 NOT EXISTS 时，索引失效。")],1),t._v(" "),v("li",[v("RouterLink",{attrs:{to:"/mysql/wfs82l/#_2-3-索引失效的场景"}},[v("strong",[t._v("使用 ORDER BY")])]),t._v("："),v("strong",[t._v("使用 ORDER BY 且结果列不满足最左前缀原则")]),t._v(" 时，索引失效。")],1)]),t._v(" "),v("h3",{attrs:{id:"如何通过-explain-分析执行计划"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何通过-explain-分析执行计划"}},[t._v("#")]),t._v(" 如何通过 EXPLAIN 分析执行计划")]),t._v(" "),v("div",{staticClass:"tag-group"},[v("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("阿里本地生活")]),v("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("腾讯PCG")])],1),v("p",[t._v("通过 "),v("strong",[t._v("EXPLAIN")]),t._v(" 分析执行计划：")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("type")]),t._v("：数据访问类型\n"),v("ul",[v("li",[t._v("const：使用主键或唯一索引进行等值查询")]),t._v(" "),v("li",[t._v("ref：使用非唯一索引等值查询")]),t._v(" "),v("li",[t._v("index_merge：使用了索引合并的优化逻辑")]),t._v(" "),v("li",[t._v("range：索引范围查询")]),t._v(" "),v("li",[t._v("index：索引全表扫描")]),t._v(" "),v("li",[t._v("all：全表扫描")])])]),t._v(" "),v("li",[v("strong",[t._v("possible_keys")]),t._v("：可能用到的索引")]),t._v(" "),v("li",[v("strong",[t._v("key")]),t._v("：实际用到的索引")]),t._v(" "),v("li",[v("strong",[t._v("rows")]),t._v("：预计扫描的行数")]),t._v(" "),v("li",[v("strong",[t._v("Extra")]),t._v("：附加信息\n"),v("ul",[v("li",[t._v("Using where：使用了 WHERE 条件")]),t._v(" "),v("li",[t._v("Using index：使用了覆盖索引")]),t._v(" "),v("li",[t._v("Using index condition：使用了索引下推")])])])]),t._v(" "),v("p",[t._v("只列举了常考字段，详见 "),v("RouterLink",{attrs:{to:"/mysql/wfs82l/#explain-执行计划"}},[v("strong",[t._v("EXPLAIN 执行计划")])]),t._v("。")],1),t._v(" "),v("h3",{attrs:{id:"事务的四个特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务的四个特性"}},[t._v("#")]),t._v(" 事务的四个特性")]),t._v(" "),v("div",{staticClass:"tag-group"},[v("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("阿里飞猪")])],1),v("ul",[v("li",[v("strong",[t._v("原子性（Atomicity）")]),t._v("：指⼀个事务中的操作要么全部成功，要么全部失败")]),t._v(" "),v("li",[v("strong",[t._v("一致性（Consistency）")]),t._v("：指事务将数据库从一个一致性状态变到另一个一致性状态。")]),t._v(" "),v("li",[v("strong",[t._v("隔离性（Isolation）")]),t._v("：指的是⼀个事务的修改在最终提交前，对其他事务是不可⻅的。")]),t._v(" "),v("li",[v("strong",[t._v("持久性（Durability）")]),t._v("：指的是⼀旦事务提交，所做的修改就会永久保存到数据库中。")])]),t._v(" "),v("h3",{attrs:{id:"如何保证事务的-acid-特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何保证事务的-acid-特性"}},[t._v("#")]),t._v(" 如何保证事务的 ACID 特性")]),t._v(" "),v("div",{staticClass:"tag-group"},[v("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("阿里健康")])],1),v("ul",[v("li",[v("strong",[t._v("原子性")]),t._v(" 由 "),v("RouterLink",{attrs:{to:"/mysql/cp5qss/#_5-3-undo-log"}},[v("strong",[t._v("undo log")])]),t._v(" 保证，它记录了需要回滚的⽇志信息，事务回滚时撤销已经执⾏成功的 SQL。")],1),t._v(" "),v("li",[v("strong",[t._v("⼀致性")]),t._v(" 由其他三⼤特性保证，程序代码要保证业务上的⼀致性  。")]),t._v(" "),v("li",[v("strong",[t._v("隔离性")]),t._v(" 由 "),v("RouterLink",{attrs:{to:"/mysql/xz81ss/#_7-5-mvcc"}},[v("strong",[t._v("MVCC")])]),t._v(" 和 "),v("strong",[t._v("锁")]),t._v(" 来保证。")],1),t._v(" "),v("li",[v("strong",[t._v("持久性")]),t._v(" 由内存和 "),v("RouterLink",{attrs:{to:"/mysql/cp5qss/#_5-2-redo-log"}},[v("strong",[t._v("redo log")])]),t._v(" 来保证，MySQL 修改数据同时在内存和 redo log 记录这次操作，宕机时从 redo log 恢复。")],1)]),t._v(" "),v("h3",{attrs:{id:"事务隔离级别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务隔离级别"}},[t._v("#")]),t._v(" 事务隔离级别")]),t._v(" "),v("div",{staticClass:"tag-group"},[v("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("阿里")])],1),v("ul",[v("li",[v("strong",[t._v("读未提交（READ-UNCOMMITTED）")]),t._v("：最低的隔离级别，"),v("strong",[t._v("允许读取尚未提交的数据变更")]),t._v("，这可能会导致脏读、不可重复读和幻读。")]),t._v(" "),v("li",[v("strong",[t._v("读已提交（READ-COMMITTED, RC）")]),t._v("："),v("strong",[t._v("允许读取并发事务已经提交的数据")]),t._v("，可以阻止脏读，但是不可重复读和幻读仍有可能发生。")]),t._v(" "),v("li",[v("strong",[t._v("可重复读（REPEATABLE-READ, RR）")]),t._v("："),v("strong",[t._v("对同一字段的多次读取结果是一致的")]),t._v("，除非数据被本身事务自己修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。")]),t._v(" "),v("li",[v("strong",[t._v("可串行化（SERIALIZABLE）")]),t._v("：最高的隔离级别，"),v("strong",[t._v("完全服从 ACID 的隔离级别")]),t._v("。事务依次逐个执行，这样事务之间就完全不可能产生干扰。该级别可以防止脏读、不可重复读以及幻读。")])]),t._v(" "),v("h3",{attrs:{id:"读已提交和可重复读是如何实现的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#读已提交和可重复读是如何实现的"}},[t._v("#")]),t._v(" 读已提交和可重复读是如何实现的")]),t._v(" "),v("div",{staticClass:"tag-group"},[v("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("快手")])],1),v("ul",[v("li",[t._v("读已提交隔离级别下，每个快照读都会生成并获取最新的 "),v("RouterLink",{attrs:{to:"/mysql/xz81ss/#read-view"}},[v("strong",[t._v("Read View")])]),t._v("。")],1),t._v(" "),v("li",[t._v("可重复读隔离级别下，只有在同一个事务的第一个快照读才会创建 Read View，之后的每次快照读都使用的同一个 Read View。")])]),t._v(" "),v("h3",{attrs:{id:"mysql-的锁有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql-的锁有哪些"}},[t._v("#")]),t._v(" MySQL 的锁有哪些")]),t._v(" "),v("div",{staticClass:"tag-group"},[v("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("滴滴")]),v("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("京东")]),v("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("腾讯")])],1),v("p",[t._v("根据加锁的范围，可以分为 "),v("strong",[t._v("全局锁、表级锁和行锁")]),t._v(" 三类。")]),t._v(" "),v("ul",[v("li",[t._v("表级锁有："),v("RouterLink",{attrs:{to:"/mysql/yh4rjk/#表锁"}},[v("strong",[t._v("表锁")])]),t._v("、"),v("RouterLink",{attrs:{to:"/mysql/yh4rjk/#元数据锁"}},[v("strong",[t._v("元数据锁")])]),t._v("、"),v("RouterLink",{attrs:{to:"/mysql/yh4rjk/#意向锁"}},[v("strong",[t._v("意向锁")])]),t._v("、"),v("RouterLink",{attrs:{to:"/mysql/yh4rjk/#auto-inc-锁"}},[v("strong",[t._v("AUTO-INC 锁")])]),t._v("。")],1),t._v(" "),v("li",[t._v("行级锁有："),v("RouterLink",{attrs:{to:"/mysql/yh4rjk/#记录锁"}},[v("strong",[t._v("记录锁")])]),t._v("、"),v("RouterLink",{attrs:{to:"/mysql/yh4rjk/#间隙锁"}},[v("strong",[t._v("间隙锁")])]),t._v("、"),v("RouterLink",{attrs:{to:"/mysql/yh4rjk/#临键锁"}},[v("strong",[t._v("临键锁")])]),t._v("。")],1)]),t._v(" "),v("h3",{attrs:{id:"bin-log、redo-log-和-undo-log-的功能"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#bin-log、redo-log-和-undo-log-的功能"}},[t._v("#")]),t._v(" bin log、redo log 和 undo log 的功能")]),t._v(" "),v("div",{staticClass:"tag-group"},[v("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("字节")])],1),v("p",[t._v("binlog 的功能：")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("主从复制")]),t._v(" ：在 Master 端开启 binlog ，然后将 binlog 发送到各个 Slave 端， Slave 端重放 binlog 来达到主从数据一致。")]),t._v(" "),v("li",[v("strong",[t._v("数据恢复")]),t._v(" ：通过使用 mysqlbinlog 工具来恢复数据。")])]),t._v(" "),v("p",[t._v("redo log 的功能：")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("实现事务的持久性，让 MySQL 有 crash-safe 的能力")]),t._v("，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；")]),t._v(" "),v("li",[v("strong",[t._v("将写操作从 “随机写” 变成了 “顺序写”")]),t._v("，提升 MySQL 写入磁盘的性能。")])]),t._v(" "),v("p",[t._v("undo log 的功能：")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("实现事务回滚，保障事务的原子性")]),t._v("。事务处理过程中，如果出现错误或用户执行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。")]),t._v(" "),v("li",[v("strong",[t._v("实现 MVCC（多版本并发控制）")]),t._v("。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 SELECT 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。")])]),t._v(" "),v("h3",{attrs:{id:"mysql-的主从复制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql-的主从复制"}},[t._v("#")]),t._v(" MySQL 的主从复制")]),t._v(" "),v("div",{staticClass:"tag-group"},[v("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("百度TPG")])],1),v("p",[t._v("在 MySQL 的主从复制中，主库会将变更写入 "),v("RouterLink",{attrs:{to:"/mysql/cp5qss/#_5-1-binlog"}},[v("strong",[t._v("binlog")])]),t._v("，从库通过连接到主库来获取并复制主库的 binlog。主从复制具体详细过程如下：")],1),t._v(" "),v("ul",[v("li",[t._v("主库在收到客户端提交事务的请求之后，会先写入 binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端 “操作成功” 的响应。")]),t._v(" "),v("li",[t._v("从库会创建一个专门的 I/O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 "),v("strong",[t._v("relay log 中继日志")]),t._v(" 里，再返回给主库 “复制成功” 的响应。")]),t._v(" "),v("li",[t._v("从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。")])])])}),[],!1,null,null,null);s.default=r.exports}}]);