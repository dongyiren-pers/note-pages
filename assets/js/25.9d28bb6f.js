(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{1079:function(t,s,a){"use strict";a.r(s);var v=a(14),i=Object(v.a)({},(function(){var t=this,s=t.$createElement,v=t._self._c||s;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"第5章-传输层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第5章-传输层"}},[t._v("#")]),t._v(" 第5章 传输层")]),t._v(" "),v("h2",{attrs:{id:"_5-1-传输层提供的服务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-传输层提供的服务"}},[t._v("#")]),t._v(" 5.1 传输层提供的服务")]),t._v(" "),v("h3",{attrs:{id:"传输层的功能"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#传输层的功能"}},[t._v("#")]),t._v(" 传输层的功能")]),t._v(" "),v("p",[t._v("传输层的功能如下：")]),t._v(" "),v("ul",[v("li",[t._v("传输层提供应用 "),v("strong",[t._v("进程之间的逻辑通信")]),t._v("（即端到端的通信）。与网络层的区别是，网络层提供的是主机之间的逻辑通信。")]),t._v(" "),v("li",[t._v("复用和分用。"),v("strong",[t._v("复用")]),t._v(" 是指发送方不同的应用进程都可使用同一个传输层协议传送数据；"),v("strong",[t._v("分用")]),t._v(" 是指接收方的传输层在剥去报文的首部后能够把这些数据正确交付到目的应用进程。")]),t._v(" "),v("li",[t._v("传输层还要对收到的报文进行 "),v("strong",[t._v("差错检测")]),t._v("（首部和数据部分）。 而网络层只检査 IP 数据报的首部， 不检验数据部分是否出错。")]),t._v(" "),v("li",[t._v("提供 "),v("strong",[t._v("两种不同的传输协议")]),t._v("， 即 "),v("strong",[t._v("面向连接的 TCP")]),t._v(" 和 "),v("strong",[t._v("无连接的 UDP")]),t._v("。 而网络层无法同时实现两种协议，即在网络层要么只提供面向连接的服务，如虚电路；要么只提供无连接服务，如数据报，而不可能在网络层同时存在这两种方式。")])]),t._v(" "),v("p",[t._v("当传输层采用面向连接的 TCP 时，尽管下面的网络是不可靠的（只提供尽最大努力的服务），但这种逻辑通信信道就相当于一条全双工的可靠信道。但当传输层采用无连接的 UDP 时，这种逻辑通信信道仍然是一条不可靠信道。")]),t._v(" "),v("h3",{attrs:{id:"传输层的寻址与端口"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#传输层的寻址与端口"}},[t._v("#")]),t._v(" 传输层的寻址与端口")]),t._v(" "),v("div",{staticClass:"anchor",attrs:{id:"端口的作用"}},[t._v("端口的作用")]),v("p",[t._v("端口能够让应用层的各种应用进程将其数据通过端口向下交付给传输层，以及让传输层知道应当将其报文段中的数据向上通过端口交付给应用层相应的进程。")]),t._v(" "),v("blockquote",[v("p",[t._v("在协议栈层间的抽象的协议端口是软件端口，它与路由器或交换机上的硬件端口是完全不同的概念。硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与传输实体进行层间交互的一种地址。传输层使用的是软件端口。")])]),t._v(" "),v("div",{staticClass:"anchor",attrs:{id:"端口号"}},[t._v("端口号")]),v("p",[t._v("应用进程通过端口号进行标识，端口号长度为 16bit，能够表示 65536（"),v("eq",[v("span",{staticClass:"katex"},[v("span",{staticClass:"katex-mathml"},[v("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[v("semantics",[v("mrow",[v("msup",[v("mn",[t._v("2")]),v("mn",[t._v("16")])],1)],1),v("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("2^{16}")])],1)],1)],1),v("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[v("span",{staticClass:"base"},[v("span",{staticClass:"strut",staticStyle:{height:"0.8141079999999999em","vertical-align":"0em"}}),v("span",{staticClass:"mord"},[v("span",{staticClass:"mord"},[t._v("2")]),v("span",{staticClass:"msupsub"},[v("span",{staticClass:"vlist-t"},[v("span",{staticClass:"vlist-r"},[v("span",{staticClass:"vlist",staticStyle:{height:"0.8141079999999999em"}},[v("span",{staticStyle:{top:"-3.063em","margin-right":"0.05em"}},[v("span",{staticClass:"pstrut",staticStyle:{height:"2.7em"}}),v("span",{staticClass:"sizing reset-size6 size3 mtight"},[v("span",{staticClass:"mord mtight"},[v("span",{staticClass:"mord mtight"},[t._v("1")]),v("span",{staticClass:"mord mtight"},[t._v("6")])])])])])])])])])])])])]),t._v("）个不同的端口号。")],1),t._v(" "),v("p",[t._v("端口号只具有本地意义，即端口号只标识本计算机应用层中的各进程，在因特网中不同计算机的相同端口号是没有联系的。")]),t._v(" "),v("div",{staticClass:"anchor",attrs:{id:"套接字"}},[t._v("套接字")]),v("p",[t._v("在网络中通过 IP 地址来标识和区别不同的主机，通过端口号来标识和区分一台主机中的不同应用进程， "),v("strong",[t._v("端口号拼接到 IP 地址即构成套接字 Socket")]),t._v("。")]),t._v(" "),v("h2",{attrs:{id:"_5-2-udp-协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-udp-协议"}},[t._v("#")]),t._v(" 5.2 UDP 协议")]),t._v(" "),v("h3",{attrs:{id:"udp-数据报"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#udp-数据报"}},[t._v("#")]),t._v(" UDP 数据报")]),t._v(" "),v("p",[t._v("UDP 仅在 IP 的数据报服务之上增加了两个最基本的服务："),v("strong",[t._v("复用和分用")]),t._v(" 以及 "),v("strong",[t._v("差错检测")]),t._v("。")]),t._v(" "),v("p",[t._v("UDP 的主要特点：")]),t._v(" "),v("ul",[v("li",[t._v("UDP 是 "),v("strong",[t._v("无连接")]),t._v(" 的，减少开销和发送数据之前的时延。")]),t._v(" "),v("li",[t._v("UDP 使用最大努力交付，即 "),v("strong",[t._v("不保证可靠交付")]),t._v("。")]),t._v(" "),v("li",[t._v("UDP 是 "),v("strong",[t._v("面向报文")]),t._v(" 的，适合一次性传输少量数据的网络应用。")]),t._v(" "),v("li",[t._v("UDP "),v("strong",[t._v("无拥塞控制")]),t._v("，适合很多实时应用。")]),t._v(" "),v("li",[t._v("UDP 的 "),v("strong",[t._v("首部开销小")]),t._v("（8B）。")])]),t._v(" "),v("div",{staticClass:"anchor",attrs:{id:"udp-的首部格式"}},[t._v("UDP 的首部格式")]),v("p",[t._v("UDP 数据报包含两部分： UDP 首部和用户数据。 UDP 首部有 8B，由 4 个字段组成，每个字段的长度都是 2B。")]),t._v(" "),v("p",[v("img",{attrs:{src:a(806),alt:"image-20221116224947989"}})]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("源端口")]),t._v("。源端口号。在需要对方回信时选用，不需要时可用全 0。")]),t._v(" "),v("li",[v("strong",[t._v("目的端口")]),t._v("。目的端口号。这在终点交付报文时必须使用到。")]),t._v(" "),v("li",[v("strong",[t._v("长度")]),t._v("。UDP 数据报的长度（包括首部和数据），其最小值是 8（仅有首部）。")]),t._v(" "),v("li",[v("strong",[t._v("校验和")]),t._v("。检测 UDP 数据报在传输中是否有错。有错就丢弃。该字段是可选的，当源主机不想计算校验和时，则直接令该字段为全 0。")])]),t._v(" "),v("h3",{attrs:{id:"udp-校验"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#udp-校验"}},[t._v("#")]),t._v(" UDP 校验")]),t._v(" "),v("p",[t._v("发送方首先把全零放入校验和字段并添加伪首部，然后把 UDP 数据报视为许多 16 位的字串接起来。若 UDP 数据报的数据部分不是偶数个字节，则要在数据部分末尾填入一个全零字节（但此字节不发送）。然后按二进制反码计算出这些 16 位字的和，将此和的二进制反码写入校验和字段，并发送。")]),t._v(" "),v("p",[t._v("接收方把收到的 UDP 数据报加上伪首部（如果不为偶数个字节，那么还需要补上全零字节）后，按二进制反码求这些 16 位字的和。当无差错时其结果应为全 1，否则就表明有差错出现，接收方就应该丢弃这个 UDP 数据报。")]),t._v(" "),v("p",[v("img",{attrs:{src:a(807),alt:"image-20221116225700477"}})]),t._v(" "),v("h2",{attrs:{id:"_5-3-tcp-协议"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-tcp-协议"}},[t._v("#")]),t._v(" 5.3 TCP 协议")]),t._v(" "),v("h3",{attrs:{id:"tcp-协议的特点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp-协议的特点"}},[t._v("#")]),t._v(" TCP 协议的特点")]),t._v(" "),v("p",[t._v("TCP 的主要特点：")]),t._v(" "),v("ul",[v("li",[t._v("TCP 是 "),v("strong",[t._v("面向连接")]),t._v(" 的传输层协议， TCP 连接是一条 "),v("strong",[t._v("逻辑连接")]),t._v("。")]),t._v(" "),v("li",[t._v("每条 TCP 连接只能有两个端点，每条 TCP 连接只能是 "),v("strong",[t._v("端到端的")]),t._v("（进程对进程）。")]),t._v(" "),v("li",[t._v("TCP 提供 "),v("strong",[t._v("可靠交付的服务")]),t._v("，保证传送的数据无差错、不丢失、不重复且有序。")]),t._v(" "),v("li",[t._v("TCP 提供 "),v("strong",[t._v("全双工通信")]),t._v("，允许通信双方的应用进程在任何时候都能发送数据，为此 TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。")]),t._v(" "),v("li",[t._v("TCP 是 "),v("strong",[t._v("面向字节流")]),t._v(" 的，虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅视为一连串的无结构的字节流。")])]),t._v(" "),v("h3",{attrs:{id:"tcp-报文段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp-报文段"}},[t._v("#")]),t._v(" TCP 报文段")]),t._v(" "),v("p",[v("img",{attrs:{src:a(808),alt:"image-20221116230415167"}})]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("源端口和目的端口")]),t._v("。各占2B。端口是传输层与应用层的服务接口，传输层的复用和分用功能都要通过端口实现。")]),t._v(" "),v("li",[v("strong",[t._v("序号")]),t._v("。占 4B，范围为 "),v("eq",[v("span",{staticClass:"katex"},[v("span",{staticClass:"katex-mathml"},[v("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[v("semantics",[v("mrow",[v("mn",[t._v("0")]),v("mo",[t._v("∼")]),v("msup",[v("mn",[t._v("2")]),v("mn",[t._v("32")])],1),v("mo",[t._v("−")]),v("mn",[t._v("1")])],1),v("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("0\\sim2^{32}-1")])],1)],1)],1),v("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[v("span",{staticClass:"base"},[v("span",{staticClass:"strut",staticStyle:{height:"0.64444em","vertical-align":"0em"}}),v("span",{staticClass:"mord"},[t._v("0")]),v("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2777777777777778em"}}),v("span",{staticClass:"mrel"},[t._v("∼")]),v("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2777777777777778em"}})]),v("span",{staticClass:"base"},[v("span",{staticClass:"strut",staticStyle:{height:"0.897438em","vertical-align":"-0.08333em"}}),v("span",{staticClass:"mord"},[v("span",{staticClass:"mord"},[t._v("2")]),v("span",{staticClass:"msupsub"},[v("span",{staticClass:"vlist-t"},[v("span",{staticClass:"vlist-r"},[v("span",{staticClass:"vlist",staticStyle:{height:"0.8141079999999999em"}},[v("span",{staticStyle:{top:"-3.063em","margin-right":"0.05em"}},[v("span",{staticClass:"pstrut",staticStyle:{height:"2.7em"}}),v("span",{staticClass:"sizing reset-size6 size3 mtight"},[v("span",{staticClass:"mord mtight"},[v("span",{staticClass:"mord mtight"},[t._v("3")]),v("span",{staticClass:"mord mtight"},[t._v("2")])])])])])])])])]),v("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}}),v("span",{staticClass:"mbin"},[t._v("−")]),v("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}})]),v("span",{staticClass:"base"},[v("span",{staticClass:"strut",staticStyle:{height:"0.64444em","vertical-align":"0em"}}),v("span",{staticClass:"mord"},[t._v("1")])])])])]),t._v(" ，共 "),v("eq",[v("span",{staticClass:"katex"},[v("span",{staticClass:"katex-mathml"},[v("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[v("semantics",[v("mrow",[v("msup",[v("mn",[t._v("2")]),v("mn",[t._v("32")])],1)],1),v("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("2^{32}")])],1)],1)],1),v("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[v("span",{staticClass:"base"},[v("span",{staticClass:"strut",staticStyle:{height:"0.8141079999999999em","vertical-align":"0em"}}),v("span",{staticClass:"mord"},[v("span",{staticClass:"mord"},[t._v("2")]),v("span",{staticClass:"msupsub"},[v("span",{staticClass:"vlist-t"},[v("span",{staticClass:"vlist-r"},[v("span",{staticClass:"vlist",staticStyle:{height:"0.8141079999999999em"}},[v("span",{staticStyle:{top:"-3.063em","margin-right":"0.05em"}},[v("span",{staticClass:"pstrut",staticStyle:{height:"2.7em"}}),v("span",{staticClass:"sizing reset-size6 size3 mtight"},[v("span",{staticClass:"mord mtight"},[v("span",{staticClass:"mord mtight"},[t._v("3")]),v("span",{staticClass:"mord mtight"},[t._v("2")])])])])])])])])])])])])]),t._v(" 个序号。 TCP 是面向字节流的（即 TCP 传送时是逐个字节传送的），所以 TCP 连接传送的字节流中的每个字节都按顺序编号。序号字段的值指的是本报文段所发送的数据的 "),v("strong",[t._v("第一个字节的序号")]),t._v("。")],1),t._v(" "),v("li",[v("strong",[t._v("确认号")]),t._v("。占 4B，是期望收到对方下一个报文段的第一个数据字节的序号。若确认号为 N 则表明到序号 N - 1 为止的所有数据都己正确收到。")]),t._v(" "),v("li",[v("strong",[t._v("数据偏移（即首部长度）")]),t._v("。占 4 位，这里不是 IP 数据报分片的那个数据偏移，而是表示首部长度（首部中还有长度不确定的选项字段），它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移” 的单位 是 32 位（以 4B 为计算单位）。由于 4 位二进制数能表示的最大值为 15，因此 TCP 首部的最大长度为 60 B。")]),t._v(" "),v("li",[v("strong",[t._v("保留")]),t._v("。占 6 位，保留为今后使用，但目前应置为 0。")]),t._v(" "),v("li",[v("strong",[t._v("紧急位 URG")]),t._v("。当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送（相当于高优先级的数据）。但 URG 需要和首部中紧急指针字段配合使用，即数据从第一个字节到紧急指针所指字节就是紧急数据。")]),t._v(" "),v("li",[v("strong",[t._v("确认位 ACK")]),t._v("。仅当 ACK = 1 时确认号字段才有效。当 ACK = 0 时，确认号无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。")]),t._v(" "),v("li",[v("strong",[t._v("推送位 PSH（Push）")]),t._v("。接收方 TCP 收到 PSH = 1 的报文段，就尽快地交付给接收应用进程，而不再等到整个缓存都填满了后再向上交付。")]),t._v(" "),v("li",[v("strong",[t._v("复位位 RST（Reset）")]),t._v("。当 RST = 1 时，表明 TCP 连接中出现严重差错（如主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接。")]),t._v(" "),v("li",[v("strong",[t._v("同步位 SYN")]),t._v("。 当 SYN = 1 时表示这是一个 "),v("strong",[t._v("连接请求")]),t._v(" 或 "),v("strong",[t._v("连接接受")]),t._v(" 报文。当 SYN = 1, ACK = 0 时，表明这是一个连接请求报文，对方若同意建立连接，则应在响应报文中使用 SYN = 1, ACK = 1。")]),t._v(" "),v("li",[v("strong",[t._v("终止位 FIN（Finish）")]),t._v("。用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已发送完毕，并要求释放传输连接。")]),t._v(" "),v("li",[v("strong",[t._v("窗口")]),t._v("。占 2B，范围为 "),v("eq",[v("span",{staticClass:"katex"},[v("span",{staticClass:"katex-mathml"},[v("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[v("semantics",[v("mrow",[v("mn",[t._v("0")]),v("mo",[t._v("∼")]),v("msup",[v("mn",[t._v("2")]),v("mn",[t._v("16")])],1),v("mo",[t._v("−")]),v("mn",[t._v("1")])],1),v("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("0\\sim 2^{16}-1")])],1)],1)],1),v("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[v("span",{staticClass:"base"},[v("span",{staticClass:"strut",staticStyle:{height:"0.64444em","vertical-align":"0em"}}),v("span",{staticClass:"mord"},[t._v("0")]),v("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2777777777777778em"}}),v("span",{staticClass:"mrel"},[t._v("∼")]),v("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2777777777777778em"}})]),v("span",{staticClass:"base"},[v("span",{staticClass:"strut",staticStyle:{height:"0.897438em","vertical-align":"-0.08333em"}}),v("span",{staticClass:"mord"},[v("span",{staticClass:"mord"},[t._v("2")]),v("span",{staticClass:"msupsub"},[v("span",{staticClass:"vlist-t"},[v("span",{staticClass:"vlist-r"},[v("span",{staticClass:"vlist",staticStyle:{height:"0.8141079999999999em"}},[v("span",{staticStyle:{top:"-3.063em","margin-right":"0.05em"}},[v("span",{staticClass:"pstrut",staticStyle:{height:"2.7em"}}),v("span",{staticClass:"sizing reset-size6 size3 mtight"},[v("span",{staticClass:"mord mtight"},[v("span",{staticClass:"mord mtight"},[t._v("1")]),v("span",{staticClass:"mord mtight"},[t._v("6")])])])])])])])])]),v("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}}),v("span",{staticClass:"mbin"},[t._v("−")]),v("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}})]),v("span",{staticClass:"base"},[v("span",{staticClass:"strut",staticStyle:{height:"0.64444em","vertical-align":"0em"}}),v("span",{staticClass:"mord"},[t._v("1")])])])])]),t._v("。它指出现在允许对方发送的数据量，接收方的数据缓存空间是有限的，因此用窗口值作为接收方让发送方设置其发送窗口的依据。")],1),t._v(" "),v("li",[v("strong",[t._v("校验和")]),t._v("。占 2B。校验和字段检验的范围包括首部和数据两部分。在计算校验和时，和 UDP —样，要在 TCP 报文段的前面加上12B 的伪首部（只需将 UDP 伪首部的第 4 个字段，即协议字段的17 改成 6，其他的和 UDP 一样）。")]),t._v(" "),v("li",[v("strong",[t._v("紧急指针")]),t._v("。占 2B。紧急指针仅在 URG = 1 时才有意义，它指出在本报文段中紧急数据共有多少字节（紧急数据在报文段数据的最前面）。")]),t._v(" "),v("li",[v("strong",[t._v("选项")]),t._v("。长度可变。 TCP 最初只规定了一种选项，即最大报文段长度（Maximum Segment Size, MSS）。 MSS 是 TCP 报文段中的数据字段的最大长度（注意仅仅是数据字段）。")]),t._v(" "),v("li",[v("strong",[t._v("填充")]),t._v("。这是为了使整个首部长度是 4B 的整数倍。")])]),t._v(" "),v("h3",{attrs:{id:"tcp-连接管理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp-连接管理"}},[t._v("#")]),t._v(" TCP 连接管理")]),t._v(" "),v("p",[t._v("TCP 连接的建立采用 "),v("strong",[t._v("客户/服务器模式")]),t._v("。主动发起连接建立的应用进程称为客户（Client），而被动等待连接建立的应用进程称为服务器（Server）。")]),t._v(" "),v("div",{staticClass:"anchor",attrs:{id:"tcp-连接的建立"}},[t._v("TCP 连接的建立")]),v("p",[t._v("连接的建立经历以下 3 个步骤，通常称为 "),v("strong",[t._v("三次握手")]),t._v("。")]),t._v(" "),v("p",[v("img",{attrs:{src:a(809),alt:"image-20221116233855863"}})]),t._v(" "),v("p",[t._v("连接建立前，服务器进程处于 LISTEN（收听）状态，等待客户的连接请求。")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("第一步")]),t._v("：客户机的 TCP 首先向服务器的 TCP 发送连接请求报文段。这个特殊报文段的首部中的 "),v("strong",[t._v("同步位 SYN 置 1")]),t._v("，同时选择一个 "),v("strong",[t._v("初始序号 seq = x")]),t._v("。 TCP 规定， SYN 报文段不能携带数据，但要消耗掉一个序号。这时，TCP 客户进程进入 SYN-SENT（"),v("strong",[v("u",[t._v("同步已发送")])]),t._v("）状态。")]),t._v(" "),v("li",[v("strong",[t._v("第二步")]),t._v("：服务器的 TCP 收到连接请求报文段后，如同意建立连接，则向客户机发回确认，并为该 TCP 连接分配缓存和变量。在确认报文段中，"),v("strong",[t._v("把 SYN 位和 ACK 位都置 1，确认号是 ack = x + 1")]),t._v("。同时为自己选择一个 "),v("strong",[t._v("初始序号 seq = y")]),t._v("。注意，确认报文段不能携带数据，但也要消耗掉一个序号。这时， TCP 服务器进程进入 SYN-RCVD（"),v("strong",[v("u",[t._v("同步收到")])]),t._v("）状态。")]),t._v(" "),v("li",[v("strong",[t._v("第三步")]),t._v("：当客户机收到确认报文段后，还要向服务器给出确认，并为该 TCP 连接分配缓存和变量。确认报文段的 "),v("strong",[t._v("ACK 位置 1，确认号 ack = y + 1，序号 seq =x + 1")]),t._v("。该报文段可以携带数据，若不携带数据则不消耗序号。这时，TCP 客户进程进入 ESTABLISHED（"),v("strong",[v("u",[t._v("已建立连接")])]),t._v("）状态。")])]),t._v(" "),v("p",[t._v("TCP 提供的是全双工通信，因此通信双方的应用进程在任何时候都能发送数据。")]),t._v(" "),v("p",[t._v("服务器端的资源是在完成第二次握手时分配的，而客户端的资源是在完成第三次握手时分配的，这就使得服务器易于受到 "),v("strong",[t._v("SYN 洪泛攻击")]),t._v("。")]),t._v(" "),v("div",{staticClass:"anchor",attrs:{id:"tcp-连接的释放"}},[t._v("TCP 连接的释放")]),v("p",[t._v("参与 TCP 连接的两个进程中的任何一个都能终止该连接。TCP 连接释放的过程通常称为 "),v("strong",[t._v("四次挥手")]),t._v("。")]),t._v(" "),v("p",[v("img",{attrs:{src:a(810),alt:"image-20221116234740103"}})]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("第一步")]),t._v("：客户机发送一个 "),v("strong",[t._v("FIN")]),t._v("（结束）报文段给服务器。这个报文段表明客户机已经发送完数据，请求关闭连接，并指定一个 "),v("strong",[t._v("序号 seq = u")]),t._v("。此时，客户机进入 FIN-WAIT-1（"),v("strong",[t._v("等待对方 ACK")]),t._v("）状态。")]),t._v(" "),v("li",[v("strong",[t._v("第二步")]),t._v("：服务器收到 FIN 报文段后，发送一个确认 "),v("strong",[t._v("ACK")]),t._v(" 报文段作为回应，"),v("strong",[t._v("确认号 ack = u + 1")]),t._v("，同时指定一个 "),v("strong",[t._v("序号 seq = v")]),t._v("。这个报文段表明服务器已经收到关闭请求，并进入 CLOSE-WAIT（"),v("strong",[t._v("等待自己关闭")]),t._v("）状态。")]),t._v(" "),v("li",[v("strong",[t._v("第三步")]),t._v("：服务器发送一个 "),v("strong",[t._v("FIN-ACK")]),t._v(" 报文段给客户机，请求关闭连接，同时指定一个 "),v("strong",[t._v("序号 seq = w")]),t._v("。此时，服务器进入 LAST-ACK（"),v("strong",[t._v("等待最后 ACK")]),t._v("）状态。")]),t._v(" "),v("li",[v("strong",[t._v("第四步")]),t._v("：客户机收到 FIN 报文段后，发送一个确认 "),v("strong",[t._v("ACK")]),t._v(" 报文段作为回应，"),v("strong",[t._v("确认号 ack = w + 1")]),t._v("。此时，客户机进入 TIME-WAIT（"),v("strong",[t._v("等待一段时间")]),t._v("）状态。在这个状态下，客户机等待 2MSL，确保服务器收到了确认，防止可能的重传。完成等待后，客户机离开 TIME-WAIT 状态，完成四次挥手过程。")])]),t._v(" "),v("h3",{attrs:{id:"tcp-可靠传输"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp-可靠传输"}},[t._v("#")]),t._v(" TCP 可靠传输")]),t._v(" "),v("p",[t._v("TCP 提供的可靠数据传输服务保证接收方进程从缓存区读出的字节流与发送方发出的字节流完全一样。 TCP 使用了 "),v("strong",[t._v("校验、序号、确认和重传")]),t._v(" 等机制来达到这一目的。")]),t._v(" "),v("div",{staticClass:"anchor",attrs:{id:"校验"}},[t._v("校验")]),v("p",[t._v("TCP 的校验机制与 UDP 校验一样，这里不再赘述。")]),t._v(" "),v("div",{staticClass:"anchor",attrs:{id:"序号"}},[t._v("序号")]),v("p",[t._v("TCP 首部的序号字段用来保证数据能有序提交给应用层，TCP 把数据视为一个无结构但有序的字节流，序号建立在传送的字节流之上，而不建立在报文段之上。")]),t._v(" "),v("div",{staticClass:"anchor",attrs:{id:"确认"}},[t._v("确认")]),v("p",[t._v("TCP 首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号。发送方缓存区会继续存储那些已发送但未收到确认的报文段，以便在需要时重传。")]),t._v(" "),v("div",{staticClass:"anchor",attrs:{id:"重传"}},[t._v("重传")]),v("p",[t._v("有两种事件会导致 TCP 对报文段进行重传： 超时和冗余 ACK。")]),t._v(" "),v("p",[v("strong",[t._v("超时")]),t._v("：TCP 每发送一个报文段，就对这个报文段设置一次计时器。计时器设置的重传时间到期但还未收到确认时，就要重传这一报文段。")]),t._v(" "),v("p",[v("strong",[t._v("冗余 ACK（冗余确认）")]),t._v("： 再次确认某个报文段的 ACK，而发送方先前已经收到过该报文段的确认。TCP 规定每当比期望序号大的失序报文段到达时就发送一个冗余 ACK，指明下一个期待字节的序号。")]),t._v(" "),v("h3",{attrs:{id:"tcp-流量控制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp-流量控制"}},[t._v("#")]),t._v(" TCP 流量控制")]),t._v(" "),v("p",[t._v("TCP 提供一种基于滑动窗口协议的流量控制机制。")]),t._v(" "),v("p",[t._v("在通信过程中，接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小，这称为 "),v("strong",[t._v("接收窗口 rwnd")]),t._v("。即调整 TCP 报文段首部中的 “窗口” 字段值，来限制发送方向网络注入报文的速率。")]),t._v(" "),v("p",[t._v("同时，发送方根据其对当前网络拥塞程度的估计而确定的窗口值，这称为 "),v("strong",[t._v("拥塞窗口 cwnd")]),t._v("，其大小与网络的带宽和时延密切相关。")]),t._v(" "),v("p",[t._v("例如，A 向 B 发送数据，连接建立时，B 告诉 A：“我的 rwnd = 400（字节）”，设每一个报文段 100B，报文段序号初始值为 1。")]),t._v(" "),v("p",[v("img",{attrs:{src:a(811),alt:"image-20221120230453773"}})]),t._v(" "),v("blockquote",[v("p",[v("strong",[t._v("传输层和数据链路层的流量控制的区别是")]),t._v("：传输层定义端到端用户之间的流量控制，数据链路层定义两个中间的相邻结点的流量控制。另外，数据链路层的滑动窗口协议的窗口大小不能动态变化，传输层的则可以动态变化。")])]),t._v(" "),v("h3",{attrs:{id:"tcp-拥塞控制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp-拥塞控制"}},[t._v("#")]),t._v(" TCP 拥塞控制")]),t._v(" "),v("p",[t._v("拥塞控制是指防止过多的数据注入网络，保证网络中的路由器或链路不致过载。出现拥塞时，端点并不了解拥塞发生的细节，对通信连接的端点来说，拥塞往往表现为通信时延的增加。")]),t._v(" "),v("p",[v("strong",[t._v("拥塞控制与流量控制的区别")]),t._v("：拥塞控制是让网络能够承受现有的网络负荷，是一个全局性的过程，涉及所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是指点对点的通信量的控制，是个端到端的问题（接收端控制发送端），它所要做的是抑制发送端发送数据的速率，以便使接收端来得及接收。当然，拥塞控制和流量控制也有相似的地方，即它们都通过控制发送方发送数据的速率来达到控制效果。")]),t._v(" "),v("p",[t._v("因特网建议标准定义了进行拥塞控制的 4 种算法：慢开始、拥塞避免、快重传和快恢复。")]),t._v(" "),v("blockquote",[v("p",[t._v("发送方在确定发送报文段的速率时，既要根据接收方的接收能力，又要从全局考虑不要使网络发生拥塞。因此， TCP 协议要求发送方维护以下两个窗口：")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("接收窗口 rwnd")]),t._v("：接收方根据目前接收缓存大小所许诺的最新窗口值，反映接收方的容量。由接收方根据其放在 TCP 报文的首部的窗口字段通知发送方。")]),t._v(" "),v("li",[v("strong",[t._v("拥塞窗口 cwnd")]),t._v("：发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络的当前容量。只要网络未出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入网络的分组数。")])]),t._v(" "),v("p",[t._v("发送窗口的上限值应取接收窗口 rwnd 和拥塞窗口 cwnd 中较小的一个，即")]),t._v(" "),v("section",[v("eqn",[v("span",{staticClass:"katex-display"},[v("span",{staticClass:"katex"},[v("span",{staticClass:"katex-mathml"},[v("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[v("semantics",[v("mrow",[v("mtext",[t._v("发送窗口的上限值")]),v("mo",[t._v("=")]),v("mi",[t._v("min")]),v("mo",[t._v("⁡")]),v("mo",{attrs:{stretchy:"false"}},[t._v("(")]),v("mi",[t._v("r")]),v("mi",[t._v("w")]),v("mi",[t._v("n")]),v("mi",[t._v("d")]),v("mo",{attrs:{separator:"true"}},[t._v(",")]),v("mi",[t._v("c")]),v("mi",[t._v("w")]),v("mi",[t._v("n")]),v("mi",[t._v("d")]),v("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),v("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("\n\\text{发送窗口的上限值} = \\min(rwnd,cwnd)\n")])],1)],1)],1),v("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[v("span",{staticClass:"base"},[v("span",{staticClass:"strut",staticStyle:{height:"0.68333em","vertical-align":"0em"}}),v("span",{staticClass:"mord text"},[v("span",{staticClass:"mord cjk_fallback"},[t._v("发送窗口的上限值")])]),v("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2777777777777778em"}}),v("span",{staticClass:"mrel"},[t._v("=")]),v("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2777777777777778em"}})]),v("span",{staticClass:"base"},[v("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),v("span",{staticClass:"mop"},[t._v("min")]),v("span",{staticClass:"mopen"},[t._v("(")]),v("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("r")]),v("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02691em"}},[t._v("w")]),v("span",{staticClass:"mord mathdefault"},[t._v("n")]),v("span",{staticClass:"mord mathdefault"},[t._v("d")]),v("span",{staticClass:"mpunct"},[t._v(",")]),v("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.16666666666666666em"}}),v("span",{staticClass:"mord mathdefault"},[t._v("c")]),v("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02691em"}},[t._v("w")]),v("span",{staticClass:"mord mathdefault"},[t._v("n")]),v("span",{staticClass:"mord mathdefault"},[t._v("d")]),v("span",{staticClass:"mclose"},[t._v(")")])])])])])])],1)]),t._v(" "),v("div",{staticClass:"anchor",attrs:{id:"慢开始和拥塞避免"}},[t._v("慢开始和拥塞避免")]),v("p",[v("img",{attrs:{src:a(812),alt:"image-20221120233037175"}})]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("慢开始")]),t._v("：开始发送 TCP 报文段时，令拥塞窗口 cwnd = 1，即一个最大报文段长度 MSS。每收到一个对新报文段的确认后，将 cwnd 加倍（指数级增长）。")]),t._v(" "),v("li",[v("strong",[t._v("拥塞避免")]),t._v("：每经过一个往返时延 RTT 就把发送方的拥塞窗口 cwnd 加 1（线性增长），使拥塞窗口 cwnd 按线性规律缓慢增长。")])]),t._v(" "),v("p",[t._v("不论是在慢开始阶段还是在拥塞避免阶段， 只要出现超时（即很可能出现了网络拥塞），就把 "),v("strong",[t._v("慢开始门限值 ssthresh")]),t._v(" 设置为当前拥塞窗口的一半（并执行慢开始算法）。")]),t._v(" "),v("div",{staticClass:"anchor",attrs:{id:"快重传和快恢复"}},[t._v("快重传和快恢复")]),v("p",[t._v("快重传和快恢复算法是对慢开始和拥塞避免算法的改进。")]),t._v(" "),v("p",[v("img",{attrs:{src:a(454),alt:"image-20221120234254876"}})]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("快重传")]),t._v("：当发送方连续收到三个重复的 ACK 报文时，直接重传对方尚未收到的报文段，不必等待那个报文段设置的重传计时器超时。")]),t._v(" "),v("li",[v("strong",[t._v("快恢复")]),t._v("：当发送方连续收到三个冗余 ACK (即重复确认） 时， 执行 “乘法减小” 算法， 把慢开始门限 ssthresh 设置为此时发送方 cwnd 的一半。")])]),t._v(" "),v("p",[t._v("在 TCP 连接建立和网络出现超时时，采用慢开始和拥塞避免算法；当发送方接收到冗余 ACK 时，采用快重传和快恢复算法。")])])}),[],!1,null,null,null);s.default=i.exports},454:function(t,s,a){t.exports=a.p+"assets/img/image-20221120234254876.e1173893.png"},806:function(t,s,a){t.exports=a.p+"assets/img/image-20221116224947989.21f1678b.png"},807:function(t,s,a){t.exports=a.p+"assets/img/image-20221116225700477.00f6823b.png"},808:function(t,s,a){t.exports=a.p+"assets/img/image-20221116230415167.6e850608.png"},809:function(t,s,a){t.exports=a.p+"assets/img/image-20221116233855863.4558884e.png"},810:function(t,s,a){t.exports=a.p+"assets/img/image-20221116234740103.a5b45bc6.png"},811:function(t,s,a){t.exports=a.p+"assets/img/image-20221120230453773.c11e2392.png"},812:function(t,s,a){t.exports=a.p+"assets/img/image-20221120233037175.33e97774.png"}}]);