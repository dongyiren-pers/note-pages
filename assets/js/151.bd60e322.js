(window.webpackJsonp=window.webpackJsonp||[]).push([[151],{1072:function(s,t,a){"use strict";a.r(t);var _=a(14),v=Object(_.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"第4章-锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第4章-锁"}},[s._v("#")]),s._v(" 第4章 锁")]),s._v(" "),a("h2",{attrs:{id:"_4-1-mysql-的锁有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-mysql-的锁有哪些"}},[s._v("#")]),s._v(" 4.1  MySQL 的锁有哪些")]),s._v(" "),a("p",[s._v("在 MySQL 里，根据加锁的范围，可以分为 "),a("strong",[s._v("全局锁、表级锁和行锁")]),s._v(" 三类。")]),s._v(" "),a("h3",{attrs:{id:"全局锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#全局锁"}},[s._v("#")]),s._v(" 全局锁")]),s._v(" "),a("div",{staticClass:"subtitle"},[a("p",[s._v("使用全局锁")])]),a("p",[s._v("要使用全局锁，则要执行这条命令：")]),s._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[s._v("FLUSH "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("TABLES")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WITH")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("READ")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("LOCK")]),s._v("\n")])])]),a("p",[s._v("执行后，"),a("strong",[s._v("整个数据库就处于只读状态了")]),s._v("，这时其他线程执行以下操作，都会被阻塞：")]),s._v(" "),a("ul",[a("li",[s._v("对数据的增删改操作，比如 INSERT、DELETE、UPDATE 等语句；")]),s._v(" "),a("li",[s._v("对表结构的更改操作，比如 ALTER TABLE、DROP TABLE 等语句。")])]),s._v(" "),a("p",[s._v("如果要释放全局锁，则要执行这条命令：")]),s._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("UNLOCK")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("TABLES")]),s._v("\n")])])]),a("div",{staticClass:"subtitle"},[a("p",[s._v("全局锁应用场景")])]),a("p",[s._v("全局锁主要应用于做 "),a("strong",[s._v("全库逻辑备份")]),s._v("，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。")]),s._v(" "),a("div",{staticClass:"subtitle"},[a("p",[s._v("全局锁的缺点")])]),a("p",[s._v("加上全局锁，意味着整个数据库都是只读状态。")]),s._v(" "),a("p",[s._v("如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。")]),s._v(" "),a("p",[a("strong",[s._v("替代方案")]),s._v("：如果数据库的引擎支持的事务支持 "),a("strong",[s._v("可重复读的隔离级别")]),s._v("，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。")]),s._v(" "),a("p",[s._v("备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 "),a("code",[s._v("–single-transaction")]),s._v(" 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持可重复读隔离级别的事务的存储引擎。InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。")]),s._v(" "),a("h3",{attrs:{id:"表级锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#表级锁"}},[s._v("#")]),s._v(" 表级锁")]),s._v(" "),a("p",[s._v("MySQL 里面表级别的锁有这几种：")]),s._v(" "),a("ul",[a("li",[s._v("表锁")]),s._v(" "),a("li",[s._v("元数据锁（MDL）")]),s._v(" "),a("li",[s._v("意向锁")]),s._v(" "),a("li",[s._v("AUTO-INC 锁")])]),s._v(" "),a("h4",{attrs:{id:"表锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#表锁"}},[s._v("#")]),s._v(" 表锁")]),s._v(" "),a("p",[s._v("如果想对学生表（t_student）加表锁，可以使用下面的命令：")]),s._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 表级别的共享锁，即读锁；")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("LOCK")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("TABLES")]),s._v(" t_student "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("READ")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 表级别的独占锁，即写锁；")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("LOCK")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("TABLES")]),s._v(" t_student "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WRITE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),a("p",[s._v("需要注意的是，表锁除了会限制别的线程的读写外，同样会限制本线程接下来的读写操作。")]),s._v(" "),a("p",[s._v("要释放表锁，可以使用下面这条命令，会释放当前会话的所有表锁：")]),s._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("UNLOCK")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("TABLES")]),s._v("\n")])])]),a("p",[s._v("尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能，"),a("strong",[s._v("InnoDB 强大的地方在于实现了颗粒度更细的行级锁")]),s._v("。")]),s._v(" "),a("h4",{attrs:{id:"元数据锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#元数据锁"}},[s._v("#")]),s._v(" 元数据锁")]),s._v(" "),a("p",[s._v("我们不需要显式地使用元数据锁（MDL），因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：")]),s._v(" "),a("ul",[a("li",[s._v("对一张表数据进行 CRUD 操作时，加的是 "),a("strong",[s._v("MDL 读锁")]),s._v("；")]),s._v(" "),a("li",[s._v("对一张表做结构变更操作的时候，加的是 "),a("strong",[s._v("MDL 写锁")]),s._v("；")])]),s._v(" "),a("p",[s._v("MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。")]),s._v(" "),a("p",[s._v("当有线程在执行 SELECT 语句（加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（申请 MDL 写锁），那么将会被阻塞，直到执行完 SELECT 语句（释放 MDL 读锁）。")]),s._v(" "),a("p",[s._v("当有线程对表结构进行变更（加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（释放 MDL 写锁）。")]),s._v(" "),a("h4",{attrs:{id:"意向锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#意向锁"}},[s._v("#")]),s._v(" 意向锁")]),s._v(" "),a("p",[s._v("意向锁：")]),s._v(" "),a("ul",[a("li",[s._v("在使用 InnoDB 引擎的表里对某些记录加上 "),a("strong",[s._v("共享锁")]),s._v(" 之前，需要先在表级别加上一个 "),a("strong",[s._v("意向共享锁")]),s._v("；")]),s._v(" "),a("li",[s._v("在使用 InnoDB 引擎的表里对某些纪录加上 "),a("strong",[s._v("独占锁")]),s._v(" 之前，需要先在表级别加上一个 "),a("strong",[s._v("意向独占锁")]),s._v("。")])]),s._v(" "),a("p",[s._v("普通的 SELECT 是不会加行级锁的，普通的 SELECT 语句是利用 MVCC 实现一致性读，是无锁的。")]),s._v(" "),a("p",[s._v("SELECT 可以对记录加共享锁和独占锁，具体方式如下：")]),s._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 先在表上加上意向共享锁，然后对读取的记录加共享锁")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("LOCK")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("IN")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SHARE")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("MODE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 先在表上加上意向独占锁，然后对读取的记录加独占锁")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FOR")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("UPDATE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),a("p",[s._v("意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（"),a("code",[s._v("LOCK TABLES ... READ")]),s._v("）和独占表锁（"),a("code",[s._v("LOCK TABLES ... WRITE")]),s._v("）发生冲突。")]),s._v(" "),a("h4",{attrs:{id:"auto-inc-锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#auto-inc-锁"}},[s._v("#")]),s._v(" AUTO-INC 锁")]),s._v(" "),a("p",[s._v("表里的主键通常都会设置成自增的，这是通过对主键字段声明 "),a("code",[s._v("AUTO_INCREMENT")]),s._v(" 属性实现的。")]),s._v(" "),a("p",[a("strong",[s._v("在插入数据时，会加一个表级别的 AUTO-INC 锁")]),s._v("，然后为被 "),a("code",[s._v("AUTO_INCREMENT")]),s._v(" 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。")]),s._v(" "),a("p",[s._v("但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种 "),a("strong",[s._v("轻量级的锁")]),s._v(" 来实现自增。在插入数据的时候，会为被 "),a("code",[s._v("AUTO_INCREMENT")]),s._v(" 修饰的字段加上轻量级锁，"),a("strong",[s._v("然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁")]),s._v("。")]),s._v(" "),a("h3",{attrs:{id:"行级锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#行级锁"}},[s._v("#")]),s._v(" 行级锁")]),s._v(" "),a("p",[s._v("InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。")]),s._v(" "),a("p",[s._v("如果要在查询时对记录加行锁，可以使用下面这两个方式：")]),s._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 对读取的记录加共享锁")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("LOCK")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("IN")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SHARE")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("MODE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("# 对读取的记录加独占锁")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FOR")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("UPDATE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),a("p",[s._v("共享锁（S 锁）满足读读共享、读写互斥。独占锁（X 锁）满足写写互斥、读写互斥。")]),s._v(" "),a("p",[s._v("行级锁的类型主要有三类：")]),s._v(" "),a("ul",[a("li",[s._v("记录锁（Record Lock）：锁定一条记录；")]),s._v(" "),a("li",[s._v("间隙锁（Gap Lock）：锁定一个范围，但是不包含记录本身；")]),s._v(" "),a("li",[s._v("临键锁（Next-Key Lock）：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。")])]),s._v(" "),a("h4",{attrs:{id:"记录锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#记录锁"}},[s._v("#")]),s._v(" 记录锁")]),s._v(" "),a("p",[s._v("记录锁（Record Lock）锁住的是一条记录。记录锁有 S 锁和 X 锁之分。")]),s._v(" "),a("p",[s._v("举个例子，当一个事务执行了下面这条语句：")]),s._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[s._v("mysql "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("BEGIN")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\nmysql "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v(">")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("SELECT")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FROM")]),s._v(" t_test "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("WHERE")]),s._v(" id "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("FOR")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("UPDATE")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n")])])]),a("p",[s._v("对 t_test 表中主键 id 为 1 的这条记录加上 X 型的记录锁，这样其他事务就无法对这条记录进行修改了。")]),s._v(" "),a("p",[s._v("当事务执行 commit 后，事务过程中生成的锁都会被释放。")]),s._v(" "),a("h4",{attrs:{id:"间隙锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#间隙锁"}},[s._v("#")]),s._v(" 间隙锁")]),s._v(" "),a("p",[s._v("间隙锁（Gap Lock）只存在于可重复读隔离级别，目的是解决可重复读隔离级别下幻读的现象。")]),s._v(" "),a("p",[s._v("假设，表中有一个范围 id 为 (3, 5) 间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。")]),s._v(" "),a("p",[s._v("间隙锁虽然存在 X 型和 S 型，但并没有什么区别，"),a("strong",[s._v("间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的")]),s._v("。")]),s._v(" "),a("h4",{attrs:{id:"临键锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#临键锁"}},[s._v("#")]),s._v(" 临键锁")]),s._v(" "),a("p",[s._v("临键锁（Next-Key Lock）是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。")]),s._v(" "),a("p",[s._v("假设，表中有一个范围 id 为 (3, 5] 的临键锁，那么其他事务既不能插入 id = 4 记录，又不能修改 id = 5 这条记录。")]),s._v(" "),a("p",[s._v("临键锁是包含间隙锁 + 记录锁的，"),a("strong",[s._v("如果一个事务获取了 X 型的临键锁，那么另外一个事务在获取相同范围的 X 型的临键锁时，是会被阻塞的。")])]),s._v(" "),a("div",{staticClass:"anchor",attrs:{id:"插入意向锁"}},[s._v("插入意向锁")]),a("p",[s._v("一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（Next-Key lock 包含间隙锁）。")]),s._v(" "),a("p",[s._v("如果有的话，插入操作就会发生 "),a("strong",[s._v("阻塞")]),s._v("，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个 "),a("strong",[s._v("插入意向锁")]),s._v("，表明有事务想在某个区间插入新记录，但是现在处于等待状态。")]),s._v(" "),a("blockquote",[a("p",[s._v("MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁。")])]),s._v(" "),a("p",[s._v("插入意向锁并 "),a("strong",[s._v("不是意向锁，是一种特殊的间隙锁，属于行级别锁")]),s._v("。")]),s._v(" "),a("h2",{attrs:{id:"_4-2-mysql-如何加锁"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-mysql-如何加锁"}},[s._v("#")]),s._v(" 4.2 MySQL 如何加锁")]),s._v(" "),a("p",[s._v("https://xiaolincoding.com/mysql/lock/how_to_lock.html#%E4%BB%80%E4%B9%88-sql-%E8%AF%AD%E5%8F%A5%E4%BC%9A%E5%8A%A0%E8%A1%8C%E7%BA%A7%E9%94%81")])])}),[],!1,null,null,null);t.default=v.exports}}]);