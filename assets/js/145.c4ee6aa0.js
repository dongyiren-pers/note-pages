(window.webpackJsonp=window.webpackJsonp||[]).push([[145],{1062:function(t,a,s){"use strict";s.r(a);var e=s(14),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"第5章-jvm-调优"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第5章-jvm-调优"}},[t._v("#")]),t._v(" 第5章 JVM 调优")]),t._v(" "),s("h2",{attrs:{id:"_5-1-调优概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-调优概述"}},[t._v("#")]),t._v(" 5.1 调优概述")]),t._v(" "),s("p",[t._v("JVM 调优可通过以下步骤进行：")]),t._v(" "),s("ul",[s("li",[t._v("分析系统系统运行情况：分析 GC 日志及 dump 文件，判断是否需要优化，确定瓶颈问题点；")]),t._v(" "),s("li",[t._v("确定 JVM 调优量化目标；")]),t._v(" "),s("li",[t._v("确定 JVM 调优参数（根据历史 JVM 参数来调整）；")]),t._v(" "),s("li",[t._v("依次确定调优内存、延迟、吞吐量等指标；")]),t._v(" "),s("li",[t._v("对比观察调优前后的差异；")]),t._v(" "),s("li",[t._v("不断的分析和调整，直到找到合适的 JVM 参数配置；")]),t._v(" "),s("li",[t._v("找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。")])]),t._v(" "),s("p",[t._v("以上操作步骤中，某些步骤是需要多次不断迭代完成的。一般是从满足程序的内存使用需求开始的，之后是时间延迟的要求，最后才是吞吐量的要求，要基于这个步骤来不断优化，每一个步骤都是进行下一步的基础，不可逆行。")]),t._v(" "),s("h2",{attrs:{id:"_5-2-jvm-参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-jvm-参数"}},[t._v("#")]),t._v(" 5.2 JVM 参数")]),t._v(" "),s("h3",{attrs:{id:"基本参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基本参数"}},[t._v("#")]),t._v(" 基本参数")]),t._v(" "),s("style",[t._v("\n                        .table-column-x-x-container-3swq1l6o table th:nth-of-type(1) {\n                            width: 40%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-3swq1l6o table th:nth-of-type(2) {\n                            width: 40%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-3swq1l6o table th:nth-of-type(3) {\n                            width: 20%;\n                            word-wrap: break-word;\n                        }\n                    ")]),s("div",{staticClass:"table-column-x-x-container-3swq1l6o"},[s("table",[s("thead",[s("tr",[s("th",[t._v("参数名称")]),t._v(" "),s("th",[t._v("含义")]),t._v(" "),s("th",[t._v("默认")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[s("u",[s("strong",[t._v("-Xms")])])]),t._v(" "),s("td",[t._v("初始堆大小")]),t._v(" "),s("td",[t._v("内存的1/64")])]),t._v(" "),s("tr",[s("td",[s("strong",[s("u",[t._v("-Xmx")])])]),t._v(" "),s("td",[t._v("最大堆大小")]),t._v(" "),s("td",[t._v("内存的1/4")])]),t._v(" "),s("tr",[s("td",[s("strong",[s("u",[t._v("-Xmn")])])]),t._v(" "),s("td",[t._v("新生代大小")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[s("strong",[s("u",[t._v("-XX:NewSize")])])]),t._v(" "),s("td",[t._v("新生代初始大小")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[s("strong",[s("u",[t._v("-XX:MaxNewSize")])])]),t._v(" "),s("td",[t._v("新生代最大值")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[s("strong",[s("u",[t._v("-XX:PermSize")])])]),t._v(" "),s("td",[t._v("永久代初始大小")]),t._v(" "),s("td",[t._v("内存的1/64")])]),t._v(" "),s("tr",[s("td",[s("strong",[s("u",[t._v("-XX:MaxPermSize")])])]),t._v(" "),s("td",[t._v("永久代最大值")]),t._v(" "),s("td",[t._v("内存的1/4")])]),t._v(" "),s("tr",[s("td",[s("strong",[s("u",[t._v("-Xss")])])]),t._v(" "),s("td",[t._v("线程的堆栈大小")]),t._v(" "),s("td",[t._v("JDK 5 之前 256K，之后 1M")])]),t._v(" "),s("tr",[s("td",[t._v("-XX:ThreadStackSize")]),t._v(" "),s("td",[t._v("线程的堆栈大小")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[s("u",[s("strong",[t._v("-XX:NewRatio")])])]),t._v(" "),s("td",[t._v("新生代与老年代的比值"),s("br"),t._v("例如: -XX:NewRatio=3，表示新生代与年老代比值为 1:3")]),t._v(" "),s("td",[t._v("1:2")])]),t._v(" "),s("tr",[s("td",[s("u",[s("strong",[t._v("-XX:SurvivorRatio")])])]),t._v(" "),s("td",[t._v("Eden 区与 Survivor 区的大小比值")]),t._v(" "),s("td",[t._v("8:1:1")])]),t._v(" "),s("tr",[s("td",[t._v("-XX:LargePageSizeInBytes")]),t._v(" "),s("td",[t._v("内存页的大小不可设置过大，会影响 Perm 的大小")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("-XX:+UseFastAccessorMethods")]),t._v(" "),s("td",[t._v("原始类型的快速优化")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("-XX:+DisableExplicitGC")]),t._v(" "),s("td",[t._v("关闭 System.gc()")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("-XX:+ExplicitGCInvokesConcurrent")]),t._v(" "),s("td",[t._v("关闭 System.gc()")]),t._v(" "),s("td",[t._v("disabled")])]),t._v(" "),s("tr",[s("td",[t._v("-XX:+ExplicitGCInvokesConcurrent"),s("br"),t._v("AndUnloadsClasses")]),t._v(" "),s("td",[t._v("关闭 System.gc()")]),t._v(" "),s("td",[t._v("disabled")])]),t._v(" "),s("tr",[s("td",[s("strong",[s("u",[t._v("-XX:MaxTenuringThreshold")])])]),t._v(" "),s("td",[t._v("垃圾最大年龄")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("-XX:+AggressiveOpts")]),t._v(" "),s("td",[t._v("加快编译")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("-XX:+UseBiasedLocking")]),t._v(" "),s("td",[t._v("锁机制的性能改善")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("-Xnoclassgc")]),t._v(" "),s("td",[t._v("禁用垃圾回收")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("-XX:SoftRefLRUPolicyMSPerMB")]),t._v(" "),s("td",[t._v("每兆堆空闲空间中 SoftReference 的存活时间")]),t._v(" "),s("td",[t._v("1s")])]),t._v(" "),s("tr",[s("td",[t._v("-XX:PretenureSizeThreshold")]),t._v(" "),s("td",[t._v("对象超过多大时直接在老年代分配")]),t._v(" "),s("td",[t._v("0")])]),t._v(" "),s("tr",[s("td",[t._v("-XX:TLABWasteTargetPercent")]),t._v(" "),s("td",[t._v("TLAB 占 eden 区的百分比")]),t._v(" "),s("td",[t._v("1%")])]),t._v(" "),s("tr",[s("td",[t._v("-XX:+CollectGen0First")]),t._v(" "),s("td",[t._v("FullGC 时是否先 YGC")]),t._v(" "),s("td",[t._v("false")])])])])]),s("div",{staticClass:"subtitle"},[s("p",[t._v("JDK 7 主要参数")])]),s("style",[t._v("\n                        .table-column-x-x-container-p8pxq6sj table th:nth-of-type(1) {\n                            width: 40%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-p8pxq6sj table th:nth-of-type(2) {\n                            width: 40%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-p8pxq6sj table th:nth-of-type(3) {\n                            width: 20%;\n                            word-wrap: break-word;\n                        }\n                    ")]),s("div",{staticClass:"table-column-x-x-container-p8pxq6sj"},[s("table",[s("thead",[s("tr",[s("th",[s("strong",[t._v("参数名称")])]),t._v(" "),s("th",[s("strong",[t._v("含义")])]),t._v(" "),s("th",[t._v("默认")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("-XX:PermSize")]),t._v(" "),s("td",[t._v("永久代大小")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("-XX:MaxPermSize")]),t._v(" "),s("td",[t._v("最大永久代大小")]),t._v(" "),s("td")])])])]),s("div",{staticClass:"subtitle"},[s("p",[t._v("JDK 8 主要参数")])]),s("style",[t._v("\n                        .table-column-x-x-container-s7ygjpow table th:nth-of-type(1) {\n                            width: 40%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-s7ygjpow table th:nth-of-type(2) {\n                            width: 40%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-s7ygjpow table th:nth-of-type(3) {\n                            width: 20%;\n                            word-wrap: break-word;\n                        }\n                    ")]),s("div",{staticClass:"table-column-x-x-container-s7ygjpow"},[s("table",[s("thead",[s("tr",[s("th",[s("strong",[t._v("参数名称")])]),t._v(" "),s("th",[s("strong",[t._v("含义")])]),t._v(" "),s("th",[t._v("默认")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("-XX:MetaspaceSize")]),t._v(" "),s("td",[t._v("元空间大小")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("-XX:MaxMetaspaceSize")]),t._v(" "),s("td",[t._v("最大元空间大小")]),t._v(" "),s("td")])])])]),s("h3",{attrs:{id:"并行收集器相关参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#并行收集器相关参数"}},[t._v("#")]),t._v(" 并行收集器相关参数")]),t._v(" "),s("style",[t._v("\n                        .table-column-x-x-container-76jbctls table th:nth-of-type(1) {\n                            width: 40%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-76jbctls table th:nth-of-type(2) {\n                            width: 40%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-76jbctls table th:nth-of-type(3) {\n                            width: 20%;\n                            word-wrap: break-word;\n                        }\n                    ")]),s("div",{staticClass:"table-column-x-x-container-76jbctls"},[s("table",[s("thead",[s("tr",[s("th",[s("strong",[t._v("参数名称")])]),t._v(" "),s("th",[s("strong",[t._v("含义")])]),t._v(" "),s("th",[t._v("默认")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("-XX:+UseParallelGC")]),t._v(" "),s("td",[t._v("Full GC 采用 Parallel MSC。"),s("br"),t._v("选择垃圾收集器为并行收集器。此配置仅对新生代有效，即上述配置下，新生代使用并发收集，而老年代仍旧使用串行收集。")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("-XX:+UseParNewGC")]),t._v(" "),s("td",[t._v("新生代为并行收集。")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("-XX:ParallelGCThreads")]),t._v(" "),s("td",[t._v("并行收集器的线程数")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("-XX:+UseParallelOldGC")]),t._v(" "),s("td",[t._v("老年代垃圾收集方式为并行收集（Parallel Compacting）")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("-XX:MaxGCPauseMillis")]),t._v(" "),s("td",[t._v("每次新生代垃圾回收的最长时间（最大暂停时间）")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("-XX:+UseAdaptiveSizePolicy")]),t._v(" "),s("td",[t._v("自动选择新生代区大小和相应的 Survivor 区比例")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("-XX:GCTimeRatio")]),t._v(" "),s("td",[t._v("垃圾回收时间占程序运行时间的百分比")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("-XX:+ScavengeBeforeFullGC")]),t._v(" "),s("td",[t._v("Full GC 前调用 YGC")]),t._v(" "),s("td",[t._v("true")])])])])]),s("h3",{attrs:{id:"cms-相关参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cms-相关参数"}},[t._v("#")]),t._v(" CMS 相关参数")]),t._v(" "),s("style",[t._v("\n                        .table-column-x-x-container-9l42riuf table th:nth-of-type(1) {\n                            width: 40%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-9l42riuf table th:nth-of-type(2) {\n                            width: 40%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-9l42riuf table th:nth-of-type(3) {\n                            width: 20%;\n                            word-wrap: break-word;\n                        }\n                    ")]),s("div",{staticClass:"table-column-x-x-container-9l42riuf"},[s("table",[s("thead",[s("tr",[s("th",[s("strong",[t._v("参数名称")])]),t._v(" "),s("th",[s("strong",[t._v("含义")])]),t._v(" "),s("th",[t._v("默认")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("-XX:+UseConcMarkSweepGC")]),t._v(" "),s("td",[t._v("使用 CMS 内存收集")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("-XX:+AggressiveHeap")]),t._v(" "),s("td"),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("-XX:CMSFullGCsBeforeCompaction")]),t._v(" "),s("td",[t._v("多少次后进行内存压缩")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("-XX:+CMSParallelRemarkEnabled")]),t._v(" "),s("td",[t._v("降低标记停顿")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("-XX+UseCMSCompactAt"),s("br"),t._v("FullCollection")]),t._v(" "),s("td",[t._v("在 FULL GC 时，对年老代的压缩")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("-XX:+UseCMSInitiatingOccupancy"),s("br"),t._v("Only")]),t._v(" "),s("td",[t._v("使用手动定义初始化定义开始 CMS 收集")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("-XX:CMSInitiatingOccupancy"),s("br"),t._v("Fraction")]),t._v(" "),s("td",[t._v("使用 CMS 作为垃圾回收"),s("br"),t._v("使用 70％后开始 CMS 收集")]),t._v(" "),s("td",[t._v("92")])]),t._v(" "),s("tr",[s("td",[t._v("-XX:CMSInitiatingPermOccupancy"),s("br"),t._v("Fraction")]),t._v(" "),s("td",[t._v("设置 Perm Gen 使用到达多少比率时触发")]),t._v(" "),s("td",[t._v("92")])]),t._v(" "),s("tr",[s("td",[t._v("-XX:+CMSIncrementalMode")]),t._v(" "),s("td",[t._v("设置为增量模式")]),t._v(" "),s("td")]),t._v(" "),s("tr",[s("td",[t._v("-XX:+CMSClassUnloadingEnabled")]),t._v(" "),s("td"),t._v(" "),s("td")])])])]),s("h2",{attrs:{id:"_5-3-性能监控工具"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-性能监控工具"}},[t._v("#")]),t._v(" 5.3 性能监控工具")]),t._v(" "),s("h3",{attrs:{id:"jdk-工具"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jdk-工具"}},[t._v("#")]),t._v(" JDK 工具")]),t._v(" "),s("p",[t._v("JDK 自带了很多性能监控工具，我们可以用这些工具来监测系统和排查内存性能问题。")]),t._v(" "),s("style",[t._v("\n                        .table-column-x-x-container-8mk92vwv table th:nth-of-type(1) {\n                            width: 20%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-8mk92vwv table th:nth-of-type(2) {\n                            width: 20%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-8mk92vwv table th:nth-of-type(3) {\n                            width: 60%;\n                            word-wrap: break-word;\n                        }\n                    ")]),s("div",{staticClass:"table-column-x-x-container-8mk92vwv"},[s("table",[s("thead",[s("tr",[s("th",[t._v("工具")]),t._v(" "),s("th",[t._v("类型")]),t._v(" "),s("th",[t._v("功能")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("jps")]),t._v(" "),s("td",[t._v("命令行")]),t._v(" "),s("td",[t._v("JVM 进程状态工具，列出系统上的 JVM 进程")])]),t._v(" "),s("tr",[s("td",[t._v("jinfo")]),t._v(" "),s("td",[t._v("命令行")]),t._v(" "),s("td",[t._v("JVM 信息查看工具，查看 JVM 的各种配置信息")])]),t._v(" "),s("tr",[s("td",[t._v("jvisualvm")]),t._v(" "),s("td",[t._v("图形界面")]),t._v(" "),s("td",[t._v("综合的 JVM 监控工具，查看 JVM 基本情况、做栈和堆转储、做内存和 CPUprofiling 等")])]),t._v(" "),s("tr",[s("td",[t._v("jconsole")]),t._v(" "),s("td",[t._v("图形界面")]),t._v(" "),s("td",[t._v("JMX 兼容的图形工具，用于监控 JVM 基本情况，查看 MBean")])]),t._v(" "),s("tr",[s("td",[t._v("jstat")]),t._v(" "),s("td",[t._v("命令行")]),t._v(" "),s("td",[t._v("JVM 统计监控工具，附加到一个 JVM 进程上收集和记录 JVM 的各种性能指标数据")])]),t._v(" "),s("tr",[s("td",[t._v("jstack")]),t._v(" "),s("td",[t._v("命令行")]),t._v(" "),s("td",[t._v("JVM 栈查看工具，可以打印 JVM 进程的线程栈和锁情况")])]),t._v(" "),s("tr",[s("td",[t._v("jcmd")]),t._v(" "),s("td",[t._v("命令行")]),t._v(" "),s("td",[t._v("JVM 命令行调试工具，用于向 JVM 进程发送调试命令")])]),t._v(" "),s("tr",[s("td",[t._v("jmap")]),t._v(" "),s("td",[t._v("命令行")]),t._v(" "),s("td",[t._v("JVM 堆内存分析工具，可以打印 JVM 进程对象直方图、类加载统计，以及做堆转储操作")])])])])]),s("h3",{attrs:{id:"linux-命令行工具"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#linux-命令行工具"}},[t._v("#")]),t._v(" Linux 命令行工具")]),t._v(" "),s("p",[t._v("进行性能监控和问题排查的时候，常常是结合操作系统本身的命令行工具来进行。")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("命令")]),t._v(" "),s("th",[t._v("功能")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("top")]),t._v(" "),s("td",[t._v("实时显示正在执行进程的 CPU 使用率、内存使用率以及系统负载等信息")])]),t._v(" "),s("tr",[s("td",[t._v("vmstat")]),t._v(" "),s("td",[t._v("对操作系统的虚拟内存、进程、CPU 活动进行监控")])]),t._v(" "),s("tr",[s("td",[t._v("pidstat")]),t._v(" "),s("td",[t._v("监控指定进程的上下文切换")])]),t._v(" "),s("tr",[s("td",[t._v("iostat")]),t._v(" "),s("td",[t._v("监控磁盘 IO")])])])]),t._v(" "),s("h2",{attrs:{id:"_5-4-调优策略"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-调优策略"}},[t._v("#")]),t._v(" 5.4 调优策略")]),t._v(" "),s("h3",{attrs:{id:"选择合适的垃圾回收器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#选择合适的垃圾回收器"}},[t._v("#")]),t._v(" 选择合适的垃圾回收器")]),t._v(" "),s("p",[s("strong",[t._v("CPU 单核")]),t._v("：毫无疑问 Serial 垃圾收集器是唯一的选择")]),t._v(" "),s("p",[s("strong",[t._v("CPU 多核、关注吞吐量")]),t._v("：选择 Parallel Scavenge + Parallel Old 组合")]),t._v(" "),s("p",[s("strong",[t._v("CPU 多核、关注用户停顿时间、JDK 版本 1.6 或者 1.7")]),t._v("：选择 CMS")]),t._v(" "),s("p",[s("strong",[t._v("CPU 多核，关注用户停顿时间、JDK 1.8 及以上，JVM 可用内存 6G 以上")]),t._v("：选择 G1")]),t._v(" "),s("p",[t._v("参数配置：")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 设置 Serial 垃圾收集器（新生代）")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("XX"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UseSerialGC")]),t._v("\n\t\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 设置 Parallel Scavenge + Parallel Old 组合")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 新生代使用功能 Parallel Scavenge ")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 老年代使用 Parallel Old 收集器")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("XX"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UseParallelOldGC")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 设置 CMS 垃圾收集器（老年代）")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("XX"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UseConcMarkSweepGC")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 设置 G1 垃圾收集器")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("XX"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UseG1GC")]),t._v("\n")])])]),s("h3",{attrs:{id:"调整内存大小"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#调整内存大小"}},[t._v("#")]),t._v(" 调整内存大小")]),t._v(" "),s("p",[s("strong",[t._v("现象")]),t._v("：垃圾收集频率非常频繁。")]),t._v(" "),s("p",[s("strong",[t._v("原因")]),t._v("：如果内存太小，就会导致频繁的需要进行垃圾收集才能释放出足够的空间来创建新的对象，所以增加堆内存大小的效果是非常显而易见的。")]),t._v(" "),s("p",[s("strong",[t._v("注意")]),t._v("：如果垃圾收集次数非常频繁，但是每次能回收的对象非常少，那么这个时候并非内存太小，而可能是内存泄露导致对象无法回收，从而造成频繁 GC。")]),t._v(" "),s("p",[t._v("参数配置：")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 设置堆初始值")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Xms2g")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("XX"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("InitialHeapSize")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2048")]),t._v("m\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 设置堆区最大值")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Xmx2g")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("XX"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MaxHeapSize")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2048")]),t._v("m\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 设置新生代内存配置")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Xmn512m")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("XX"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MaxNewSize")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("512")]),t._v("m\n")])])]),s("h3",{attrs:{id:"设置符合预期的停顿时间"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#设置符合预期的停顿时间"}},[t._v("#")]),t._v(" 设置符合预期的停顿时间")]),t._v(" "),s("p",[s("strong",[t._v("现象")]),t._v("：程序间接性的卡顿。")]),t._v(" "),s("p",[s("strong",[t._v("原因")]),t._v("：如果没有确切的停顿时间设定，垃圾收集器以吞吐量为主，则垃圾收集时间就会不稳定。")]),t._v(" "),s("p",[s("strong",[t._v("注意")]),t._v("：不要设置不切实际的停顿时间，单次时间越短意味着需要更次 GC 才能回收完原有数量的垃圾。")]),t._v(" "),s("p",[t._v("参数配置：")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// GC 停顿时间，垃圾收集器会尝试用各种手段达到这个时间")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("XX"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MaxGCPauseMillis")]),t._v(" \n")])])]),s("h3",{attrs:{id:"调整内存区域大小比率"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#调整内存区域大小比率"}},[t._v("#")]),t._v(" 调整内存区域大小比率")]),t._v(" "),s("p",[s("strong",[t._v("现象")]),t._v("：某一个区域的 GC 频繁，其他都正常。")]),t._v(" "),s("p",[s("strong",[t._v("原因")]),t._v("：如果对应区域空间不足，导致需要频繁 GC 来释放空间，在 JVM 堆内存无法增加的情况下，可以调整对应区域的大小比率。")]),t._v(" "),s("p",[s("strong",[t._v("注意")]),t._v("：可能并非空间不足，而是因为内存泄造成内存无法回收。从而导致 GC 频繁。")]),t._v(" "),s("p",[t._v("参数配置：")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Survivor 区和 Eden 区大小比率")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("XX"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SurvivorRatio")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Survivor 区和 Eden 区占新生代比率为 1:6，两个 Survivor 区 2:6")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 新生代和老年代的占比")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("XX"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("NewRatio")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 表示 新生代:老年代 = 1:4，即老年代占整个堆的 4/5；默认值为 2")]),t._v("\n")])])]),s("h3",{attrs:{id:"调整对象升老年代的年龄"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#调整对象升老年代的年龄"}},[t._v("#")]),t._v(" 调整对象升老年代的年龄")]),t._v(" "),s("p",[s("strong",[t._v("现象")]),t._v("：老年代频繁 GC，每次回收的对象很多。")]),t._v(" "),s("p",[s("strong",[t._v("原因")]),t._v("：如果升代年龄小，新生代的对象很快就进入老年代了，导致老年代对象变多，而这些对象其实在随后的很短时间内就可以回收，这时可以调整对象的升级代年龄，让对象不那么容易进入老年代解决老年代空间不足频繁 GC 问题。")]),t._v(" "),s("p",[s("strong",[t._v("注意")]),t._v("：增加了年龄之后，这些对象在新生代的时间会变长，可能导致新生代的 GC 频率增加。")]),t._v(" "),s("p",[t._v("参数配置：")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 进入老年代最小的 GC 年龄，新生代对象转换为老年代对象最小年龄值，默认值 7")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("XX"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("InitialTenuringThreshol")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("7")]),t._v(" \n")])])]),s("h3",{attrs:{id:"调整大对象的标准"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#调整大对象的标准"}},[t._v("#")]),t._v(" 调整大对象的标准")]),t._v(" "),s("p",[s("strong",[t._v("现象")]),t._v("：老年代频繁 GC，每次回收的对象很多，而且单个对象的体积都比较大。")]),t._v(" "),s("p",[s("strong",[t._v("原因")]),t._v("：如果大量的大对象直接分配到老年代，导致老年代容易被填满而造成频繁 GC，可设置对象直接进入老年代的标准。")]),t._v(" "),s("p",[s("strong",[t._v("注意")]),t._v("：这些大对象进入新生代后可能会使新生代的GC频率和时间增加。")]),t._v(" "),s("p",[t._v("参数配置：")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 新生代可容纳的最大对象，大于则直接会分配到老年代，0 代表没有限制。")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("XX"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("PretenureSizeThreshold")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1000000")]),t._v(" \n")])])]),s("h3",{attrs:{id:"调整-gc-的触发时机"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#调整-gc-的触发时机"}},[t._v("#")]),t._v(" 调整 GC 的触发时机")]),t._v(" "),s("p",[s("strong",[t._v("现象")]),t._v("：CMS、G1 经常 Full GC，程序卡顿严重。")]),t._v(" "),s("p",[s("strong",[t._v("原因")]),t._v("：G1 和 CMS 部分 GC 阶段是并发进行的，业务线程和垃圾收集线程一起工作，垃圾收集的过程中业务线程会生成新的对象，因此在 GC 的时候需要预留一部分内存空间来容纳新产生的对象，如果这个时候内存空间不足以容纳新产生的对象，那么 JVM 就会停止并发收集暂停所有业务线程（STW）来保证垃圾收集的正常运行。这个时候可以调整 GC 触发的时机（比如在老年代占用 60% 就触发 GC），这样就可以预留足够的空间来让业务线程创建的对象有足够的空间分配。")]),t._v(" "),s("p",[s("strong",[t._v("注意")]),t._v("：提早触发 GC 会增加老年代 GC 的频率。")]),t._v(" "),s("p",[t._v("参数配置：")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 使用多少比例的老年代后开始 CMS 收集，默认是 68%，如果频繁发生 Serial Old 卡顿，应该调小")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("XX"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("CMSInitiatingOccupancyFraction")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("68")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// G1 混合垃圾回收周期中要包括的旧区域设置占用率阈值，默认占用率为 65%")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("XX"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("G1MixedGCLiveThresholdPercent")]),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("65")]),t._v(" \n")])])]),s("h3",{attrs:{id:"调整-jvm-本地内存大小"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#调整-jvm-本地内存大小"}},[t._v("#")]),t._v(" 调整 JVM 本地内存大小")]),t._v(" "),s("p",[s("strong",[t._v("现象")]),t._v("：GC 的次数、时间和回收的对象都正常，堆内存空间充足，但是报 OOM。")]),t._v(" "),s("p",[s("strong",[t._v("原因")]),t._v("： JVM 除了堆内存之外还有一块堆外内存，这片内存又称为本地内存，可是这块内存区域不足了并不会主动触发 GC，只有在堆内存区域触发的时候顺带会把本地内存回收了，而一旦本地内存分配不足就会直接报 OOM 异常。")]),t._v(" "),s("p",[s("strong",[t._v("注意")]),t._v("：本地内存异常的时候除了上面的现象之外，异常信息可能是 OutOfMemoryError:Direct buffer memory。 解决方式除了调整本地内存大小之外，也可以在出现此异常时进行捕获，手动触发 GC（"),s("code",[t._v("System.gc()")]),t._v("）。")]),t._v(" "),s("p",[t._v("参数配置：")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("XX"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MaxDirectMemorySize")]),t._v("\n")])])]),s("h2",{attrs:{id:"_5-5-oom-场景及解决方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-5-oom-场景及解决方案"}},[t._v("#")]),t._v(" 5.5 OOM 场景及解决方案")]),t._v(" "),s("p",[t._v("在《Java虚拟机规范》的规定里，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生 OutOfMemoryError 异常的可能。")]),t._v(" "),s("h3",{attrs:{id:"线程溢出-unable-to-create-new-native-thread"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线程溢出-unable-to-create-new-native-thread"}},[t._v("#")]),t._v(" 线程溢出 - unable to create new native thread")]),t._v(" "),s("p",[t._v("操作系统对于一个进程所能创建的本地线程数有限制。当尝试创建新的本地线程时，如果已经达到了系统的线程数限制，就会出现 "),s("code",[t._v("java.lang.OutOfMemoryError: unable to create new native thread")]),t._v("  错误。这通常发生在运行线程密集型应用程序或者系统资源有限的情况下。")]),t._v(" "),s("div",{staticClass:"subtitle"},[s("p",[t._v("示例代码")])]),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("NativeThreadDemo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("sleep")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("MAX_VALUE"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("catch")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("InterruptedException")]),t._v(" e"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("start")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("运行结果：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("Error occurred during initialization of VM\n\tjava.lang.OutOfMemoryError: unable to create new native thread\n")])])]),s("div",{staticClass:"subtitle"},[s("p",[t._v("常见原因")])]),s("ul",[s("li",[t._v("线程数超过操作系统最大线程数限制（和平台有关）")]),t._v(" "),s("li",[t._v("线程数超过 kernel.pid_max（只能重启）")]),t._v(" "),s("li",[t._v("native 内存不足")])]),t._v(" "),s("div",{staticClass:"subtitle"},[s("p",[t._v("解决方案")])]),s("ul",[s("li",[t._v("降低程序中创建线程的数量，分析应用是否真的需要创建这么多线程。")]),t._v(" "),s("li",[t._v("如果确实需要创建很多线程，则调高操作系统层面的线程最大数：执行 "),s("code",[t._v("ulimia-a")]),t._v(" 查看最大线程数限制，使用 "),s("code",[t._v("ulimit-u xxx")]),t._v(" 调整最大线程数限制。")])]),t._v(" "),s("h3",{attrs:{id:"堆内存溢出-java-heap-space"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#堆内存溢出-java-heap-space"}},[t._v("#")]),t._v(" 堆内存溢出 - Java heap space")]),t._v(" "),s("p",[t._v("当堆内存（Heap Space）没有足够空间存放新创建的对象时，就会抛出 "),s("code",[t._v("java.lang.OutOfMemoryError: Java heap space")]),t._v(" 错误。")]),t._v(" "),s("p",[t._v("Java 堆用于存储对象实例，只要不断的创建对象，并且保证 GC Roots 到对象之间有可达路径来避免 GC 清除这些对象，那随着对象数量的增加，总容量触及堆的最大容量限制后就会产生内存溢出异常。")]),t._v(" "),s("div",{staticClass:"subtitle"},[s("p",[t._v("示例代码")])]),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("JavaHeapSpaceDemo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" SIZE "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1024")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1024")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("SIZE"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("运行结果：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('Exception in thread "main" java.lang.OutOfMemoryError：Java heap space\n\tat com.atguigu.java.oom.JavaHeapSpaceDemo.main(JavaHeapSpaceDemo.java：13)\n')])])]),s("div",{staticClass:"subtitle"},[s("p",[t._v("常见原因")])]),s("ul",[s("li",[t._v("请求创建一个超大对象，通常是一个大数组。")]),t._v(" "),s("li",[t._v("超出预期的访问量/数据量，通常是上游系统请求流量飙升，常见于各类促销/秒杀活动，可以结合业务流量指标排查是否有尖状峰值。")]),t._v(" "),s("li",[t._v("过度使用终结器（Finalizer），该对象没有立即被 GC。")]),t._v(" "),s("li",[t._v("内存泄漏（Memory Leak），大量对象引用没有释放，JVM 无法对其自动回收，常见于使用了 File 等资源没有回收。")])]),t._v(" "),s("div",{staticClass:"subtitle"},[s("p",[t._v("解决方案")])]),s("ul",[s("li",[t._v("针对大部分情况，通常只需要通过 -Xmx 参数调高 JVM 堆内存空间即可。")]),t._v(" "),s("li",[t._v("如果是超大对象，可以检查其合理性，比如是否一次性查询了数据库全部结果，而没有做结果数限制。")]),t._v(" "),s("li",[t._v("如果是业务峰值压力，可以考虑添加机器资源，或者做限流降级。")]),t._v(" "),s("li",[t._v("如果是内存泄漏，需要找到持有的对象，修改代码设计，比如关闭没有释放的连接。")])]),t._v(" "),s("h3",{attrs:{id:"垃圾回收上头-gc-overhead-limit-exceeded"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收上头-gc-overhead-limit-exceeded"}},[t._v("#")]),t._v(" 垃圾回收上头 - GC overhead limit exceeded")]),t._v(" "),s("p",[t._v("JVM 内置了垃圾回收机制 GC，我们不需要手工编写代码来进行内存分配和释放，但是当 Java 进程花费 98% 以上的时间执行 GC，但只恢复了不到 2% 的内存，且该动作连续重复了 5 次，就会抛出 "),s("code",[t._v("java.lang.OutOfMemoryError: GC overhead limit exceeded")]),t._v(" 错误（俗称：垃圾回收上头）。")]),t._v(" "),s("p",[t._v("简单地说，就是应用程序已经基本耗尽了所有可用内存， GC 也无法回收。")]),t._v(" "),s("p",[t._v("假如不抛出 GC overhead limit exceeded 错误，那 GC 清理的那么一丢丢内存很快就会被再次填满，迫使 GC 再次执行，这样恶性循环，CPU 使用率 100%，而 GC 没什么效果。")]),t._v(" "),s("div",{staticClass:"subtitle"},[s("p",[t._v("示例代码")])]),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("OutOfMemoryGCLimitExceed")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("addRandomDataToMap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Map")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" dataMap "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("HashMap")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Random")]),t._v(" r "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Random")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            dataMap"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("put")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("r"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("nextInt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("valueOf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("r"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("nextInt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("addRandomDataToMap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("。\n")])])]),s("p",[t._v("运行结果：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('Exception in thread "main" java.lang.OutOfMemoryError: GC overhead limit exceeded\n\tat java.lang.Integer.toString(Integer.java:403)\n')])])]),s("div",{staticClass:"subtitle"},[s("p",[t._v("常见原因")])]),s("p",[t._v("由于 GC 回收不了资源，触发了该错误的条件报错了，这个程序的最终错误，和 JVM 配置也会有关系，如果设置的堆内存特别小，会直接报 Java heap space。在资源受限的情况下，无法准确预测程序会死于哪种具体的原因。通过微调 -Xmx 大小试多几次会出现 "),s("code",[t._v("java.lang.OutOfMemoryError: GC Overhead Limit Exceeded")]),t._v("。")]),t._v(" "),s("div",{staticClass:"subtitle"},[s("p",[t._v("解决方案")])]),s("p",[t._v("此类问题的原因与解决方案跟 "),s("code",[t._v("Javaheap space")]),t._v(" 非常类似。")]),t._v(" "),s("ul",[s("li",[t._v("添加 JVM 参数 "),s("code",[t._v("-XX:-UseGCOverheadLimit")]),t._v("。不推荐这么干，没有真正解决问题，只是将异常推迟。")]),t._v(" "),s("li",[t._v("检查项目中是否有大量的死循环或有使用大内存的代码，优化代码。")]),t._v(" "),s("li",[t._v("dump 内存分析，检查是否存在内存泄露，如果没有，加大内存。")])]),t._v(" "),s("h3",{attrs:{id:"数组大小超限-requested-array-size-exceeds-vm-limit"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数组大小超限-requested-array-size-exceeds-vm-limit"}},[t._v("#")]),t._v(" 数组大小超限 - Requested array size exceeds VM limit")]),t._v(" "),s("p",[t._v("Java 虚拟机对单个数组的大小设置了一个限制。具体的限制取决于使用的 Java 虚拟机的版本和配置。在不同的 Java 虚拟机实现中，这个限制可能会有所不同。")]),t._v(" "),s("p",[t._v("Java 虚拟机为每个数组分配一块连续的内存空间，以便存储数组的元素。如果请求的数组大小超过了虚拟机的限制，就会抛出 "),s("code",[t._v("java.lang.OutOfMemoryError: Requested array size exceeds VM limit")]),t._v(" 错误。")]),t._v(" "),s("p",[t._v("这个限制是为了保护虚拟机免受内存溢出的影响。如果允许分配过大的数组，可能会消耗掉系统的所有可用内存资源，导致应用程序崩溃。")]),t._v(" "),s("div",{staticClass:"subtitle"},[s("p",[t._v("示例代码")])]),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ArraySizeExceedsVMLimitDemo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" arr "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("MAX_VALUE"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("运行结果：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('Exception in thread "main" java.lang.OutOfMemoryError: Requested array size exceeds VM limit\n')])])]),s("div",{staticClass:"subtitle"},[s("p",[t._v("常见原因")])]),s("ul",[s("li",[t._v("JVM 限制了数组的最大长度，该错误表示程序请求创建的数组超过最大长度限制。")]),t._v(" "),s("li",[t._v("JVM 在为数组分配内存前，会检查要分配的数据结构在系统中是否可寻址，通常为 "),s("code",[t._v("Integer.MAX_VALUE - 2")]),t._v("。")])]),t._v(" "),s("div",{staticClass:"subtitle"},[s("p",[t._v("解决方案")])]),s("p",[t._v("检查代码，确认业务是否需要创建如此大的数组，是否可以拆分为多个块，分批执行。")]),t._v(" "),s("h3",{attrs:{id:"元空间溢出-metaspace"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#元空间溢出-metaspace"}},[t._v("#")]),t._v(" 元空间溢出 - Metaspace")]),t._v(" "),s("p",[t._v("当元空间无法满足新的类加载请求或元数据的动态增长时，就会抛出 "),s("code",[t._v("java.lang.OutOfMemoryError: Metaspace")]),t._v(" 异常。")]),t._v(" "),s("p",[t._v("JDK 1.8 之前会出现 Permgen space，该错误表示永久代（Permanent Generation）已用满，通常是因为加载的 class 数目太多或体积太大。随着 1.8 中永久代的取消，就不会出现这种异常了。")]),t._v(" "),s("p",[t._v("Metaspace 是方法区在 HotSpot 中的实现，它与永久代最大的区别在于，元空间并不在虚拟机内存中而是使用本地内存，但是本地内存也有打满的时候，所以也会有异常。")]),t._v(" "),s("div",{staticClass:"subtitle"},[s("p",[t._v("示例代码")])]),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MetaspaceOOMDemo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Enhancer")]),t._v(" enhancer "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Enhancer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            enhancer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setSuperclass")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MetaspaceOOMDemo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            enhancer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setUseCache")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            enhancer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setCallback")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("MethodInterceptor")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("o"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" method"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" objects"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" methodProxy"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 动态代理创建对象")]),t._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" methodProxy"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("invokeSuper")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("o"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" objects"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            enhancer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("create")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("运行结果：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('Exception in thread "main" org.springframework.cglib.core.CodeGenerationException: java.lang.OutOfMemoryError--\x3eMetaspace\n')])])]),s("div",{staticClass:"subtitle"},[s("p",[t._v("常见原因")])]),s("ul",[s("li",[t._v("类加载过多：当应用程序动态加载过多的类时，会导致元空间的使用量增加。如果加载的类数量超过了元空间的限制，就会发生元空间溢出。")]),t._v(" "),s("li",[t._v("大量动态生成类：某些应用程序可能在运行时动态生成类，例如使用反射或动态代理。如果生成的类过多并且占用了大量的元空间，就可能导致元空间溢出。")]),t._v(" "),s("li",[t._v("内存泄漏：如果应用程序存在内存泄漏，即无用的类或类加载器没有被正确地释放，这些类将一直占用元空间的内存，导致元空间溢出。")]),t._v(" "),s("li",[t._v("设置不合理的元空间大小：JVM允许通过参数来配置元空间的大小。如果设置的大小过小，无法容纳应用程序所需的类元数据，就可能发生元空间溢出。")])]),t._v(" "),s("div",{staticClass:"subtitle"},[s("p",[t._v("解决方案")])]),s("ul",[s("li",[t._v("增加元空间大小：增加元空间的初始大小和最大大小，使其能够容纳更多的类元数据。可以使用 JVM 参数 "),s("code",[t._v("-XX:MetaspaceSize")]),t._v(" 设置初始大小，使用 "),s("code",[t._v("-XX:MaxMetaspaceSize")]),t._v(" 设置最大大小。")]),t._v(" "),s("li",[t._v("优化类加载机制：检查应用程序中的类加载行为，确保只加载必要的类。避免过多无用的类加载，可以采用延迟加载或按需加载的策略。")]),t._v(" "),s("li",[t._v("优化动态类的生成：减少不必要的动态类生成操作。避免过度使用反射和动态代理，尽可能使用静态类或编译时生成的类。")]),t._v(" "),s("li",[t._v("限制动态类的数量：如果无法避免大量动态生成类的需求，可以通过限制生成的类的数量或者使用对象池来重用动态生成的类，以减少元空间的压力。")]),t._v(" "),s("li",[t._v("定期检查和修复内存泄漏：使用内存分析工具来检查应用程序的内存使用情况，找出存在的内存泄漏问题，并及时修复。确保无用的类和类加载器能够正确释放，避免占用元空间的内存无法回收。")])]),t._v(" "),s("h3",{attrs:{id:"直接缓冲区溢出-direct-buffer-memory"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#直接缓冲区溢出-direct-buffer-memory"}},[t._v("#")]),t._v(" 直接缓冲区溢出 - Direct buffer memory")]),t._v(" "),s("p",[t._v("使用 NIO 的时候经常需要使用 ByteBuffer 来读取或写入数据，这是一种基于 Channel（通道） 和 Buffer（缓冲区）的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里面的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样在一些场景就避免了 Java 堆和 Native 中来回复制数据，所以性能会有所提高。")]),t._v(" "),s("p",[t._v("Java 允许应用程序通过 Direct ByteBuffer 直接访问堆外内存，许多高性能程序通过 Direct ByteBuffer 结合内存映射文件（Memory Mapped File）实现高速 IO。")]),t._v(" "),s("div",{staticClass:"subtitle"},[s("p",[t._v("示例代码")])]),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("DirectBufferMemoryDemo")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"maxDirectMemory is:"')]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" sun"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("misc"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("VM"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("maxDirectMemory")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1024")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1024")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"MB"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ByteBuffer buffer = ByteBuffer.allocate(6*1024*1024);")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ByteBuffer")]),t._v(" buffer "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ByteBuffer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("allocateDirect")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("6")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1024")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1024")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("运行结果：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('Exception in thread "main" java.lang.OutOfMemoryError: Direct buffer memory\n\tat java.nio.Bits.reserveMemory(Bits.java:694)\n')])])]),s("div",{staticClass:"subtitle"},[s("p",[t._v("常见原因")])]),s("p",[t._v("如果不断分配本地内存，堆内存很少使用，那么 JVM 就不需要执行 GC，DirectByteBuffer 对象就不会被回收，这时虽然堆内存充足，但本地内存可能已经不够用了，就会出现 OOM，本地直接内存溢出。")]),t._v(" "),s("div",{staticClass:"subtitle"},[s("p",[t._v("解决方案")])]),s("ul",[s("li",[t._v("通过增加 "),s("code",[t._v("-XX:MaxDirectMemorySize")]),t._v(" JVM 参数来调整 Direct Buffer Memory 的限制。")]),t._v(" "),s("li",[t._v("合理使用直接字节缓冲区、及时释放无用的缓冲区对象。")])]),t._v(" "),s("h3",{attrs:{id:"虚拟内存耗尽-out-of-swap-space"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚拟内存耗尽-out-of-swap-space"}},[t._v("#")]),t._v(" 虚拟内存耗尽 - Out of swap space")]),t._v(" "),s("p",[t._v("交换空间（Swap Space）是操作系统用于暂时存储物理内存中未被使用的页面的一部分磁盘空间。物理内存不足时，操作系统会将一些页面交换到磁盘上的交换空间，以释放物理内存供其他进程使用。")]),t._v(" "),s("div",{staticClass:"subtitle"},[s("p",[t._v("示例代码")])]),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 无")]),t._v("\n")])])]),s("div",{staticClass:"subtitle"},[s("p",[t._v("常见原因")])]),s("p",[t._v("该错误表示所有可用的 "),s("strong",[t._v("虚拟内存已被耗尽")]),t._v("。虚拟内存由物理内存和交换空间两部分组成。当运行时程序请求的虚拟内存溢出时就会抛出 "),s("code",[t._v("java.lang.OutOfMemoryError: Outof swap space")]),t._v(" 错误。")]),t._v(" "),s("ul",[s("li",[t._v("内存需求超过可用资源：应用程序需要的内存超过了操作系统可用的物理内存和交换空间的总和。")]),t._v(" "),s("li",[t._v("内存泄漏：应用程序存在内存泄漏，即分配的内存没有正确释放，持续占用内存而不释放，就会导致物理内存的消耗增加，最终耗尽交换空间。")]),t._v(" "),s("li",[t._v("进程泄漏：存在大量进程同时运行且每个进程都占用大量内存，超过了系统的总内存和交换空间大小。")])]),t._v(" "),s("div",{staticClass:"subtitle"},[s("p",[t._v("解决方案")])]),s("p",[t._v("根据错误原因可以采取如下解决方案：")]),t._v(" "),s("ul",[s("li",[t._v("增加交换空间：调整操作系统的交换空间设置，提供更多的虚拟内存供应用程序使用。")]),t._v(" "),s("li",[t._v("优化内存使用：检查应用程序的内存使用情况，找出内存泄漏或过度消耗内存的部分，并进行优化，以降低内存消耗。")])]),t._v(" "),s("h3",{attrs:{id:"oom-killer-被激活-kill-process-or-sacrifice-child"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#oom-killer-被激活-kill-process-or-sacrifice-child"}},[t._v("#")]),t._v(" OOM Killer 被激活 - Kill process or sacrifice child")]),t._v(" "),s("p",[t._v("有一种内核作业（Kernel Job）名为 Out of Memory Killer，它会在可用内存极低的情况下 “杀死”（kill）某些进程。OOM Killer 会对所有进程进行打分，然后将评分较低的进程 “杀死”，具体的评分规则可以参考 Surviving the Linux OOM Killer。")]),t._v(" "),s("p",[t._v("不同于其他的 OOM 错误， "),s("code",[t._v("Killprocessorsacrifice child")]),t._v(" 错误不是由 JVM 层面触发的，而是由操作系统层面触发的。")]),t._v(" "),s("div",{staticClass:"subtitle"},[s("p",[t._v("示例代码")])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("// 无\n")])])]),s("div",{staticClass:"subtitle"},[s("p",[t._v("常见原因")])]),s("p",[t._v("默认情况下，Linux 内核允许进程申请的内存总量大于系统可用内存，通过这种 “错峰复用” 的方式可以更有效的利用系统资源。")]),t._v(" "),s("p",[t._v("然而，这种方式会带来一定的 “超卖” 风险。例如某些进程持续占用系统内存，然后导致其他进程没有可用内存。此时，系统将自动激活 OOM Killer，寻找评分低的进程，并将其 “杀死”，释放内存资源。")]),t._v(" "),s("div",{staticClass:"subtitle"},[s("p",[t._v("解决方案")])]),s("ul",[s("li",[t._v("升级服务器配置或隔离部署，避免争用。")]),t._v(" "),s("li",[t._v("OOM Killer 调优。")])])])}),[],!1,null,null,null);a.default=n.exports}}]);