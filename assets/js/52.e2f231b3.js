(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{561:function(t,a,s){t.exports=s.p+"assets/img/image-20220611095412396.7135ecc5.png"},562:function(t,a,s){t.exports=s.p+"assets/img/image-20220611101005847.829cfe09.png"},563:function(t,a,s){t.exports=s.p+"assets/img/image-20220611102012615.026ee860.png"},981:function(t,a,s){"use strict";s.r(a);var e=s(14),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"第6章-存储器层次结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第6章-存储器层次结构"}},[t._v("#")]),t._v(" 第6章 存储器层次结构")]),t._v(" "),e("h2",{attrs:{id:"_6-1-存储技术"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-存储技术"}},[t._v("#")]),t._v(" 6.1 存储技术")]),t._v(" "),e("h3",{attrs:{id:"随机访问存储器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#随机访问存储器"}},[t._v("#")]),t._v(" 随机访问存储器")]),t._v(" "),e("p",[t._v("随机访问存储器（Random-Access Memory, RAM）分为两类：静态的和动态的。静态 RAM（SRAM）比动态 RAM（DRAM）更快，但贵得多。SRAM 用来作为高速缓存存储器。DRAM 用来作为主存以及图形系统的帧缓冲区。")]),t._v(" "),e("h4",{attrs:{id:"静态-ram"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#静态-ram"}},[t._v("#")]),t._v(" 静态 RAM")]),t._v(" "),e("p",[t._v("SRAM 将每个位存储在一个双稳态的（bistable）存储器单元里。每个单元是用一个六晶体管电路来实现的。这个电路有这样一个属性，它可以无限期地保持在两个不同的电压配置（configuration）或状态（state）之一。其他任何状态都是不稳定的，在不稳定状态时，电路会迅速转移到两个稳定状态的一个。")]),t._v(" "),e("p",[t._v("由于 SRAM 存储器单元的双稳态特性，只要有电，它就会永远地保持它的值。即使有干扰（例如电子噪音）来扰乱电压，当干扰消除时，电路就会恢复到稳定值。")]),t._v(" "),e("h4",{attrs:{id:"动态-ram"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#动态-ram"}},[t._v("#")]),t._v(" 动态 RAM")]),t._v(" "),e("p",[t._v("DRAM 将每个位存储为对一个电容的充电。DRAM 存储器可以制造得非常密集。每个单元由一个电容和一个访问晶体管组成。但是，与 SRAM 不同，DRAM 存储器单元对干扰非常敏感。当电容的电压被扰乱之后，它就永远不会恢复了。暴露在光线下会导致电容电压改变。")]),t._v(" "),e("p",[t._v("下表总结了SRAM和DRAM存储器的特性。只要有供电，SRAM 就会保持不变。与 DRAM 不同，它不需要刷新。SRAM 的存取比 DRAM快。SRAM 对诸如光和电噪声这样的干扰不敏感。代价是 SRAM 单元比 DRAM 单元使用更多的晶体管，因而密集度低，而且更贵，功耗更大。")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th"),t._v(" "),e("th",[t._v("每位"),e("br"),t._v("晶体管数")]),t._v(" "),e("th",[t._v("相对"),e("br"),t._v("访问时间")]),t._v(" "),e("th",[t._v("持续的")]),t._v(" "),e("th",[t._v("敏感的")]),t._v(" "),e("th",[t._v("相对花费")]),t._v(" "),e("th",[t._v("应用")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("SRAM")]),t._v(" "),e("td",[t._v("6")]),t._v(" "),e("td",[t._v("1X")]),t._v(" "),e("td",[t._v("是")]),t._v(" "),e("td",[t._v("否")]),t._v(" "),e("td",[t._v("1000X")]),t._v(" "),e("td",[t._v("高速缓存存储器")])]),t._v(" "),e("tr",[e("td",[t._v("DRAM")]),t._v(" "),e("td",[t._v("1")]),t._v(" "),e("td",[t._v("10X")]),t._v(" "),e("td",[t._v("否")]),t._v(" "),e("td",[t._v("是")]),t._v(" "),e("td",[t._v("1X")]),t._v(" "),e("td",[t._v("主存，帧缓冲区")])])])]),t._v(" "),e("h4",{attrs:{id:"传统的-dram"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#传统的-dram"}},[t._v("#")]),t._v(" 传统的 DRAM")]),t._v(" "),e("p",[t._v("DRAM 芯片中的单元（位）被分成 d 个超单元（supercell），每个超单元都由 w 个 DRAM 单元组成。一个 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("d")]),e("mo",[t._v("×")]),e("mi",[t._v("w")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("d \\times w")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.77777em","vertical-align":"-0.08333em"}}),e("span",{staticClass:"mord mathdefault"},[t._v("d")]),e("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}}),e("span",{staticClass:"mbin"},[t._v("×")]),e("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}})]),e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.43056em","vertical-align":"0em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02691em"}},[t._v("w")])])])])]),t._v(" 的 DRAM 总共存储了"),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("d")]),e("mi",[t._v("w")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("dw")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.69444em","vertical-align":"0em"}}),e("span",{staticClass:"mord mathdefault"},[t._v("d")]),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02691em"}},[t._v("w")])])])])]),t._v(" 位信息。超单元被组织成一个 r 行 c 列的长方形阵列，这里 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("r")]),e("mi",[t._v("c")]),e("mo",[t._v("=")]),e("mi",[t._v("d")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("rc=d")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.43056em","vertical-align":"0em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("r")]),e("span",{staticClass:"mord mathdefault"},[t._v("c")]),e("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2777777777777778em"}}),e("span",{staticClass:"mrel"},[t._v("=")]),e("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2777777777777778em"}})]),e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.69444em","vertical-align":"0em"}}),e("span",{staticClass:"mord mathdefault"},[t._v("d")])])])])]),t._v("。每个超单元有形如 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mo",{attrs:{stretchy:"false"}},[t._v("(")]),e("mi",[t._v("i")]),e("mo",{attrs:{separator:"true"}},[t._v(",")]),e("mi",[t._v("j")]),e("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("(i,j)")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),e("span",{staticClass:"mopen"},[t._v("(")]),e("span",{staticClass:"mord mathdefault"},[t._v("i")]),e("span",{staticClass:"mpunct"},[t._v(",")]),e("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.16666666666666666em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.05724em"}},[t._v("j")]),e("span",{staticClass:"mclose"},[t._v(")")])])])])]),t._v(" 的地址，这里 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("i")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("i")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.65952em","vertical-align":"0em"}}),e("span",{staticClass:"mord mathdefault"},[t._v("i")])])])])]),t._v(" 表示行，而 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("j")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("j")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.85396em","vertical-align":"-0.19444em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.05724em"}},[t._v("j")])])])])]),t._v(" 表示列。")],1),t._v(" "),e("p",[t._v("每个 DRAM 芯片被连接到某个称为内存控制器（memory controller）的电路，这个电路可以一次传送 w 位到每个 DRAM 芯片或一次从每个 DRAM 芯片传出 w 位。为了读出超单元 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mo",{attrs:{stretchy:"false"}},[t._v("(")]),e("mi",[t._v("i")]),e("mo",{attrs:{separator:"true"}},[t._v(",")]),e("mi",[t._v("j")]),e("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("(i,j)")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),e("span",{staticClass:"mopen"},[t._v("(")]),e("span",{staticClass:"mord mathdefault"},[t._v("i")]),e("span",{staticClass:"mpunct"},[t._v(",")]),e("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.16666666666666666em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.05724em"}},[t._v("j")]),e("span",{staticClass:"mclose"},[t._v(")")])])])])]),t._v(" 的内容，内存控制器将行地址 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("i")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("i")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.65952em","vertical-align":"0em"}}),e("span",{staticClass:"mord mathdefault"},[t._v("i")])])])])]),t._v(" 发送到 DRAM，然后是列地址 j。DRAM 把超单元"),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mo",{attrs:{stretchy:"false"}},[t._v("(")]),e("mi",[t._v("i")]),e("mo",{attrs:{separator:"true"}},[t._v(",")]),e("mi",[t._v("j")]),e("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("(i,j)")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),e("span",{staticClass:"mopen"},[t._v("(")]),e("span",{staticClass:"mord mathdefault"},[t._v("i")]),e("span",{staticClass:"mpunct"},[t._v(",")]),e("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.16666666666666666em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.05724em"}},[t._v("j")]),e("span",{staticClass:"mclose"},[t._v(")")])])])])]),t._v(" 的内容发回给控制器作为响应。行地址 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("i")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("i")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.65952em","vertical-align":"0em"}}),e("span",{staticClass:"mord mathdefault"},[t._v("i")])])])])]),t._v(" 称为 RAS（Row Access strobe，行访问选通脉冲）请求。列地址 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("j")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("j")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.85396em","vertical-align":"-0.19444em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.05724em"}},[t._v("j")])])])])]),t._v(" 称为 CAS（ Column Access strobe，列访问选通脉冲）请求。注意，RAS 和 CAS 请求共享相同的 DRAM 地址引脚。")],1),t._v(" "),e("p",[t._v("电路设计者将 DRAM 组织成二维阵列而不是线性数组的一个原因是降低芯片上地址引脚的数量。")]),t._v(" "),e("h4",{attrs:{id:"增强的-dram"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#增强的-dram"}},[t._v("#")]),t._v(" 增强的 DRAM")]),t._v(" "),e("p",[t._v("可以通过以下方式提高访问基本DRAM的速度。")]),t._v(" "),e("p",[t._v("快页模式 DRAM（ Fast Page Mode dram, FPM DRAM）。传统的 DRAM 将超单元的一整行复制到它的内部行缓冲区中，使用一个，然后丢弃剩余的。FPM DRAM 允许对同一行连续地访问可以直接从行缓冲区得到服务。")]),t._v(" "),e("p",[t._v("扩展数据输出 DRAM（ Extended Data Out Dram, EDO DRAM）。FPM DRAM的个增强的形式，它允许各个 CAS 信号在时间上靠得更紧密一点。")]),t._v(" "),e("p",[t._v("同步 DRAM（ Synchronous DRaM, SDRAM）。 SDRAM 用与驱动内存控制器相同的外部时钟信号的上升沿来代替许多这样的控制信号。最终效果就是 SDRAM 能够比那些异步的存储器更快地输出它的超单元的内容。")]),t._v(" "),e("p",[t._v("双倍数据速率同步 DRAM（ Double data- Rate SynchronouS DRAm, DDR SDRAM）。DDR SDRAM 是对 SDRAM 的一种增强，它通过使用两个时钟沿作为控制信号，从而使 DRAM 的速度翻倍。不同类型的 DDR SDRAM 是用提高有效带宽的很小的预取缓冲区的大小来划分的：DDR（2位）、DDR2（4位）和 DDR（8位）。")]),t._v(" "),e("p",[t._v("视频 RAM（Video ram,VRAM）。它用在图形系统的帧缓冲区中。VRAM 的思想与 FPM DRAM类似。两个主要区别是：VRAM的输出是通过依次对内部缓冲区的整个内容进行移位得到的；VRAM允许对内存并行地读和写。因此，系统可以在写下一次更新的新值（写）的同时，用帧缓冲区中的像素刷屏幕（读）。")]),t._v(" "),e("h4",{attrs:{id:"非易失性存储器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#非易失性存储器"}},[t._v("#")]),t._v(" 非易失性存储器")]),t._v(" "),e("p",[t._v("如果断电，DRAM 和 SRAM 会丢失它们的信息，从这个意义上说，它们是易失的（volatile）。另一方面，非易失性存储器（nonvolatile memory）即使是在关电后，仍然保存着它们的信息。")]),t._v(" "),e("p",[t._v("对 EPROM 编程是通过使用一种把 1 写入 EPROM 的特殊设备来完成的。EPROM 能够被擦除和重编程的次数的数量级可以达到 1000 次。EEPROM 能够被编程的次数的数量级可以达到 10 次。")]),t._v(" "),e("p",[t._v("闪存（flash memory）是一类非易失性存储器，基于 EEPROM，它已经成为了一种重要的存储技术。")]),t._v(" "),e("h4",{attrs:{id:"访问主存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#访问主存"}},[t._v("#")]),t._v(" 访问主存")]),t._v(" "),e("p",[t._v("数据流通过称为总线（bus）的共享电子电路在处理器和 DRAM 主存之间来来回回。每次 CPU 和主存之间的数据传送都是通过一系列步骤来完成的，这些步骤称为总线事务（bus transaction）。读事务（ read transaction）从主存传送数据到 CPU。写事务（write trans-action）从 CPU 传送数据到主存。")]),t._v(" "),e("p",[t._v("总线是一组并行的导线，能携带地址、数据和控制信号。取决于总线的设计，数据和地址信号可以共享同一组导线，也可以使用不同的。同时，两个以上的设备也能共享同一总线。控制线携带的信号会同步事务，并标识出当前正在被执行的事务的类型。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(561),alt:"image-20220611095412396"}})]),t._v(" "),e("p",[t._v("上图展示了一个示例计算机系统的配置。主要部件是 CPU 芯片、我们将称为 IO 桥接器（I/O bridge）的芯片组（其中包括内存控制器），以及组成主存的 DRAM 内存模块这些部件由一对总线连接起来，其中一条总线是系统总线（system bus），它连接 CPU 和 I/O 桥接器，另一条总线是内存总线（memory bus），它连接 I/O 桥接器和主存。I/O 桥接器将系统总线的电子信号翻译成内存总线的电子信号。")]),t._v(" "),e("h2",{attrs:{id:"_6-2-局部性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-局部性"}},[t._v("#")]),t._v(" 6.2 局部性")]),t._v(" "),e("p",[t._v("一个编写良好的计算机程序常常具有良好的局部性（locality）。也就是，它们倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身。这种倾向性，被称为"),e("strong",[t._v("局部性原理")]),t._v("（ principle of locality），是一个持久的概念，对硬件和软件系统的设计和性能都有着极大的影响。")]),t._v(" "),e("p",[t._v("局部性通常有两种不同的形式："),e("strong",[t._v("时间局部性")]),t._v("（temporal locality）和"),e("strong",[t._v("空间局部性")]),t._v("（spatial locality）。在一个具有良好时间局部性的程序中，被引用过一次的内存位置很可能在不远的将来再被多次引用。在一个具有良好空间局部性的程序中，如果一个内存位置被引用了次，那么程序很可能在不远的将来引用附近的一个内存位置。一般而言，有良好局部性的程序比局部性差的程序运行得更快。")]),t._v(" "),e("p",[t._v("如下所示的函数 sumvec，它对一个向量的元素求和。在这个例子中，变量 sum 在每次循环迭代中被引用一次，因此，对于 sum 来说，有好的时间局部性。另一方面，因为 sum 是标量，对于 sum 来说，没有空间局部性。")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("sumvec")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" v"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("N"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" sum "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" N"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        sum "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" v"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" sum"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("引用模式：")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("地址")]),t._v(" "),e("th",[t._v("0")]),t._v(" "),e("th",[t._v("4")]),t._v(" "),e("th",[t._v("8")]),t._v(" "),e("th",[t._v("12")]),t._v(" "),e("th",[t._v("16")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("内容")]),t._v(" "),e("td",[t._v("v0")]),t._v(" "),e("td",[t._v("v1")]),t._v(" "),e("td",[t._v("v2")]),t._v(" "),e("td",[t._v("v3")]),t._v(" "),e("td",[t._v("v4")])]),t._v(" "),e("tr",[e("td",[t._v("访问顺序")]),t._v(" "),e("td",[t._v("1")]),t._v(" "),e("td",[t._v("2")]),t._v(" "),e("td",[t._v("3")]),t._v(" "),e("td",[t._v("4")]),t._v(" "),e("td",[t._v("5")])])])]),t._v(" "),e("p",[t._v("如上所示，向量 v 的元素是被顺序读取的，一个接一个，按照它们存储在内存中的顺序（为了方便，我们假设数组是从地址 0 开始的）。因此，对于变量 v，函数有很好的空间局部性，但是时间局部性很差，因为每个向量元素只被访问一次。")]),t._v(" "),e("p",[t._v("步长为 1 的引用模式为"),e("strong",[t._v("顺序引用模式")]),t._v("（sequential reference pattern）。一个连续向量中，每隔 k 个元素进行访问，就称为步长为 k 的引用模式（stride-k reference pattern）。步长为 1 的引用模式是程序中空间局部性常见和重要的来源。一般而言，随着步长的增加，空间局部性下降。")]),t._v(" "),e("p",[t._v("如下的函数 sumarrayrows，它对一个二维数组的元素求和。双重嵌套循环按照行优先顺序（row major order）读数组的元素。也就是，内层循环读第一行的元素，然后读第二行，依此类推。函数 sumarrayrows 具有良好的空间局部性，因为它按照数组被存储的行优先顺序来访问这个数组。其结果是得到一个很好的步长为 1 的引用模式，具有良好的空间局部性。")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("sum_array_rows")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" a"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("M"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("N"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" j"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" sum "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" M"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("j "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" j "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" N"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" j"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n            sum "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" a"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("j"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" sum"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("引用模式：")]),t._v(" "),e("table",[e("thead",[e("tr",[e("th",[t._v("地址")]),t._v(" "),e("th",[t._v("0")]),t._v(" "),e("th",[t._v("4")]),t._v(" "),e("th",[t._v("8")]),t._v(" "),e("th",[t._v("12")]),t._v(" "),e("th",[t._v("16")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("内容")]),t._v(" "),e("td",[t._v("a00")]),t._v(" "),e("td",[t._v("a01")]),t._v(" "),e("td",[t._v("a02")]),t._v(" "),e("td",[t._v("a10")]),t._v(" "),e("td",[t._v("a11")])]),t._v(" "),e("tr",[e("td",[t._v("访问顺序")]),t._v(" "),e("td",[t._v("1")]),t._v(" "),e("td",[t._v("2")]),t._v(" "),e("td",[t._v("3")]),t._v(" "),e("td",[t._v("4")]),t._v(" "),e("td",[t._v("5")])])])]),t._v(" "),e("h2",{attrs:{id:"_6-3-存储器层次结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-存储器层次结构"}},[t._v("#")]),t._v(" 6.3 存储器层次结构")]),t._v(" "),e("p",[t._v("存储技术和计算机软件的一些基本的和持久的属性：")]),t._v(" "),e("p",[t._v("存储技术：不同存储技术的访问时间差异很大。速度较快的技术每字节的成本要比速度较慢的技术高，而且容量较小。CPU 和主存之间的速度差距在增大。")]),t._v(" "),e("p",[t._v("计算机软件：一个编写良好的程序倾向于展示出良好的局部性。")]),t._v(" "),e("p",[t._v("硬件和软件的这些基本属性互相补充得很完美。它们这种相互补充的性质使人想到一种组织存储器系统的方法，称为"),e("strong",[t._v("存储器层次结构")]),t._v("（ memory hierarchy），下图展示了一个典型的存储器层次结构。")]),t._v(" "),e("p",[e("img",{attrs:{src:s(562),alt:"image-20220611101005847"}})]),t._v(" "),e("p",[t._v("一般而言，从高层往底层走，存储设备变得更慢、更便宜和更大。在最高层（L0），是少量快速的 CPU 寄存器，CPU 可以在一个时钟周期内访问它们。接下来（L1~L3）是一个或多个小型到中型的基于 SRAM 的高速缓存存储器，可以在几个 CPU 时钟周期内访问它们。然后（L4）是一个大的基于 DRAM 的主存，可以在几十到几百个时钟周期内访问它们。接下来（L5）是慢速但是容量很大的本地磁盘。最后（L6），有些系统甚至包括了一层附加的远程服务器上的磁盘，要通过网络来访问它们。")]),t._v(" "),e("h3",{attrs:{id:"存储器结构中的缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#存储器结构中的缓存"}},[t._v("#")]),t._v(" 存储器结构中的缓存")]),t._v(" "),e("p",[t._v("一般而言，"),e("strong",[t._v("高速缓存（cache，读作 “cash”）")]),t._v(' 是一个小而快速的存储设备，它作为存储在更大、也更慢的设备中的数据对象的缓冲区域。使用高速缓存的过程称为缓存（caching，读作“ cashing"）。')]),t._v(" "),e("p",[t._v("存储器层次结构的中心思想是，位于 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("k")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("k")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.69444em","vertical-align":"0em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.03148em"}},[t._v("k")])])])])]),t._v(" 层的更快更小的存储设备作为位于 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("k")]),e("mo",[t._v("+")]),e("mn",[t._v("1")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("k+1")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.77777em","vertical-align":"-0.08333em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.03148em"}},[t._v("k")]),e("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}}),e("span",{staticClass:"mbin"},[t._v("+")]),e("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}})]),e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.64444em","vertical-align":"0em"}}),e("span",{staticClass:"mord"},[t._v("1")])])])])]),t._v(" 层的更大更慢的存储设备的缓存。换句话说，层次结构中的每一层都缓存来自较低一层的数据对象。")],1),t._v(" "),e("p",[e("img",{attrs:{src:s(563),alt:"image-20220611102012615"}})]),t._v(" "),e("p",[t._v("数据总是以块大小为传送单元（transfer unit）在第 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("k")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("k")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.69444em","vertical-align":"0em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.03148em"}},[t._v("k")])])])])]),t._v(" 层和第 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("k")]),e("mo",[t._v("+")]),e("mn",[t._v("1")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("k+1")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.77777em","vertical-align":"-0.08333em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.03148em"}},[t._v("k")]),e("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}}),e("span",{staticClass:"mbin"},[t._v("+")]),e("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}})]),e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.64444em","vertical-align":"0em"}}),e("span",{staticClass:"mord"},[t._v("1")])])])])]),t._v(" 层之间来回复制的。虽然在层次结构中任何一对相邻的层次之间块大小是固定的，但是其他的层次对之间可以有不同的块大小。")],1),t._v(" "),e("p",[t._v("L1 和 L0 之间的传送通常使用的是 1 个字大小的块。L2 和 L1 之间（以及 L3 和 L2 之间、L4 和 L3 之间）的传送通常使用的是几十个字节的块。而 L5 和 L4 之间的传送用的是大小为几百或几千字节的块。")]),t._v(" "),e("p",[t._v("一般而言，存储器层次结构中较低层（离 CPU 较远）的设备的访问时间较长，因此为了补偿这些较长的访问时间，倾向于使用较大的块。")]),t._v(" "),e("h4",{attrs:{id:"缓存命中"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存命中"}},[t._v("#")]),t._v(" 缓存命中")]),t._v(" "),e("p",[t._v("当程序需要第 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("k")]),e("mo",[t._v("+")]),e("mn",[t._v("1")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("k+1")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.77777em","vertical-align":"-0.08333em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.03148em"}},[t._v("k")]),e("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}}),e("span",{staticClass:"mbin"},[t._v("+")]),e("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}})]),e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.64444em","vertical-align":"0em"}}),e("span",{staticClass:"mord"},[t._v("1")])])])])]),t._v(" 层的某个数据对象 d 时，它首先在当前存储在第 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("k")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("k")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.69444em","vertical-align":"0em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.03148em"}},[t._v("k")])])])])]),t._v(" 层的一个块中查找 d。如果 d 刚好缓存在第 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("k")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("k")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.69444em","vertical-align":"0em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.03148em"}},[t._v("k")])])])])]),t._v(" 层中，那么就是我们所说的缓存命中（cache hit）。")],1),t._v(" "),e("h4",{attrs:{id:"缓存不命中"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存不命中"}},[t._v("#")]),t._v(" 缓存不命中")]),t._v(" "),e("p",[t._v("另一方面，如果第 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("k")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("k")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.69444em","vertical-align":"0em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.03148em"}},[t._v("k")])])])])]),t._v(" 层中没有缓存数据对象 d，那么就是我们所说的缓存不命中（cache miss）。当发生缓存不命中时，第 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("k")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("k")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.69444em","vertical-align":"0em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.03148em"}},[t._v("k")])])])])]),t._v(" 层的缓存从第 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("k")]),e("mo",[t._v("+")]),e("mn",[t._v("1")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("k+1")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.77777em","vertical-align":"-0.08333em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.03148em"}},[t._v("k")]),e("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}}),e("span",{staticClass:"mbin"},[t._v("+")]),e("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}})]),e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.64444em","vertical-align":"0em"}}),e("span",{staticClass:"mord"},[t._v("1")])])])])]),t._v(" 层缓存中取出包含 d 的那个块，如果第 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("k")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("k")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.69444em","vertical-align":"0em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.03148em"}},[t._v("k")])])])])]),t._v(" 层的缓存已经满了，可能就会覆盖现存的一个块。")],1),t._v(" "),e("p",[t._v("缓存的替换策略：随机替换替换策略、最少被使用（LRU）替换策略。")]),t._v(" "),e("h4",{attrs:{id:"缓存不命中种类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存不命中种类"}},[t._v("#")]),t._v(" 缓存不命中种类")]),t._v(" "),e("p",[t._v("区分不同种类的缓存不命中有时候是很有帮助的。如果第 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("k")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("k")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.69444em","vertical-align":"0em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.03148em"}},[t._v("k")])])])])]),t._v(" 层的缓存是空的，那么对任何数据对象的访问都会不命中。一个空的缓存有时被称为"),e("strong",[t._v("冷缓存")]),t._v("（cold cache），此类不命中称为"),e("strong",[t._v("强制性不命中")]),t._v("（compulsory miss）或"),e("strong",[t._v("冷不命中")]),t._v("（cold miss）。冷不命中很重要，因为它们通常是短暂的事件，不会在反复访问存储器使得缓存暖身（warmed up）之后的稳定状态中出现。")],1),t._v(" "),e("h4",{attrs:{id:"缓存管理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缓存管理"}},[t._v("#")]),t._v(" 缓存管理")]),t._v(" "),e("p",[t._v("存储器层次结构的本质是，每一层存储设备都是较低一层的缓存。在每一层上，某种形式的逻辑必须管理缓存。这里，我们的意思是指某个东西要将缓存划分成块，在不同的层之间传送块，判定是命中还是不命中，并处理它们。管理缓存的逻辑可以是硬件、软件，或是两者的结合。")]),t._v(" "),e("h2",{attrs:{id:"_6-4-高速缓存存储器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-高速缓存存储器"}},[t._v("#")]),t._v(" 6.4 高速缓存存储器")]),t._v(" "),e("h3",{attrs:{id:"高速缓存存储器结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#高速缓存存储器结构"}},[t._v("#")]),t._v(" 高速缓存存储器结构")]),t._v(" "),e("p",[t._v("// TODO")]),t._v(" "),e("h3",{attrs:{id:"有关写的问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#有关写的问题"}},[t._v("#")]),t._v(" 有关写的问题")]),t._v(" "),e("p",[t._v("高速缓存关于读的操作非常简单。首先，在高速缓存中查找所需字 w 的副本。如果命中，立即返回字 w 给 CPU。如果不命中，从存储器层次结构中较低层中取出包含字 w 的块，将这个块存储到某个高速缓存行中（可能会驱逐一个有效的行），然后返回字 w。")]),t._v(" "),e("p",[t._v("写的情况就要复杂一些了。假设我们要写一个已经缓存了的字 w（写命中， write hit）。在高速缓存更新它的 w 的副本之后，怎么更新 w 在层次结构中紧接着低一层中的副本呢？")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("直写")]),t._v("（write-through），就是立即将 w 的高速缓存块写回到紧接着的低一层中。虽然简单，但是直写的缺点是每次写都会引起总线流量。")]),t._v(" "),e("li",[e("strong",[t._v("写回")]),t._v("（write-back），尽可能地推迟更新，只有当替换算法要驱逐这个更新过的块时，才把它写到紧接着的低一层中。由于局部性，写回能够显著地减少总线流量，但是它的缺点是增加了复杂性。高速缓存必须为每个高速缓存行维护一个额外的修改位（dirty bit），表明这个高速缓存块是否被修改过。")])]),t._v(" "),e("p",[t._v("另一个问题是如何处理写不命中。")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("写分配")]),t._v("（write-allocate），加载相应的低一层中的块到高速缓存中，然后更新这个高速缓存块。写分配试图利用写的空间局部性，但是缺点是每次不命中都会导致一个块从低一层传送到高速缓存。")]),t._v(" "),e("li",[e("strong",[t._v("非写分配")]),t._v("（not- write-allocate），避开高速缓存，直接把这个字写到低一层中。直写高速缓存通常是非写分配的。写回高速缓存通常是写分配的。")])]),t._v(" "),e("p",[t._v("只保存指令的高速缓存称为 i-cache。只保存程序数据的高速缓存称为 d-cache。既保存指令又包括数据的高速缓存称为统一的高速缓存（unified cache）。")]),t._v(" "),e("p",[t._v("现代处理器包括独立的 i-cache 和 d-cache。这样做有很多原因。有两个独立的高速缓存，处理器能同时读一个指令字和一个数据字。")]),t._v(" "),e("p",[t._v("i-cache 通常是只读的，因此比较简单。")]),t._v(" "),e("p",[t._v("通常会针对不同的访问模式来优化这两个高速缓存，它们可以有不同的块大小、相联度和容量。使用不同的高速缓存也确保了数据访问不会与指令访问形成冲突不命中，反过来一样，代价就是可能会引起容量不命中增加。")]),t._v(" "),e("h2",{attrs:{id:"_6-5-编写高速缓存友好的代码"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-编写高速缓存友好的代码"}},[t._v("#")]),t._v(" 6.5 编写高速缓存友好的代码")]),t._v(" "),e("p",[t._v("确保代码高速缓存友好的基本方法：")]),t._v(" "),e("ul",[e("li",[t._v("让最常见的情况运行得快。程序通常把大部分时间都花在少量的核心函数上，而这些函数通常把大部分时间都花在了少量循环上。所以要把注意力集中在核心函数里的循环上，而忽略其他部分。")]),t._v(" "),e("li",[t._v("尽量减小每个循环内部的缓存不命中数量。在其他条件（例如加载和存储的总次数）相同的情况下，不命中率较低的循环运行得更快。")])]),t._v(" "),e("p",[t._v("考虑如下的函数")]),t._v(" "),e("div",{staticClass:"language-c extra-class"},[e("pre",{pre:!0,attrs:{class:"language-c"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("sumvec")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" v"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("N"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" sum "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" N"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" i"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        sum "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+=")]),t._v(" v"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" sum"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("首先，注意对于局部变量 i 和 sum，循环体有良好的时间局部性。现在考虑一下对向量 v 的步长为 1 的引用。一般而言，如果一个高速缓存的块大小为 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("B")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("B")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.68333em","vertical-align":"0em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.05017em"}},[t._v("B")])])])])]),t._v(" 字节，那么一个步长为 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("k")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("k")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.69444em","vertical-align":"0em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.03148em"}},[t._v("k")])])])])]),t._v(" 的引用模式（这里 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("k")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("k")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.69444em","vertical-align":"0em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.03148em"}},[t._v("k")])])])])]),t._v(" 是以字为单位的）平均每次循环迭代会有 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("min")]),e("mo",[t._v("⁡")]),e("mo",{attrs:{stretchy:"false"}},[t._v("(")]),e("mn",[t._v("1")]),e("mo",{attrs:{separator:"true"}},[t._v(",")]),e("mo",{attrs:{stretchy:"false"}},[t._v("(")]),e("mrow",[e("mi",{attrs:{mathvariant:"normal"}},[t._v("w")]),e("mi",{attrs:{mathvariant:"normal"}},[t._v("o")]),e("mi",{attrs:{mathvariant:"normal"}},[t._v("r")]),e("mi",{attrs:{mathvariant:"normal"}},[t._v("d")]),e("mi",{attrs:{mathvariant:"normal"}},[t._v("s")]),e("mi",{attrs:{mathvariant:"normal"}},[t._v("i")]),e("mi",{attrs:{mathvariant:"normal"}},[t._v("z")]),e("mi",{attrs:{mathvariant:"normal"}},[t._v("e")])],1),e("mo",[t._v("×")]),e("mi",[t._v("k")]),e("mo",{attrs:{stretchy:"false"}},[t._v(")")]),e("mi",{attrs:{mathvariant:"normal"}},[t._v("/")]),e("mi",[t._v("B")]),e("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("\\min (1,({\\rm wordsize} \\times k)/B)")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),e("span",{staticClass:"mop"},[t._v("min")]),e("span",{staticClass:"mopen"},[t._v("(")]),e("span",{staticClass:"mord"},[t._v("1")]),e("span",{staticClass:"mpunct"},[t._v(",")]),e("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.16666666666666666em"}}),e("span",{staticClass:"mopen"},[t._v("(")]),e("span",{staticClass:"mord"},[e("span",{staticClass:"mord"},[e("span",{staticClass:"mord mathrm",staticStyle:{"margin-right":"0.01389em"}},[t._v("w")]),e("span",{staticClass:"mord mathrm"},[t._v("o")]),e("span",{staticClass:"mord mathrm"},[t._v("r")]),e("span",{staticClass:"mord mathrm"},[t._v("d")]),e("span",{staticClass:"mord mathrm"},[t._v("s")]),e("span",{staticClass:"mord mathrm"},[t._v("i")]),e("span",{staticClass:"mord mathrm"},[t._v("z")]),e("span",{staticClass:"mord mathrm"},[t._v("e")])])]),e("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}}),e("span",{staticClass:"mbin"},[t._v("×")]),e("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}})]),e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.03148em"}},[t._v("k")]),e("span",{staticClass:"mclose"},[t._v(")")]),e("span",{staticClass:"mord"},[t._v("/")]),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.05017em"}},[t._v("B")]),e("span",{staticClass:"mclose"},[t._v(")")])])])])]),t._v(" 次缓存不命中。当 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("k")]),e("mo",[t._v("=")]),e("mn",[t._v("1")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("k=1")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.69444em","vertical-align":"0em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.03148em"}},[t._v("k")]),e("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2777777777777778em"}}),e("span",{staticClass:"mrel"},[t._v("=")]),e("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2777777777777778em"}})]),e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.64444em","vertical-align":"0em"}}),e("span",{staticClass:"mord"},[t._v("1")])])])])]),t._v(" 时，它取最小值，所以对 v 的步长为 1 的引用确实是高速缓存友好的。")],1),t._v(" "),e("p",[t._v("例如，假设 v 是块对齐的，字为 4 个字节，高速缓存块为 4 个字，而高速缓存初始为空（冷高速缓存）。在这个例子中，对 v[0] 的引用会不命中，而相应的包含v[0] ~ v[3] 的块会被从内存加载到高速缓存中。因此，接下来三个引用都会命中。对 v[4] 的引用会导致不命中，而个新的块被加载到高速缓存中，接下来的三个引用都命中，依此类推。总的来说，四个引用中，三个会命中，在这种冷缓存的情况下，这是我们所能做到的最好的情况了。")]),t._v(" "),e("p",[t._v("总之，简单的 sumvec 示例说明了两个关于编写高速缓存友好的代码的重要问题：")]),t._v(" "),e("ul",[e("li",[t._v("第一，对局部变量的反复引用是好的，因为编译器能够将它们缓存在寄存器文件中（时间局部性）。")]),t._v(" "),e("li",[t._v("第二，步长为 1 的引用模式是好的，因为存储器层次结构中所有层次上的缓存都是将数据存储为连续的块（空间局部性）。")])]),t._v(" "),e("p",[t._v("本章主要介绍了各种各样的存储系统及其原理，一般来说，较小、较快的设备在顶部，较大、较慢的设备在底部。因为编写良好的程序有好的局部性，大多数数据都可以从较高层得到服务，结果就是存储系统能以较高层的速度运行，但却有较低层的成本和容量。我们可以通过编写有良好空间和时间局部性的程序来显著地改进程序的运行时间。例如，可以利用基于 SRAM 的高速缓存存储器。主要原因是从高速缓存取数据的程序比主要从内存取数据的程序运行得快得多。")])])}),[],!1,null,null,null);a.default=n.exports}}]);