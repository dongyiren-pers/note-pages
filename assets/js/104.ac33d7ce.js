(window.webpackJsonp=window.webpackJsonp||[]).push([[104],{975:function(t,a,s){"use strict";s.r(a);var e=s(14),v=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"图-文-at-t汇编语法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#图-文-at-t汇编语法"}},[t._v("#")]),t._v(" 图 文 AT&T汇编语法")]),t._v(" "),s("h3",{attrs:{id:"先看一段代码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#先看一段代码"}},[t._v("#")]),t._v(" 先看一段代码")]),t._v(" "),s("p",[t._v("首先我们有这样一段 C 语言代码：")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token macro property"}},[s("span",{pre:!0,attrs:{class:"token directive-hash"}},[t._v("#")]),s("span",{pre:!0,attrs:{class:"token directive keyword"}},[t._v("include")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("<stdio.h>")])]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" msg"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("14")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Hello,world!\\n"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("puts")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("msg"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("运行 "),s("code",[t._v("gcc -S -Os hello.c")])]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('    .file   "hello.c"\n    .section    .text.startup,"ax",@progbits\n    .globl  main\n    .type   main, @function\nmain:\n.LFB0:\n    .cfi_startproc\n    pushq   %rax\n    .cfi_def_cfa_offset 16\n    movl    $msg, %edi\n    call    puts\n    xorl    %eax, %eax\n    popq    %rdx\n    .cfi_def_cfa_offset 8\n    ret\n    .cfi_endproc\n.LFE0:\n    .size   main, .-main\n    .globl  msg\n    .data\n    .align 8\n    .type   msg, @object\n    .size   msg, 14\nmsg:\n    .string "Hello,world!\\n"\n    .ident  "GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-39)"\n    .section    .note.GNU-stack,"",@progbits\n')])])]),s("p",[t._v("接下来解释下AT&T汇编语法。")]),t._v(" "),s("h3",{attrs:{id:"指令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#指令"}},[t._v("#")]),t._v(" 指令")]),t._v(" "),s("p",[t._v("指令是直接由CPU负责处理的命令，不以 "),s("code",[t._v(".")]),t._v(" 开头的行首缩进的行都是指令行。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("movl    $msg, %edi\ncall    puts\nxorl    %eax, %eax\n")])])]),s("p",[t._v("指令由操作符和作为参数的操作数组成，以 "),s("code",[t._v("movl $msg, %edi")]),t._v(" 为例，"),s("code",[t._v("movl")]),t._v(" 为操作符， "),s("code",[t._v("$msg")]),t._v(" 和 "),s("code",[t._v("%edi")]),t._v(" 为操作数，操作数以逗号来间隔。")]),t._v(" "),s("h3",{attrs:{id:"汇编伪操作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#汇编伪操作"}},[t._v("#")]),t._v(" 汇编伪操作")]),t._v(" "),s("p",[t._v("以 "),s("code",[t._v(".")]),t._v(" 开头末尾没有"),s("code",[t._v(":")]),t._v("的行都是汇编伪操作。例如，"),s("code",[t._v('.file "hello.c"')]),t._v("，"),s("code",[t._v(".globl main")]),t._v("。汇编伪操作是由汇编器而非CPU处理的指令。一般用于在目标文件中记录元数据（meta data）或者设定指定的属性等。例如 "),s("code",[t._v(".string")]),t._v(" 是用来定义字符串常量的汇编伪操作。")]),t._v(" "),s("h3",{attrs:{id:"标签"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#标签"}},[t._v("#")]),t._v(" 标签")]),t._v(" "),s("p",[t._v("以冒号"),s("code",[t._v(":")]),t._v(" 结尾的行都是标签行，例如："),s("code",[t._v(".LFB0:")]),t._v("，"),s("code",[t._v("main:")]),t._v("。 标签具有为汇编伪操作生成的数据或者指令命名（标上符号）的功能，这样就可以在其他地方调用通过标签定义的符号。 标签可以以 "),s("code",[t._v(".")]),t._v(" 开头")]),t._v(" "),s("h3",{attrs:{id:"注释"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#注释"}},[t._v("#")]),t._v(" 注释")]),t._v(" "),s("p",[t._v("支持两种注释：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("# xxx\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("/* xxx\nxxx */\n")])])]),s("h3",{attrs:{id:"操作符后缀"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#操作符后缀"}},[t._v("#")]),t._v(" 操作符后缀")]),t._v(" "),s("p",[t._v("刚才提到的 "),s("code",[t._v("movl")]),t._v(" 和 "),s("code",[t._v("subl")]),t._v(" 为操作符，更准确的说 "),s("code",[t._v("mov")]),t._v(" 和 "),s("code",[t._v("sub")]),t._v(" 为操作符，末尾的 "),s("code",[t._v("l")]),t._v(" 是后缀，"),s("code",[t._v("l")]),t._v(" 是 "),s("code",[t._v("long")]),t._v(" 的缩写，表示操作对象的数据大小。类似这样的后缀还有"),s("code",[t._v("b")]),t._v("、"),s("code",[t._v("w")]),t._v("、"),s("code",[t._v("l")]),t._v("。")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("后缀")]),t._v(" "),s("th",[t._v("操作对象的大小")]),t._v(" "),s("th",[t._v("缩写")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("b")]),t._v(" "),s("td",[t._v("8位")]),t._v(" "),s("td",[t._v("byte")])]),t._v(" "),s("tr",[s("td",[t._v("w")]),t._v(" "),s("td",[t._v("16位")]),t._v(" "),s("td",[t._v("word")])]),t._v(" "),s("tr",[s("td",[t._v("l")]),t._v(" "),s("td",[t._v("32位")]),t._v(" "),s("td",[t._v("long")])])])]),t._v(" "),s("h3",{attrs:{id:"操作数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#操作数"}},[t._v("#")]),t._v(" 操作数")]),t._v(" "),s("p",[t._v("操作数有四种： 1. 立即数 2. 寄存器 3. 直接内存引用 4. 间接内存引用")]),t._v(" "),s("p",[s("strong",[t._v("1. 立即数")])]),t._v(" "),s("p",[t._v("立即数就是 C 语言中的字面量，机器语言中立即数以整数的形式出现，能高速访问。像 "),s("code",[t._v("$27")]),t._v(" 这样，立即数用 "),s("code",[t._v("$")]),t._v(" 来标识，如果没有 "),s("code",[t._v("$")]),t._v(" 就成了直接内存引用。立即数有8位，16位，32位。")]),t._v(" "),s("p",[s("strong",[t._v("2. 寄存器")])]),t._v(" "),s("p",[t._v("GUN汇编器规定寄存器以 "),s("code",[t._v("%")]),t._v(" 开头，例如 eax 寄存器写作 "),s("code",[t._v("%eax")]),t._v("。")]),t._v(" "),s("p",[s("strong",[t._v("3. 直接内存引用")])]),t._v(" "),s("p",[t._v("直接访问固定内存地址的方式。GNC汇编器会将任何整数解释为内存地址并访问。比起使用数字，更常用符号（symbol）直接访问内存。例如"),s("code",[t._v(".LFE0")]),t._v("就是访问符号"),s("code",[t._v(".LFE0")]),t._v("所指向的地址。符号在汇编和链接的过程中会被置换为实际内存地址。")]),t._v(" "),s("p",[s("strong",[t._v("4. 间接内存引用")])]),t._v(" "),s("p",[t._v("是将寄存器的值作为内存地址访问的方式。间接内存引用中最通用的就是下方的形式：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("disp(base, index, scale)\n")])])]),s("p",[t._v("其中任何一者都可以省略。")]),t._v(" "),s("p",[t._v("上述指令访问 disp + (base + index * scale)的地址。 下面详细讲解，首先最简单的间接引用的形式如下：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("(%eax)\n")])])]),s("p",[t._v("即只指定基地址（base）的形式。上述表达式将 eax 寄存器中的值作为内存地址访问。 接着带有 disp 的形式如下。disp 是displacement（偏移）的简称。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("4(%eax)\n")])])]),s("p",[t._v("上述就是访问 "),s("code",[t._v("4 + (eax寄存器中值)")]),t._v(" 这个内存地址。在 C 语言中用来访问如下结构体中成员 y 的情况：")]),t._v(" "),s("div",{staticClass:"language-c extra-class"},[s("pre",{pre:!0,attrs:{class:"language-c"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("point")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// x 占 4 个字节，即 4 个内存地址")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" y"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),s("p",[t._v("最后使用 index 和 scale 的情况如下所示：")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("(%ebx, %eax, 4)\n")])])]),s("p",[t._v("示例访问的就是（ebx寄存器中的值 + eax寄存器中的值 * 4）内存地址。")]),t._v(" "),s("p",[t._v("在 C 语言中用来访问数组，例如访问元素大小为 4 字节的数组中元素的第 %ebx 个元素时就可以用这种方式。当并非所有的数组访问都可以只靠间接内存引用来表示，因为 scale 只能是 1、2、4、8 之一。")])])}),[],!1,null,null,null);a.default=v.exports}}]);