(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{1089:function(e,t,s){"use strict";s.r(t);var a=s(14),v=Object(a.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"第7章-redis-集群"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第7章-redis-集群"}},[e._v("#")]),e._v(" 第7章 Redis 集群")]),e._v(" "),a("h2",{attrs:{id:"_7-1-主从模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-主从模式"}},[e._v("#")]),e._v(" 7.1 主从模式")]),e._v(" "),a("p",[e._v("主从模式至少需要两台 Redis 服务器，一台主节点（Master）、一台从节点（Slave），组成主从模式的 Redis 集群。通常来说，Master 主要负责写，Slave 主要负责读，主从模式实现了读写分离。")]),e._v(" "),a("div",{staticStyle:{"text-align":"center"}},[a("img",{staticStyle:{zoom:"67%"},attrs:{src:s(882),alt:"image-20230205152052134"}})]),a("p",[e._v("集群中有多台 Redis 节点，就必须保证每个节点中的数据是一致的。Redis 中，为了保持数据一致性，数据总是从 Master 复制到 Slave，这就是 Redis 的 "),a("strong",[e._v("主从复制")]),e._v("。")]),e._v(" "),a("h3",{attrs:{id:"主从同步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主从同步"}},[e._v("#")]),e._v(" 主从同步")]),e._v(" "),a("h4",{attrs:{id:"初次同步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#初次同步"}},[e._v("#")]),e._v(" 初次同步")]),e._v(" "),a("p",[a("img",{attrs:{src:s(883),alt:"image-20230809201521328"}})]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("Slave 发送同步请求")]),e._v("：Slave 服务器向 Master 发送 psync 命令（此时发送的是 psync ? -1），告诉 Master 需要同步数据。")]),e._v(" "),a("li",[a("strong",[e._v("Master 生成并发送 RDB 快照")]),e._v("：Master 接收到 psync 命令后会进行 BGSAVE 命令生成 RDB 文件快照并发送给 Slave。")]),e._v(" "),a("li",[a("strong",[e._v("Slave 载入 RDB 快照")]),e._v("：Slave 接收到文件载入 RDB 快照，并且将数据库状态变更为 Master 在执行 BGSAVE 时的状态一致。")]),e._v(" "),a("li",[a("strong",[e._v("Master 发送缓冲区内增量写命令")]),e._v("：Master 发送保存在缓冲区里的增量写命令，告诉 Slave 可以进行同步了。")]),e._v(" "),a("li",[a("strong",[e._v("Slave 载入增量命令")]),e._v("。")])]),e._v(" "),a("h4",{attrs:{id:"命令传播"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#命令传播"}},[e._v("#")]),e._v(" 命令传播")]),e._v(" "),a("p",[e._v("slave 已经同步过 master 了，那么如果后续 master 进行了写操作，比如说一个简单的 set name Redis，那么 master 执行过当前命令后，会将当前命令发送给 slave 执行一遍，达成数据一致性。")]),e._v(" "),a("h4",{attrs:{id:"重新同步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#重新同步"}},[e._v("#")]),e._v(" 重新同步")]),e._v(" "),a("div",{staticStyle:{"text-align":"center"}},[a("img",{staticStyle:{zoom:"67%"},attrs:{src:s(884),alt:"image-20230226151848553"}})]),a("ul",[a("li",[e._v("当 Slave 断开重连后，会发送 psync 命令给 Master。")]),e._v(" "),a("li",[e._v("Master 首先会对服务器 "),a("strong",[e._v("运行 id")]),e._v("（runid）进行判断，如果与自己相同就进行判断偏移量。")]),e._v(" "),a("li",[e._v("Master 会判断自己的 "),a("strong",[e._v("偏移量")]),e._v(" 与 Slave 的偏移量是否一致。")]),e._v(" "),a("li",[e._v("如果不一致，Master 会去缓冲区中判断 Slave 的 "),a("strong",[e._v("偏移量之后的数据是否存在")]),e._v("。")]),e._v(" "),a("li",[e._v("如果存在就会返回 +continue 回复，表示 Slave 可以执行部分同步了。")]),e._v(" "),a("li",[e._v("Master 发送断线后的写命令给 Slave。")]),e._v(" "),a("li",[e._v("Slave 执行写命令。")])]),e._v(" "),a("h2",{attrs:{id:"_7-2-哨兵模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-哨兵模式"}},[e._v("#")]),e._v(" 7.2 哨兵模式")]),e._v(" "),a("p",[e._v("哨兵模式（Sentinel）是 Redis 的高可用实现方案，它可以实现对 Redis 的监控、通知和自动故障转移，当 Redis Master 挂掉之后，可以自动拉起 Slave 提供业务，从而实现 Redis 的高可用。为了避免 Sentinel 本身出现单点故障，Sentinel 自己可采用集群模式。")]),e._v(" "),a("p",[a("img",{attrs:{src:s(885),alt:"image-20230205160605629"}})]),e._v(" "),a("h3",{attrs:{id:"监控和故障转移"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#监控和故障转移"}},[e._v("#")]),e._v(" 监控和故障转移")]),e._v(" "),a("p",[e._v("Sentinel 是一种特殊的 Redis 节点，每个 Sentinel 节点会维护与其他 Redis 节点（包括 Master/Slave/Sentinel）的心跳。")]),e._v(" "),a("p",[e._v("当一个 Sentinel 节点与 Master 节点的心跳丢失时，这个 Sentinel 节点就会认为 Master 节点出现了故障，处于不可用的状态，这种判定叫作 "),a("strong",[e._v("主观下线")]),e._v("（即 Sentinel 节点自己主观认为 Master 下线了）")]),e._v(" "),a("p",[e._v("之后，这个 Sentinel 节点会与其他 Sentinel 节点交换信息，如果发现认为主节点发生故障的 Sentinel 节点的个数超过了某个阈值（通常为 Sentinel 节点总数的 1/2 + 1，即超过半数），则 Sentinel 会认为 Master 节点已经处于 "),a("strong",[e._v("客观下线")]),e._v(" 的状态，即大家都认为 Master 故障不可用了。")]),e._v(" "),a("p",[e._v("之后，Sentinel 节点中会选举出一个 Sentinel leader 来执行 Redis 主节点的故障转移。")]),e._v(" "),a("p",[e._v("被选举出的 Sentinel 领导者进行故障转移的具体步骤如下：")]),e._v(" "),a("ul",[a("li",[e._v("在从节点列表中选出一个节点作为新的主节点。")]),e._v(" "),a("li",[e._v("Sentinel 领导者节点会对选出来的从节点执行 slaveof no one 命令让其成为主节点。")]),e._v(" "),a("li",[e._v("Sentinel 领导者节点会向剩余的从节点发送命令，让他们从新的主节点上复制数据。")]),e._v(" "),a("li",[e._v("Sentinel 领导者会将原来的主节点更新为从节点， 并对其进行监控， 当其恢复后命令它去复制新的主节点。")])]),e._v(" "),a("h2",{attrs:{id:"_7-3-集群模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-3-集群模式"}},[e._v("#")]),e._v(" 7.3 集群模式")]),e._v(" "),a("p",[e._v("主从模式实现了数据的热备份，哨兵模式实现了 Redis 的高可用。但是有一个问题，这两种模式都只能有一个 Master 节点负责写操作，在高并发的写操作场景，Master 节点就会成为性能瓶颈。")]),e._v(" "),a("p",[e._v("Redis 的集群模式（Cluster）中可以实现多个节点同时提供写操作，Redis 集群模式采用无中心结构，每个节点都保存数据，节点之间互相连接从而知道整个集群状态。")]),e._v(" "),a("h3",{attrs:{id:"数据分片"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据分片"}},[e._v("#")]),e._v(" 数据分片")]),e._v(" "),a("p",[e._v("Redis Cluster 方案采用哈希槽（Hash Slot），来处理数据和节点之间的映射关系。在 Redis Cluster 方案中，"),a("strong",[e._v("一个切片集群共有 16384 个哈希槽")]),e._v("，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中，具体执行过程分为两大步：")]),e._v(" "),a("ul",[a("li",[e._v("根据键值对的 key，按照 CRC16 算法计算一个 16 bit 的值。")]),e._v(" "),a("li",[e._v("再用 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。")])]),e._v(" "),a("h3",{attrs:{id:"主从复制和冷备节点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主从复制和冷备节点"}},[e._v("#")]),e._v(" 主从复制和冷备节点")]),e._v(" "),a("p",[e._v("Redis Custer 引入了主从复制模型，一个主节点对应一个或者多个从节点，当主节点宕机时，就会启用从节点。当其它主节点 ping 一个主节点 A，如果半数以上主节点与 A 通信超时，就认为主节点 A 宕机了。")]),e._v(" "),a("p",[a("img",{attrs:{src:s(886),alt:"image-20230206120407474"}})]),e._v(" "),a("p",[e._v("Slave 节点只是一个冷备节点，不提供分担读操作的压力。")])])}),[],!1,null,null,null);t.default=v.exports},882:function(e,t,s){e.exports=s.p+"assets/img/image-20230205152052134.6e9eddc6.png"},883:function(e,t,s){e.exports=s.p+"assets/img/image-20230809201521328.3ba27499.png"},884:function(e,t,s){e.exports=s.p+"assets/img/image-20230226151848553.e94a1e0e.png"},885:function(e,t,s){e.exports=s.p+"assets/img/image-20230205160605629.627907aa.png"},886:function(e,t,s){e.exports=s.p+"assets/img/image-20230206120407474.9c6e6cd3.png"}}]);