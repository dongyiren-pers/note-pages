(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{1093:function(r,e,a){"use strict";a.r(e);var v=a(14),t=Object(v.a)({},(function(){var r=this,e=r.$createElement,v=r._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[v("h1",{attrs:{id:"第2章-rocketmq-架构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第2章-rocketmq-架构"}},[r._v("#")]),r._v(" 第2章 RocketMQ 架构")]),r._v(" "),v("p",[r._v("RocketMQ 主要有四大核心组成部分："),v("strong",[r._v("NameServer")]),r._v("、"),v("strong",[r._v("Broker")]),r._v("、"),v("strong",[r._v("Producer")]),r._v(" 以及 "),v("strong",[r._v("Consumer")]),r._v(" 四部分。")]),r._v(" "),v("p",[v("img",{attrs:{src:a(887),alt:"在这里插入图片描述"}})]),r._v(" "),v("h2",{attrs:{id:"_2-1-名称服务器-nameserver"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-名称服务器-nameserver"}},[r._v("#")]),r._v(" 2.1 名称服务器 NameServer")]),r._v(" "),v("p",[r._v("NameServer 是整个 RocketMQ 的 “大脑” ，它是 RocketMQ 的服务注册中心，因此，RocketMQ 需要先启动 NameServer 再启动 Rocket 中的 Broker。")]),r._v(" "),v("blockquote",[v("p",[r._v("RocketMQ 的思想来自于 Kafka，而 Kafka 是依赖了 Zookeeper 的。所以，在 RocketMQ 的早期版本，即在 MetaQ v1.0 与 v2.0 版本中，也是依赖于 Zookeeper 的。从 MetaQ v3.0，使用自己的 NameServer。")])]),r._v(" "),v("h3",{attrs:{id:"nameserver-功能"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#nameserver-功能"}},[r._v("#")]),r._v(" NameServer 功能")]),r._v(" "),v("p",[r._v("名称服务器（NameServer）用来保存 Broker 相关元信息并为 Producer 和 Consumer 查找 Broker 信息。NameServer 被设计成几乎 "),v("strong",[r._v("无状态")]),r._v(" 的，可以横向扩展，节点之间相互之间无通信，通过部署多台机器来标记自己是一个伪集群。")]),r._v(" "),v("p",[r._v("每个 Broker 在启动的时候会到 NameServer 注册，Producer 在发送消息前会根据 Topic 到 NameServer 获取到 Broker 的路由信息，进而和 Broker 取得连接。Consumer 同样会定时获取 Topic 的路由信息。")]),r._v(" "),v("h3",{attrs:{id:"与-zookeeper-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#与-zookeeper-的区别"}},[r._v("#")]),r._v(" 与 ZooKeeper 的区别")]),r._v(" "),v("p",[r._v("NameServer 和 ZooKeeper 的作用大致是相同的，从宏观上来看，NameServer 做的东西很少，就是保存一些运行数据，"),v("strong",[r._v("NameServer之间不互连，这就需要 Broker 端连接所有的 NameServer")]),r._v("，运行数据的改动要发送到每一个 NameServer 来保证运行数据的一致性，这样就变成了 NameServer 很轻量级，但是 Broker 端就要做更多的东西了。")]),r._v(" "),v("p",[r._v("而 ZooKeeper，Broker 只需要连接其中的一台机器，运行数据分发、一致性都交给 ZooKeeper 来完成。")]),r._v(" "),v("h3",{attrs:{id:"工作流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#工作流程"}},[r._v("#")]),r._v(" 工作流程")]),r._v(" "),v("p",[v("strong",[r._v("路由注册")]),r._v("：Broker 节点启动时，轮询 NameServer 列表，与每个 NameServer 节点建立长连接，发起注册请求。在 NameServer 内部维护着⼀个 Broker 列表，用来动态存储 Broker 的信息。")]),r._v(" "),v("p",[v("strong",[r._v("路由剔除")]),r._v("：NameServer 中有⼀个定时任务，每隔 10 秒就会扫描⼀次 Broker 表，查看每一个 Broker 的最新心跳时间戳距离当前时间是否超过 120 秒，如果超过，则会判定 Broker 失效，然后将其从 Broker 列表中剔除。")]),r._v(" "),v("p",[v("strong",[r._v("路由发现")]),r._v("：RocketMQ 的路由发现采用的是 Pull 模型。当 Topic 路由信息出现变化时，NameServer 不会主动推送给客户端，而是客户端定时拉取主题最新的路由。默认客户端每 30 秒会拉取一次最新的路由。")]),r._v(" "),v("h2",{attrs:{id:"_2-2-消息服务器-broker"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-消息服务器-broker"}},[r._v("#")]),r._v(" 2.2 消息服务器 Broker")]),r._v(" "),v("p",[r._v("消息服务器（Broker）是消息存储中心，主要功能是接收来自 Producer 的消息并存储，Consumer 从这里取得消息。它还存储与消息相关的元数据，包括用户组、消费进度偏移量、队列信息等。")]),r._v(" "),v("p",[r._v("从部署结构图中可以看出 Broker 有 Master 和 Slave 两种类型，"),v("strong",[r._v("Master 既可以写又可以读，Slave 不可以写只可以读")]),r._v("。")]),r._v(" "),v("h3",{attrs:{id:"主备集群"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主备集群"}},[r._v("#")]),r._v(" 主备集群")]),r._v(" "),v("p",[r._v("Broker 节点集群是一个 "),v("strong",[r._v("主备集群")]),r._v("，即集群中具有 Master 与 Slave 两种角色。Master 负责处理读写操作请求，Slave 负责对 Master 中的数据进行备份。当 Master 挂掉了，Slave 则会自动切换为 Master 去工作。Master 和 Slave 是 1:N 的关系。")]),r._v(" "),v("p",[r._v("Master 与 Slave 的对应关系 "),v("strong",[r._v("通过指定相同的 Broker Name，不同的 BrokerId 来定义")]),r._v("，BrokerId 为 0 表 Master，非 0 表示 Slave。")]),r._v(" "),v("p",[r._v("从物理结构上看 Broker 的集群部署方式有四种：单 Master 、多 Master 、多 Master 多 Slave（异步复制）、多 Master 多 Slave（同步双写）。")]),r._v(" "),v("div",{staticClass:"subtitle"},[v("p",[r._v("单 Master")])]),v("p",[r._v("一旦 Broker 重启或宕机会导致整个服务不可用，这种方式风险较大，所以显然不建议线上环境使用。")]),r._v(" "),v("div",{staticClass:"subtitle"},[v("p",[r._v("多 Master")])]),v("p",[r._v("所有消息服务器都是 Master ，没有 Slave 。这种方式优点是配置简单，单个 Master 宕机或重启维护对应用无影响。缺点是单台机器宕机期间，该机器上未被消费的消息在机器恢复之前不可订阅，消息实时性会受影响。")]),r._v(" "),v("div",{staticClass:"subtitle"},[v("p",[r._v("多 Master 多 Slave（异步复制）")])]),v("p",[r._v("每个 Master 配置一个 Slave，有多对 Master-Slave，消息采用 "),v("strong",[r._v("异步复制")]),r._v(" 方式，主备之间有毫秒级消息延迟。这种方式优点是消息丢失的非常少，且消息实时性不会受影响，Master 宕机后消费者可以继续从 Slave 消费，中间的过程对用户应用程序透明，不需要人工干预，性能同多 Master 方式几乎一样。缺点是 Master 宕机时在磁盘损坏情况下会丢失极少量消息。")]),r._v(" "),v("div",{staticClass:"subtitle"},[v("p",[r._v("多 Master 多 Slave（同步双写）")])]),v("p",[r._v("每个 Master 配置一个 Slave，有多对 Master-Slave ，消息采用 "),v("strong",[r._v("同步双写")]),r._v(" 方式，主备都写成功才返回。这种方式优点是数据与服务都没有单点问题，Master 宕机时消息无延迟，服务与数据的可用性非常高。缺点是性能相对异步复制方式略低，发送消息的延迟会略高。")]),r._v(" "),v("h3",{attrs:{id:"工作流程-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#工作流程-2"}},[r._v("#")]),r._v(" 工作流程")]),r._v(" "),v("p",[r._v("每个 Broker 与 NameServer 集群中的所有节点建立长连接，"),v("strong",[r._v("定时（每隔 30s）注册 Topic 信息到所有 NameServer")]),r._v("。NameServer 定时（每隔 10s）扫描所有存活 Broker 的连接，如果 NameServer 超过 2 分钟没有收到心跳，则 NameServer 断开与 Broker 的连接。")]),r._v(" "),v("h3",{attrs:{id:"刷盘策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#刷盘策略"}},[r._v("#")]),r._v(" 刷盘策略")]),r._v(" "),v("p",[v("strong",[r._v("同步刷盘")]),r._v("：在消息达到 Broker 的内存之后，必须刷到 commitLog 日志文件中才算成功，然后返回 Producer 数据已经发送成功。")]),r._v(" "),v("p",[v("strong",[r._v("异步刷盘")]),r._v("：异步刷盘是指消息达到 Broker 内存（PageCache）后就返回 Producer 数据已经发送成功，会唤醒一个线程去将数据持久化到 CommitLog 日志文件中。")]),r._v(" "),v("p",[r._v("同步刷盘保证了消息不丢失，但是响应时间相对异步刷盘要多出 10%左右，适用于对消息可靠性要求比较高的场景。异步刷盘的吞吐量比较高，RT 小，但是如果 Broker 断电了内存中的部分数据会丢失，适用于对吞吐量要求比较高的场景。")]),r._v(" "),v("h2",{attrs:{id:"_2-3-生产者-producer"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-生产者-producer"}},[r._v("#")]),r._v(" 2.3 生产者 Producer")]),r._v(" "),v("p",[r._v("消息生产者，负责生产消息。Producer 通过 MQ 的负载均衡模块选择相应的 Broker 集群队列进行消息投递，投递的过程支持快速失败并且低延迟。")]),r._v(" "),v("h3",{attrs:{id:"发送范例"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#发送范例"}},[r._v("#")]),r._v(" 发送范例")]),r._v(" "),v("p",[r._v("RocketMQ 提供了发送 "),v("strong",[r._v("同步、异步和单向（one-way）")]),r._v(" 的多种范例。")]),r._v(" "),v("div",{staticClass:"subtitle"},[v("p",[r._v("同步发送")])]),v("p",[r._v("同步发送指消息发送方发出数据后会在收到接收方发回响应之后才发下一个数据包。")]),r._v(" "),v("p",[r._v("一般用于重要通知消息，例如重要通知邮件、营销短信。")]),r._v(" "),v("div",{staticClass:"subtitle"},[v("p",[r._v("异步发送")])]),v("p",[r._v("异步发送指发送方发出数据后，不等接收方发回响应，接着发送下个数据包。假如过一段时间检测到某个信息发送失败，可以选择重新发送。")]),r._v(" "),v("p",[r._v("一般用于可能链路耗时较长而对响应时间敏感的业务场景，例如用户视频上传后通知启动转码服务。")]),r._v(" "),v("div",{staticClass:"subtitle"},[v("p",[r._v("单向发送")])]),v("p",[r._v("单向发送是指只负责发送消息而不等待服务器回应且没有回调函数触发。")]),r._v(" "),v("p",[r._v("适用于某些耗时非常短但对可靠性要求并不高的场景，例如日志收集。")]),r._v(" "),v("h3",{attrs:{id:"生产者组"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#生产者组"}},[r._v("#")]),r._v(" 生产者组")]),r._v(" "),v("p",[r._v("RocketMQ 中的消息生产者都是以生产者组（Producer Group）的形式出现的。生产者组是同一类生产者的集合，这类 Producer 发送相同 Topic 类型的消息。一个生产者组可以同时发送多个主题的消息。")]),r._v(" "),v("h3",{attrs:{id:"工作流程-3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#工作流程-3"}},[r._v("#")]),r._v(" 工作流程")]),r._v(" "),v("p",[r._v("Producer 与 NameServer 集群中的其中一个节点（随机选择）建立长连接，定期从 NameServer 取 Topic 路由信息，并向提供 Topic 服务的 Master 建立长连接，且定时向 Master 发送心跳。Producer 完全无状态，可集群部署。")]),r._v(" "),v("p",[v("strong",[r._v("Producer 每隔 30s（由 ClientConfig 的 pollNameServerInterval 决定）从 NameServer 获取所有 Topic 队列的最新情况")]),r._v("，这意味着 Broker 不可用时，Producer 最多最需要 30s 才能感知，在此期间内发往 Broker 的所有消息都会失败。")]),r._v(" "),v("p",[v("strong",[r._v("Producer 每隔 30s（由 ClientConfig 中 heartbeatBrokerInterval 决定）向所有关联的 Broker 发送心跳")]),r._v("，Broker 每隔 10s 中扫描所有存活的连接，如果 Broker 在 2 分钟内没有收到心跳数据，则关闭与 Producer 的连接。")]),r._v(" "),v("h2",{attrs:{id:"_2-4-消费者-consumer"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-消费者-consumer"}},[r._v("#")]),r._v(" 2.4 消费者 Consumer")]),r._v(" "),v("p",[r._v("消息消费者，负责消费消息。一个消息消费者会从 Broker 服务器中获取到消息，并对消息进行相关业务处理。")]),r._v(" "),v("h3",{attrs:{id:"消费者组"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#消费者组"}},[r._v("#")]),r._v(" 消费者组")]),r._v(" "),v("p",[r._v("RocketMQ 中的消息消费者都是以消费者组（Consumer Group）的形式出现的。")]),r._v(" "),v("p",[r._v("消费者组是同一类消费者的集合，这类 Consumer 消费的是同一个 Topic 类型的消息。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。")]),r._v(" "),v("p",[r._v("RocketMQ 中的消息有个特点，"),v("strong",[r._v("同一条消息，只能被某一消费组其中的一台机器消费，但是可以同时被不同的消费组消费。")])]),r._v(" "),v("h3",{attrs:{id:"工作流程-4"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#工作流程-4"}},[r._v("#")]),r._v(" 工作流程")]),r._v(" "),v("p",[r._v("Consumer 与 NameServer 集群中的其中一个节点（随机选择）建立长连接，定期从 NameServer 取 Topic 路由信息，并向提供 Topic 服务的 Master、Slave 建立长连接，且定时向 Master、Slave 发送心跳。Consumer 既可以从 Master 订阅消息，也可以从 Slave 订阅消息，订阅规则由 Broker 配置决定。")]),r._v(" "),v("p",[v("strong",[r._v("Consumer 每隔 30s（由 ClientConfig 的 pollNameServerInterval 决定）从 NameServer 获取 Topic 的最新队列情况")]),r._v("，这意味着 Broker 不可用时，Consumer 最多最需要 30s 才能感知。")]),r._v(" "),v("p",[v("strong",[r._v("Consumer 每隔 30s（由 ClientConfig 中 heartbeatBrokerInterval 决定）向所有关联的 Broker 发送心跳")]),r._v("，Broker 每隔 10s 扫描所有存活的连接，若某个连接 2 分钟内没有发送心跳数据，则关闭连接；并向该 Consumer Group 的所有 Consumer 发出通知，Group 内的 Consumer 重新分配队列，继续消费。")]),r._v(" "),v("p",[r._v("当 Consumer 得到 Master 宕机通知后，转向 Slave 消费，Slave不能保证 Master 的消息 100% 都同步过来了，因此会有少量的消息丢失。但是一旦 Master 恢复，未同步过去的消息会被最终消费掉。")])])}),[],!1,null,null,null);e.default=t.exports},887:function(r,e,a){r.exports=a.p+"assets/img/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAZkZlZS1vcHM=,size_20,color_FFFFFF,t_70,g_se,x_16.3575cd24.png"}}]);