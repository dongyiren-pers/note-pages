(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{1103:function(_,v,t){"use strict";t.r(v);var s=t(14),r=Object(s.a)({},(function(){var _=this,v=_.$createElement,s=_._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[s("h1",{attrs:{id:"第4章-总体设计"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第4章-总体设计"}},[_._v("#")]),_._v(" 第4章 总体设计")]),_._v(" "),s("h2",{attrs:{id:"_4-1-设计过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-设计过程"}},[_._v("#")]),_._v(" 4.1 设计过程")]),_._v(" "),s("p",[_._v("总体设计又称为概要设计或初步设计，总体设计的基本目的就是回答 "),s("strong",[_._v("“系统应该如何实现”")]),_._v(" 这个问题。")]),_._v(" "),s("p",[_._v("主要任务：")]),_._v(" "),s("ul",[s("li",[s("strong",[_._v("划分出组成系统的物理元素")]),_._v("：程序、文件、数据库、人工过程和文档等。")]),_._v(" "),s("li",[s("strong",[_._v("确定软件结构")]),_._v("：系统中每个程序是由哪些模块组成的，以及这些模块相互间的关系。")])]),_._v(" "),s("blockquote",[s("p",[_._v("注意：每个物理元素的具体实现是详细阶段的任务。")])]),_._v(" "),s("p",[s("strong",[_._v("总体设计过程分为两个阶段：")])]),_._v(" "),s("ul",[s("li",[s("strong",[_._v("系统设计")]),_._v("——确定系统的具体实现方案；")]),_._v(" "),s("li",[s("strong",[_._v("结构设计")]),_._v("——确定软件结构。")])]),_._v(" "),s("h2",{attrs:{id:"_4-2-设计原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-设计原理"}},[_._v("#")]),_._v(" 4.2 设计原理")]),_._v(" "),s("h3",{attrs:{id:"模块化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模块化"}},[_._v("#")]),_._v(" 模块化")]),_._v(" "),s("p",[_._v("模块化就是 "),s("strong",[_._v("把程序划分成独立命名且可独立访问的模块")]),_._v("，每个模块完成一个子功能，把这些模块集成起来构成一个整体，可以完成指定的功能满足用户的需求。")]),_._v(" "),s("p",[_._v("优点：")]),_._v(" "),s("ul",[s("li",[_._v("使软件结构清晰，不仅容易设计也容易阅读和理解；")]),_._v(" "),s("li",[_._v("使软件容易测试和调试，有助于提高软件的可靠性；")]),_._v(" "),s("li",[_._v("提高软件的可修改性；")]),_._v(" "),s("li",[_._v("有助于软件开发工程的组织管理。")])]),_._v(" "),s("p",[_._v("接口控制考虑的是对模块相联和资源共享问题进行描述和制约。")]),_._v(" "),s("blockquote",[s("p",[s("strong",[_._v("注意：模块是构成程序的基本构件。")])])]),_._v(" "),s("h3",{attrs:{id:"抽象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#抽象"}},[_._v("#")]),_._v(" 抽象")]),_._v(" "),s("p",[_._v("抽象就是 "),s("strong",[_._v("抽出事物的本质特性而暂时不考虑它们的细节")]),_._v("。")]),_._v(" "),s("p",[_._v("优点：")]),_._v(" "),s("ul",[s("li",[_._v("简化了软件的设计和实现；")]),_._v(" "),s("li",[_._v("提高了软件的可理解性和可测试性；")]),_._v(" "),s("li",[_._v("使得软件更容易维护。")])]),_._v(" "),s("h3",{attrs:{id:"信息隐藏与局部化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#信息隐藏与局部化"}},[_._v("#")]),_._v(" 信息隐藏与局部化")]),_._v(" "),s("p",[_._v("信息隐藏：使得一个模块内包含的信息（主要是实现细节）对于不需要这些信息的模块是不能访问的。")]),_._v(" "),s("p",[_._v("局部化：指把一些关系密切的软件元素物理地放得彼此靠近。")]),_._v(" "),s("h3",{attrs:{id:"模块独立"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#模块独立"}},[_._v("#")]),_._v(" 模块独立")]),_._v(" "),s("p",[_._v("定义：开发的模块具有独立功能而且和其他模块之间没有过多的相互作用的模块，就可以做到模块独立；"),s("strong",[_._v("坚持模块独立性是获得良好设计的关键")]),_._v("。")]),_._v(" "),s("p",[_._v("两个度量标准：耦合和内聚。")]),_._v(" "),s("p",[s("strong",[_._v("耦合")]),_._v("：耦合用于衡量 "),s("strong",[_._v("不同模块")]),_._v(" 彼此之间相互依赖（连接）的紧密程度。")]),_._v(" "),s("p",[_._v("耦合的七种类型（低 → 高）：")]),_._v(" "),s("ul",[s("li",[s("strong",[_._v("非直接耦合")]),_._v("：两个模块之间没有直接联系，其联系通过主模块或上层模块间接建立。")]),_._v(" "),s("li",[_._v("数据耦合：模块间通过传递简单的数据参数（非控制参数、公共结构或外部变量）交换信息。")]),_._v(" "),s("li",[_._v("标记耦合：模块间通过传递复杂的数据结构（非简单变量）交换信息。")]),_._v(" "),s("li",[_._v("控制耦合： 一个模块通过传递控制信息（如开关、标志）来控制另一模块的行为。")]),_._v(" "),s("li",[_._v("外部耦合：多个模块访问同一全局简单变量，且不通过参数传递。")]),_._v(" "),s("li",[_._v("公共耦合：多个模块访问同一公共数据环境，如全局数据结构或共享通信区。")]),_._v(" "),s("li",[_._v("内容耦合：模块直接访问另一模块的内部数据；模块不通过正常入口进入另一模块；两模块有程序代码重迭；模块具有多个入口。")])]),_._v(" "),s("p",[s("strong",[_._v("内聚")]),_._v("：内聚衡量 "),s("strong",[_._v("一个模块")]),_._v(" 内部各个元素之间彼此结合的紧密程度；理想内聚的模块只做一件事情；设计时应该力求做到高内聚，坚决不要使用低内聚；"),s("strong",[_._v("高内聚意味着松耦合")]),_._v("。")]),_._v(" "),s("p",[_._v("内聚更重要，应该把更多注意力集中到提高模块的内聚程度上。")]),_._v(" "),s("p",[_._v("内聚的七种类型（低 → 高）：")]),_._v(" "),s("ul",[s("li",[_._v("偶然内聚：代码片段凑巧相同，但没有表现出明确的功能。")]),_._v(" "),s("li",[_._v("逻辑内聚：相关功能被组合在一个模块中，执行哪种功能由传递给模块的控制参数决定。")]),_._v(" "),s("li",[_._v("时间内聚：模块的不同功能与时间有关，通常要求所有功能必须在同一时间段内执行。")]),_._v(" "),s("li",[_._v("过程内聚：模块由执行特定顺序的子模块组成。")]),_._v(" "),s("li",[_._v("通信内聚：模块内的功能部分都使用了相同的输入数据或产生了相同的输出流向。")]),_._v(" "),s("li",[_._v("顺序内聚：子模块必须顺序执行，且通常一个子模块的输出数据是下一个子模块的输入数据。")]),_._v(" "),s("li",[s("strong",[_._v("功能内聚")]),_._v("：模块中的各个部分紧密联系，共同完成一个单一的功能。")])]),_._v(" "),s("blockquote",[s("p",[s("strong",[_._v("牢记")]),_._v("：设计的软件尽量满足 "),s("strong",[_._v("“高内聚、低耦合”")]),_._v(" 和 "),s("strong",[_._v("“高扇入、低扇出”")]),_._v(" 原则。")])]),_._v(" "),s("h2",{attrs:{id:"_5-3-启发规则"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-启发规则"}},[_._v("#")]),_._v(" 5.3 启发规则")]),_._v(" "),s("p",[s("strong",[_._v("1、改进软件结构提高模块独立性。")])]),_._v(" "),s("p",[_._v("通过模块分解或合并，降低耦合提高内聚。")]),_._v(" "),s("p",[s("strong",[_._v("2、模块规模应该适中。")])]),_._v(" "),s("p",[s("strong",[_._v("3、深度、宽度、扇出和扇入都应适当。")])]),_._v(" "),s("ul",[s("li",[_._v("深度：深度表示软件结构中控制的 "),s("strong",[_._v("层数")]),_._v("。")]),_._v(" "),s("li",[_._v("宽度：宽度是软件结构内 "),s("strong",[_._v("同一个层次上的模块总数的最大值")]),_._v("。宽度越大系统越复杂。对宽度影响最大的因素是模块的扇出。")]),_._v(" "),s("li",[_._v("扇出：扇出是 "),s("strong",[_._v("一个模块直接控制的模块数目")]),_._v("。")]),_._v(" "),s("li",[_._v("扇入：扇入表明 "),s("strong",[_._v("有多少个上级模块直接调用它")]),_._v("。")])]),_._v(" "),s("p",[_._v("一个模块的（扇出）太大一般是因为缺乏中间层次，应当适当增加中间层次的控制模块。")]),_._v(" "),s("p",[s("img",{attrs:{src:t(909),alt:"image-20240120220424639"}})]),_._v(" "),s("p",[s("strong",[_._v("4、模块的作用域应该在控制域之内。")])]),_._v(" "),s("ul",[s("li",[_._v("作用域：受该模块内一个判定影响的所有模块的集合；")]),_._v(" "),s("li",[_._v("控制域：该模块本身以及所有直接或间接从属于它的模块的集合。")]),_._v(" "),s("li",[_._v("改变作用域与控制域的方法：判断点上移 / 作用域对象下移。")])]),_._v(" "),s("p",[s("img",{attrs:{src:t(910),alt:"image-20240120220351136"}})])])}),[],!1,null,null,null);v.default=r.exports},909:function(_,v,t){_.exports=t.p+"assets/img/image-20240120220424639.786caa77.png"},910:function(_,v,t){_.exports=t.p+"assets/img/image-20240120220351136.25e68561.png"}}]);