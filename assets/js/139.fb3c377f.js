(window.webpackJsonp=window.webpackJsonp||[]).push([[139],{1046:function(a,t,s){"use strict";s.r(t);var n=s(14),e=Object(n.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"第3章-对象与类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第3章-对象与类"}},[a._v("#")]),a._v(" 第3章 对象与类")]),a._v(" "),s("h2",{attrs:{id:"_3-1-面向对象程序设计概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-面向对象程序设计概述"}},[a._v("#")]),a._v(" 3.1 面向对象程序设计概述")]),a._v(" "),s("p",[a._v("面向对象程序设计（简称OOP）是当今主流的程序设计范型，它已经取代了 20 世纪 70 年代的 “结构化” 过程化程序设计开发技术。Java 是完全面向对象的，必须熟悉OOP 才能够编写 Java 程序。")]),a._v(" "),s("h3",{attrs:{id:"类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类"}},[a._v("#")]),a._v(" 类")]),a._v(" "),s("p",[s("strong",[a._v("类")]),a._v("（class）是构造对象的模板或蓝图。 由类构造对象的过程称为创建类的"),s("strong",[a._v("实例")]),a._v("（instance）。")]),a._v(" "),s("p",[s("strong",[a._v("封装")]),a._v("（encapsulation，有时称为数据隐藏）是与对象有关的一个重要概念。 从形式上看，封装不过是将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式。")]),a._v(" "),s("p",[a._v("对象中的数据称为"),s("strong",[a._v("实例域")]),a._v("（instance field），操纵数据的过程称为"),s("strong",[a._v("方法")]),a._v(" （method）。对于每个特定的类实例（对象）都有一组特定的实例域值。 这些值的集合就是这个对象的当前"),s("strong",[a._v("状态")]),a._v("（state）。")]),a._v(" "),s("p",[a._v("实现封装的关键在于绝对不能让类中的方法直接地访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。封装给对象赋予了 “黑盒” 特征，这是提高重用性和可靠性的关键。")]),a._v(" "),s("p",[a._v("OOP 的另一个原则会让用户自定义 Java 类变得轻而易举，这就是：可以通过扩展一个类来建立另外一个新的类。事实上，在 Java 中，所有的类都源自于一个 “神通广大的超类”，它就是 Object。")]),a._v(" "),s("p",[a._v("在扩展一个已有的类时，这个扩展后的新类具有所扩展的类的全部属性和方法，只需提供适用于这个新类的新方法和数据域就可以了。 通过扩展一个类来建立另外一个类的过程称为"),s("strong",[a._v("继承")]),a._v("（inheritance）。")]),a._v(" "),s("h3",{attrs:{id:"对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对象"}},[a._v("#")]),a._v(" 对象")]),a._v(" "),s("p",[a._v("同一个类的所有对象实例，由于支持相同的行为而具有家族式的相似性。 "),s("strong",[a._v("对象的行为")]),a._v("是用可调用的方法定义的 。")]),a._v(" "),s("p",[a._v("此外，每个对象都保存着描述当前特征的信息。这就是"),s("strong",[a._v("对象的状态")]),a._v("。对象的状态可能会随着时间而发生改变，但这种改变不会是自发的。对象状态的改变必须通过调用方法实现（如果不经过方法调用就可以改变对象状态，只能说明封装’性遭到了破坏） 。")]),a._v(" "),s("p",[a._v("但是，对象的状态并不能完全描述一个对象。 每个对象都有一个唯一的身份（identity） 。")]),a._v(" "),s("h3",{attrs:{id:"类之间的关系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类之间的关系"}},[a._v("#")]),a._v(" 类之间的关系")]),a._v(" "),s("p",[a._v("在类之间，最常见的关系有")]),a._v(" "),s("ul",[s("li",[a._v("依赖（uses-a）")]),a._v(" "),s("li",[a._v("聚合（has-a）")]),a._v(" "),s("li",[a._v("继承（is-a）")])]),a._v(" "),s("p",[a._v("如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类。聚合关系意味着一个类的对象包含另一个类的对象。继承用于表示特殊与一般关系。")]),a._v(" "),s("h2",{attrs:{id:"_3-2-使用预定义类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-使用预定义类"}},[a._v("#")]),a._v(" 3.2 使用预定义类")]),a._v(" "),s("h3",{attrs:{id:"对象与对象变量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对象与对象变量"}},[a._v("#")]),a._v(" 对象与对象变量")]),a._v(" "),s("p",[a._v("要想使用对象，就必须首先构造对象，并指定其初始状态。 然后，对对象应用方法。")]),a._v(" "),s("p",[a._v("在 Java 程序设计语言中，使用构造器（constructor）构造新实例。构造器是一种特殊的方法，用来构造并初始化对象。")]),a._v(" "),s("p",[a._v("下面看一个例子。在标准 Java 库中包含一个 Date 类。")]),a._v(" "),s("p",[a._v("Date 类的对象将描述一个时间点，例如：“December 31,1999,23:59:59 GMT”。")]),a._v(" "),s("p",[a._v("构造器的名字与类名相同。因此 Date 类的构造器名为 Date。要构造一个 Date 对象，需要在构造器前面加上 new 操作符，如下所示：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Date")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])])]),s("p",[a._v("这个表达式构造了一个新对象。 这个对象被初始化为当前的日期和时间 。")]),a._v(" "),s("p",[a._v("通常，希望构造的对象可以多次使用，因此，需要将对象存放在一个变量中：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Date")]),a._v(" birthday "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Date")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("p",[a._v("在对象与对象变量之间存在着一个重要的区别。例如，语句")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Date")]),a._v(" deadline"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// deadline doesn't refer to any object")]),a._v("\n")])])]),s("p",[a._v("定义了一个对象变量 deadline，它可以引用 Date 类型的对象。但是，一定要认识到：变量 deadline 不是一个对象，实际上也没有引用对象。此时，不能将任何 Date 方法应用于这个变量上。语句")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[a._v("s "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" deadline"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("toString")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// not yet")]),a._v("\n")])])]),s("p",[a._v("将产生编译错误。")]),a._v(" "),s("p",[a._v("在 Java 中，任何对象变量的值都是对存储在另外一个地方的一个对象的引用。")]),a._v(" "),s("p",[a._v("可以显式地将对象变量设置为 null，表明这个对象变量没有引用任何对象。如果将一个方法应用于一个值为 null 的对象上，那么就会产生运行时错误。")]),a._v(" "),s("p",[a._v("局部变量不会自动地初始化为 null，而必须通过调用 new 或将它们设置为 null 进行初始化。")]),a._v(" "),s("blockquote",[s("p",[s("strong",[a._v("C++ 注释")]),a._v("：很多人错误地认为 Java 对象变量与 C＋＋的引用类似。 然而，在 C＋＋中没有空引用，并且引用不能被赋值。 可以将 Java 的对象变量看作 C++ 的对象指针。在 C++ 中，指针十分令人头疼，并常常导致程序错误。稍不小心就会创建一个错误的指针，或者造成内存溢出。在 Java 中，这些问题都不复存在。如果使用一个没有初始化的指针，运行系统将会产生一个运行时错误，而不是生成一个随机的结果。同时，不必担心内存管理问题，垃圾收集器将会处理相关的事宜。")])]),a._v(" "),s("h3",{attrs:{id:"java-类库中的-localdate-类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java-类库中的-localdate-类"}},[a._v("#")]),a._v(" Java 类库中的 LocalDate 类")]),a._v(" "),s("p",[a._v("前面的例子中，已经使用了 Java 标准类库中的 Date 类。Date 类的实例有一个状态，即特定的时间点。")]),a._v(" "),s("p",[a._v("尽管在使用 Date 类时不必知道这一点，但时间是用距离一个固定时间点的毫秒数（可正可负）表示的，这个点就是所谓的纪元（epoch），它是 UTC 时间 1970 年 1 月 1 日 00:00:00。")]),a._v(" "),s("p",[a._v("UTC 是 Coordinated Universal Time 的缩写，与大家熟悉的 GMT（即 Greenwich Mean Time，格林威治时间）一样，是一种具有实践意义的科学标准时间。")]),a._v(" "),s("p",[a._v("但是，Date 类所提供的日期处理并没有太大的用途。Java 类库的设计者认为： 像 “December 31, 1999, 23:59:59” 这样的日期表示法只是阳历的固有习惯。这种特定的描述法遵循了世界上大多数地区使用的 Gregorian 阳历表示法。但是，同一时间点采用中国的农历表示或者希伯来的阴历表示就很不一样，对于火星历来说就更不可想象了。")]),a._v(" "),s("p",[a._v("类库设计者决定将保存时间与给时间点命名分开。标准 Java 类库分别包含了两个类：一个是用来表示时间点的 Date 类；另一个是用来表示大家熟悉的日历表示法的 LocalDate 类。")]),a._v(" "),s("p",[a._v("将时间与日历分开是一种很好的面向对象设计。通常，最好使用不同的类表示不同的概念。")]),a._v(" "),s("p",[a._v("不要使用构造器来构造 LocalDate 类的对象。 实际上，应当使用静态工厂方法（factory method）代表你调用构造器。下面的表达式")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("LocalDate")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("now")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])])]),s("p",[a._v("会构造一个新对象，表示构造这个对象时的日期。")]),a._v(" "),s("p",[a._v("可以提供年 、月和日来构造对应一个特定日期的对象：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("LocalDate")]),a._v(" newYearsEve "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("LocalDate")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("of")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1999")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("12")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("31")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])])]),s("p",[a._v("一旦有了一个 LocalDate 对象，可以用方法 getYear、getMonthValue 和 getDayOfMonth 得到年、月和日：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" year "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" newYearsEve"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getYear")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 1999")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" month "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" newYearsEve"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getMonthValue")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 12")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" day "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" newYearsEve"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getDayOfMonth")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 31")]),a._v("\n")])])]),s("p",[a._v("plusDays 方法会得到一个新的 LocalDate，这个新日期对象则是距当前对象指定天数的一个新日期：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("LocalDate")]),a._v(" aThousandDaysLater "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" newYearsEve"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("plusDays")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1000")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" \nyear "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" aThousandDaysLater"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getYear")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 2002")]),a._v("\nmonth "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" aThousandDaysLater"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getMonthValue")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 09")]),a._v("\nday "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" aThousandDaysLater"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getDayOfMonth")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 26")]),a._v("\n")])])]),s("blockquote",[s("p",[a._v("注释：实际上，Date 类还有 getDay、 getMonth 以及 getYear 等方法，然而并不推荐使用这些方法。")])]),a._v(" "),s("h3",{attrs:{id:"更改器方法与访问器方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#更改器方法与访问器方法"}},[a._v("#")]),a._v(" 更改器方法与访问器方法")]),a._v(" "),s("p",[a._v("再来看上一节中的 plusDays 方法调用：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("LocalDate")]),a._v(" aThousandDaysLater "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" newYearsEve"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("plusDays")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1000")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" \n")])])]),s("p",[a._v("调用之后 newYearsEve 会改为 1000 天之后的日期吗？事实上，并没有。plusDays 方法会生成一个新 LocalDate 对象，然后把这个新对象赋给 aThousandDaysLater 变量。原来的对象不做任何改动。我们说 plusDays 方法没有更改调用这个方法的对象。")]),a._v(" "),s("p",[a._v("Java 库的一个较早版本曾经有另一个类来处理日历，名为 GregorianCalendar。可以如下为这个类表示的一个日期增加 1000 天：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("GregorianCalendar")]),a._v(" someDay "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("GregorianCalendar")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1999")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("11")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("31")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// Odd feature of that class: month numbers go from 0 to 11")]),a._v("\nsomeDay"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("add")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Calendar")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("DAY_OF_MONTH"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1000")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("p",[a._v("与 LocalDate.plusDays 方法不同，GregorianCalendar.add 方法是一个"),s("strong",[a._v("更改器方法（mutator method）")]),a._v("。调用这个方法后，someDay 对象的状态会改变。可以如下查看新状态：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[a._v("year "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" someDay"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Calendar")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("YEAR"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 2002")]),a._v("\nmonth "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" someDay"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Calendar")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("MONTH"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 09")]),a._v("\nday "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" someDay"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("get")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Calendar")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("DAY_OF_MONTH"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 26")]),a._v("\n")])])]),s("p",[a._v("正是因为这个原因，我们将变量命名为 someDay 而不是 newYearsEve一一调用这个更改器方法之后，它不再是新年前夜。")]),a._v(" "),s("p",[a._v("相反，只访问对象而不修改对象的方法称为"),s("strong",[a._v("访问器方法（accessor method）")]),a._v("。例如，LocalDate.getYear() 和 GregorianCalendar.get() 就是访问器方法。")]),a._v(" "),s("blockquote",[s("p",[s("strong",[a._v("C++ 注释")]),a._v("：在 C++ 中，带有 const 后缀的方法是访问器方法；默认为更改器方法。但是，在 Java 中，访问器方法与更改器方法在语法上没有明显的区别。")])]),a._v(" "),s("h3",{attrs:{id:"java-time-localdate-8-api"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java-time-localdate-8-api"}},[a._v("#")]),a._v(" java.time.LocalDate 8 API")]),a._v(" "),s("table",[s("thead",[s("tr",[s("th",[a._v("方法")]),a._v(" "),s("th",[a._v("描述")])])]),a._v(" "),s("tbody",[s("tr",[s("td",[a._v("static LocalTime now()")]),a._v(" "),s("td",[a._v("构造一个表示当前日期的对象。")])]),a._v(" "),s("tr",[s("td",[a._v("static LocalTime of(int year, int month , int day)")]),a._v(" "),s("td",[a._v("构造一个表示给定日期的对象。")])]),a._v(" "),s("tr",[s("td",[a._v("int getYear()"),s("br"),a._v("int getMonthValue()"),s("br"),a._v("int getDayOfMonth()")]),a._v(" "),s("td",[a._v("得到当前日期的年、月和日。")])]),a._v(" "),s("tr",[s("td",[a._v("DayOfWeek getDayOfWeek()")]),a._v(" "),s("td",[a._v("得到当前日期是星期几，返回 DayOfWeek 类的一个实例。调用 getValue 得到 1 ~ 7 之间的数，1 表示星期一，7 表示星期日。")])]),a._v(" "),s("tr",[s("td",[a._v("LocalDate plusDays(int n)"),s("br"),a._v("LocalDate minusDays(int n)")]),a._v(" "),s("td",[a._v("生成当前日期之后或之前 n 天的日期。")])])])]),a._v(" "),s("h2",{attrs:{id:"_3-3-用户自定义类"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-用户自定义类"}},[a._v("#")]),a._v(" 3.3 用户自定义类")]),a._v(" "),s("h3",{attrs:{id:"构造器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构造器"}},[a._v("#")]),a._v(" 构造器")]),a._v(" "),s("p",[a._v("以 Employee 类为例。先看看 Employee 类的构造器：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Employee")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("double")]),a._v(" s"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" year"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" month"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" day"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    name "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    salary "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" s"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    hireDay "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("LocalDate")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("of")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("year"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" month"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" day"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("构造器与类同名。在构造 Employee 类的对象时，构造器会运行，以便将实例域初始化为所希望的状态 。")]),a._v(" "),s("p",[a._v("构造器与其他的方法有一个重要的不同。构造器总是伴随着 new 操作符的执行被调用，而不能对一个已存在的对象调用构造器来达到重新设置实例域的目的。")]),a._v(" "),s("p",[a._v("稍后还会更加详细地介绍有关构造器的内容。 现在只需要记住：")]),a._v(" "),s("ul",[s("li",[a._v("构造器与类同名")]),a._v(" "),s("li",[a._v("每个类可以有一个以上的构造器")]),a._v(" "),s("li",[a._v("构造器可以有 0 个、1 个或多个参数")]),a._v(" "),s("li",[a._v("构造器没有返回值")]),a._v(" "),s("li",[a._v("构造器总是伴随着 new 操作一起调用")])]),a._v(" "),s("h3",{attrs:{id:"隐式参数与显式参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#隐式参数与显式参数"}},[a._v("#")]),a._v(" 隐式参数与显式参数")]),a._v(" "),s("p",[a._v("方法用于操作对象以及存取它们的实例域。例如，方法：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("raiseSalary")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("double")]),a._v(" byPercent"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("double")]),a._v(" raise "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" salary "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" byPercent "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("100")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    salary "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+=")]),a._v(" raise"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("raiseSalary 方法有两个参数。 第一个参数称为隐式（implicit）参数，是出现在方法名前的 Employee 类对象。第二个参数位于方法名后面括号中的数值，这是一个显式（explicit）参数。")]),a._v(" "),s("p",[a._v("在每一个方法中，关键字 this 表示隐式参数。如果需要的话，可以用下列方式编写 raiseSalary 方法：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("raiseSalary")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("double")]),a._v(" byPercent"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("double")]),a._v(" raise "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("salary "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" byPercent "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("/")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("100")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("salary "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+=")]),a._v(" raise"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("blockquote",[s("p",[s("strong",[a._v("C++ 注释")]),a._v("：在 Java 中，所有的方法都必须在类的内部定义，但并不表示它们是内联方法。是否将某个方法设置为内联方法是 Java 虚拟机的任务。即时编译器会监视调用那些简洁、经常被调用、没有被重载以及可优化的方法。")])]),a._v(" "),s("h3",{attrs:{id:"封装的优点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#封装的优点"}},[a._v("#")]),a._v(" 封装的优点")]),a._v(" "),s("p",[a._v("最后，再仔细地看一下非常简单的 getName 方法、 getSalary 方法和 getHireDay 方法。")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getName")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("double")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getSalary")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" salary"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("LocalDate")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getHireDay")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" hireDay"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("这些都是典型的访问器方法。由于它们只返回实例域值，因此又称为域访问器。")]),a._v(" "),s("p",[a._v("有些时候，需要获得或设置实例域的值。因此，应该提供下面三项内容：")]),a._v(" "),s("ul",[s("li",[a._v("一个私有的数据域")]),a._v(" "),s("li",[a._v("一个公有的域访问器方法")]),a._v(" "),s("li",[a._v("一个公有的域更改器方法")])]),a._v(" "),s("p",[a._v("这样做要比提供一个简单的公有数据域复杂些，但是却有着下列明显的好处：")]),a._v(" "),s("p",[a._v("首先，可以改变内部实现，除了该类的方法之外，不会影响其他代码。例如，将存储名字的域改为：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" firstName"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" lastName"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("p",[a._v("那么 getName 方法可以改为返回")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[a._v("firstName "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('" "')]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" lastName\n")])])]),s("p",[a._v("对于这点改变，程序的其他部分完全不可见。")]),a._v(" "),s("p",[a._v("当然，为了进行新旧数据表示之间的转换，访问器方法和更改器方法有可能需要做许多工作。 但是，这将为我们带来了第二点好处：更改器方法可以执行错误检查，直接对域进行赋值将不会进行这些处理。 例如， setSalary 方法可以检查薪金是否小于 0。")]),a._v(" "),s("p",[a._v("不要编写返回引用可变对象的访问器方法。下面例子违反了这个设计原则，其中的 getHireDay 方法返回了一个 Date 类对象：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Employee")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Date")]),a._v(" hireDay"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// ...")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Date")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getHireDay")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" hireDay"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// Bad")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// ...")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("LocalDate 类没有更改器方法，与之不同，Date 类有一个更改器方法 setTime，可以在这里设置毫秒数。Date 对象是可变的，这一点就破坏了封装性。")]),a._v(" "),s("p",[a._v("如果需要返回一个可变对象的引用，应该首先对它进行克隆（clone）。对象 clone 是存放在另一个位置上的对象副本。")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Employee")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Date")]),a._v(" hireDay"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// ...")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Date")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getHireDay")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Date")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" hireDay"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("clone")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// Ok")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// ...")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("h3",{attrs:{id:"基于类的访问权限"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基于类的访问权限"}},[a._v("#")]),a._v(" 基于类的访问权限")]),a._v(" "),s("p",[a._v("方法可以访问所调用对象的私有数据，且一个方法可以访问"),s("strong",[a._v("所属类的所有对象")]),a._v("的私有数据。")]),a._v(" "),s("p",[a._v("例如，比较两个雇员的 equals 方法。")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Employee")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// ...")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("boolean")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("equals")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Employee")]),a._v(" other"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("equals")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("other"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("典型的调用方式是")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("harry"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("equals")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("boss"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//...")]),a._v("\n")])])]),s("p",[a._v("这个方法访问 harry 的私有域，这点并不会让人奇怪，然而，它还访问了 boss 的私有域。这是合法的，因为 boss 是 Employee 类对象，Employee 类的方法可以访问 Employee 类的任何一个对象的私有域。")]),a._v(" "),s("blockquote",[s("p",[s("strong",[a._v("C++注释")]),a._v("：C++有同样的原则。方法可以访问所属类的私有特性（feature），而不仅限于访问隐式参数（this）的私有特性。")])]),a._v(" "),s("h3",{attrs:{id:"私有方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#私有方法"}},[a._v("#")]),a._v(" 私有方法")]),a._v(" "),s("p",[a._v("尽管绝大多数方法都被设计为公有的，但在某些特殊情况下，也可能将它们设计为私有的。有时，可能希望将一个计算代码划分成若干个独立的辅助方法。通常，这些辅助方法不应该成为公有接口的一部分，这是由于它们往往与当前的实现机制非常紧密，或者需要一个特别的协议以及一个特别的调用次序。最好将这样的方法设计为 private 的。")]),a._v(" "),s("p",[a._v("在 Java 中，为了实现一个私有的方法，只需将关键字 public 改为 private 即可。")]),a._v(" "),s("h3",{attrs:{id:"final-实例域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#final-实例域"}},[a._v("#")]),a._v(" final 实例域")]),a._v(" "),s("p",[a._v("可以将实例域定义为 final。构建对象时必须初始化这样的域，即必须确保在每一个构造器执行之后，这个域的值被设置，并且在后面的操作中，不能够再对它进行修改。")]),a._v(" "),s("p",[a._v("final 修饰符大都应用于基本（primitive）类型域，或不可变（immutable）类的域（如果类中的每个方法都不会改变其对象，这种类就是不可变的类）。")]),a._v(" "),s("p",[a._v("final 关键字只是表示存储在变量中的对象引用不会再指示其他对象，但这个对象可以更改。")]),a._v(" "),s("h2",{attrs:{id:"_3-4-静态域与静态方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-静态域与静态方法"}},[a._v("#")]),a._v(" 3.4 静态域与静态方法")]),a._v(" "),s("h3",{attrs:{id:"静态域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#静态域"}},[a._v("#")]),a._v(" 静态域")]),a._v(" "),s("p",[a._v("如果将域定义为 static，每个类中只有一个这样的域，称为静态域。")]),a._v(" "),s("blockquote",[s("p",[s("strong",[a._v("注释")]),a._v("：在绝大多数的面向对象程序设计语言中，静态域被称为类域。")])]),a._v(" "),s("h3",{attrs:{id:"静态常量"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#静态常量"}},[a._v("#")]),a._v(" 静态常量")]),a._v(" "),s("p",[a._v("一个多次使用的静态常量是 System.out：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("PrintStream")]),a._v(" out "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("由于每个类对象都可以对公有域进行修改，最好不要将域设计为 public。 然而，公有常量（即 final 域）却没问题。因为 out 被声明为 final，所以不允许\n再将其他打印流赋给它。")]),a._v(" "),s("h3",{attrs:{id:"静态方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#静态方法"}},[a._v("#")]),a._v(" 静态方法")]),a._v(" "),s("p",[a._v("静态方法是一种不能向对象实施操作的方法。可以认为静态方法是没有 this 参数的方法（在一个非静态的方法中，this 参数表示这个方法的隐式参数）。")]),a._v(" "),s("blockquote",[s("p",[s("strong",[a._v("注释")]),a._v("：可以使用对象调用静态方法。不过，这种方式很容易造成混滑，建议使用类名调用静态方法。")])]),a._v(" "),s("p",[a._v("在下面两种情况下使用静态方法：")]),a._v(" "),s("ul",[s("li",[a._v("一个方法不需要访问对象状态，其所需参数都是通过显式参数提供")]),a._v(" "),s("li",[a._v("一个方法只需要访问类的静态域")])]),a._v(" "),s("h3",{attrs:{id:"工厂方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#工厂方法"}},[a._v("#")]),a._v(" 工厂方法")]),a._v(" "),s("p",[a._v("静态方法还有另外一种常见的用途。 类似 LocalDate 和 NumberFormat 的类使用静态工厂方法（factory method）来构造对象。")]),a._v(" "),s("h2",{attrs:{id:"_3-5-按值调用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-按值调用"}},[a._v("#")]),a._v(" 3.5 按值调用")]),a._v(" "),s("p",[a._v("首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。")]),a._v(" "),s("p",[s("strong",[a._v("按值调用")]),a._v("（call by value）表示方法接收的是调用者提供的值。 "),s("strong",[a._v("按引用调用")]),a._v("（call by reference）表示方法接收的是调用者提供的变量地址。")]),a._v(" "),s("p",[a._v("Java 总是采用按值调用，方法得到的是参数值的一个拷贝。")]),a._v(" "),s("p",[a._v("然而，方法参数共有两种类型：")]),a._v(" "),s("ul",[s("li",[a._v("基本数据类型（数字、布尔值） 。")]),a._v(" "),s("li",[a._v("对象引用 。")])]),a._v(" "),s("p",[a._v("实现一个改变对象参数状态的方法并不是一件难事。 理由很简单，方法得到的是对象引用的拷贝，对象引用及其拷贝同时引用同一个对象。")]),a._v(" "),s("p",[a._v("有些程序员认为 Java 对对象采用的是按引用调用，实际上，这种理解是不对的。 由于这种误解具有一定的普遍性，下面给出一个反例来详细地阐述一下这个问题。")]),a._v(" "),s("p",[a._v("首先，编写一个交换两个雇员对象的方法：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("swap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Employee")]),a._v(" x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Employee")]),a._v(" y"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// doesn't work")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Employee")]),a._v(" temp "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    x "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" y"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    y "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" temp"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("如果 Java 对对象采用的是按引用调用，那么这个方法就应该能够实现交换数据的效果。但是，方法并没有改变存储在变量 a 和 b 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝。")]),a._v(" "),s("h2",{attrs:{id:"_3-6-对象构造"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-6-对象构造"}},[a._v("#")]),a._v(" 3.6 对象构造")]),a._v(" "),s("h3",{attrs:{id:"重载"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重载"}},[a._v("#")]),a._v(" 重载")]),a._v(" "),s("p",[a._v("如果多个方法有相同的名字、不同的参数，便产生了重载。 编译器必须挑选出具体执行哪个方法，它通过用各个方法给出的参数类型与特定方法调用使用的值类型进行匹配来挑选出相应的方法。 如果编译器找不到匹配的参数，就会产生编译时错误。这个过程被称为"),s("strong",[a._v("重载解析")]),a._v("（overloading resolution）。")]),a._v(" "),s("blockquote",[s("p",[s("strong",[a._v("注释")]),a._v("： Java 允许重载任何方法，而不只是构造器方法。因此，完整地描述一个方法，需要指出方法名以及参数类型。这叫做方法的签名（signature）。")])]),a._v(" "),s("h3",{attrs:{id:"默认域初始化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#默认域初始化"}},[a._v("#")]),a._v(" 默认域初始化")]),a._v(" "),s("p",[a._v("如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值：数值为 0、布尔值为 false、 对象引用为 null。")]),a._v(" "),s("blockquote",[s("p",[s("strong",[a._v("注释")]),a._v("：这是域与局部变量的主要不同点。必须明确地初始化方法中的局部变量，否则将出现编译错误。但是，如果没有初始化类中的域，将会被自动初始化为默认位（0、false 或 null）。")])]),a._v(" "),s("h3",{attrs:{id:"无参数的构造器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#无参数的构造器"}},[a._v("#")]),a._v(" 无参数的构造器")]),a._v(" "),s("p",[a._v("很多类都包含一个无参数的构造函数，对象由无参数构造函数创建时，其状态会设置为适当的默认值。")]),a._v(" "),s("p",[a._v("如果在编写一个类时没有编写构造器，系统就会提供一个无参数构造器。这个构造器将所有的实例域设置为默认值。实例域中的数值型数据设置为 0、布尔型数据设置为 false、所有对象变量将设置为 null。")]),a._v(" "),s("p",[a._v("如果类中提供了至少一个构造器，但是没有提供无参数的构造器，则在构造对象时如果没有提供参数就会被视为不合法。")]),a._v(" "),s("h3",{attrs:{id:"调用另一个构造器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#调用另一个构造器"}},[a._v("#")]),a._v(" 调用另一个构造器")]),a._v(" "),s("p",[a._v("如果构造器的第一个语句形如 "),s("code",[a._v("this(...)")]),a._v("，这个构造器将调用同一个类的另一个构造器。一个例子：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Employee")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("double")]),a._v(" s"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// call Employee(String, double)")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("this")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Employee #"')]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" nextId"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" s"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    nextId"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("h3",{attrs:{id:"初始化块"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#初始化块"}},[a._v("#")]),a._v(" 初始化块")]),a._v(" "),s("p",[a._v("前面已经讲过两种初始化数据域的方法：")]),a._v(" "),s("ul",[s("li",[a._v("在构造器中设置值")]),a._v(" "),s("li",[a._v("在声明中赋值")])]),a._v(" "),s("p",[a._v("实际上，Java 还有第三种机制，称为初始化块（initializationblock）。在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行。")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("div",{staticClass:"highlight-lines"},[s("br"),s("br"),s("br"),s("br"),s("br"),s("br"),s("div",{staticClass:"highlighted"},[a._v(" ")]),s("div",{staticClass:"highlighted"},[a._v(" ")]),s("div",{staticClass:"highlighted"},[a._v(" ")]),s("div",{staticClass:"highlighted"},[a._v(" ")]),s("div",{staticClass:"highlighted"},[a._v(" ")]),s("br"),s("br"),s("br"),s("br"),s("br"),s("br"),s("br"),s("br"),s("br"),s("br"),s("br"),s("br")]),s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Employee")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" nextId"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" id"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" name"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("double")]),a._v(" salary"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n   "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// object initialization block")]),a._v("\n   "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n      id "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" nextId"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n      nextId"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n   "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Employee")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("double")]),a._v(" s"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n      name "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n      salary "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" s"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n   "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n   "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Employee")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n      name "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('""')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n      salary "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n   "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("在这个示例中，无论使用哪个构造器构造对象，id 域都在对象初始化块中被初始化。首先运行初始化块，然后才运行构造器的主体部分。")]),a._v(" "),s("p",[a._v("由于初始化数据域有多种途径，列出构造过程的全部路径可能相当棍乱。这是调用构造器的处理步骤：")]),a._v(" "),s("ol",[s("li",[a._v("所有数据域被初始化为默认值（0、false 或 null）。")]),a._v(" "),s("li",[a._v("按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块。")]),a._v(" "),s("li",[a._v("如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。")]),a._v(" "),s("li",[a._v("执行这个构造器的主体。")])]),a._v(" "),s("p",[a._v("当然，应该精心地组织好初始化代码，这样有利于其他程序员的理解。例如，如果让类的构造器行为依赖于数据域声明的顺序，那就会显得很奇怪并且容易引起错误。")]),a._v(" "),s("p",[a._v("可以通过提供一个初始化值，或者使用一个静态的初始化块来对静态域进行初始化。第一种机制：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" nextId "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("p",[a._v("如果对类的静态域进行初始化的代码比较复杂，那么可以使用静态的初始化块。")]),a._v(" "),s("p",[a._v("将代码放在一个块中，并标记关键字 static。下面是一个示例。其功能是将雇员 ID 的起始值赋予一个小于 10000 的随机整数。")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// static initialization block")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Random")]),a._v(" generator "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Random")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" \n    nextId "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" generator"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("nextInt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("10000")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("类第一次加载时，将会进行静态域的初始化。与实例域一样，除非将它们显式地设置成其他值，否则默认的初始值是 0、false 或 null。静态初始化语句以及静态初始化块将依照类定义的顺序执行。")]),a._v(" "),s("h3",{attrs:{id:"对象析构与-finalize-方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对象析构与-finalize-方法"}},[a._v("#")]),a._v(" 对象析构与 finalize 方法")]),a._v(" "),s("p",[a._v("有些面向对象的程序设计语言，特别是 C++，有显式的析构器方法，其中放置一些当对象不再使用时需要执行的清理代码。在析构器中，最常见的操作是回收分配给对象的存储空间。由于 Java 有自动的垃圾回收器，不需要人工回收内存，所以 Java 不支持析构器。")]),a._v(" "),s("p",[a._v("当然，某些对象使用了内存之外的其他资源，例如，文件或使用了系统资源的另一个对象的句柄。在这种情况下，当资源不再需要时，将其回收和再利用将显得十分重要。")]),a._v(" "),s("p",[a._v("可以为任何一个类添加 finalize 方法。finalize 方法将在垃圾回收器清除对象之前调用。在实际应用中，不要依赖于使用 finalize 方法回收任何短缺的资源，这是因为很难知道这个方法什么时候才能够调用。")]),a._v(" "),s("h2",{attrs:{id:"_3-7-包"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-7-包"}},[a._v("#")]),a._v(" 3.7 包")]),a._v(" "),s("p",[a._v("Java 允许使用包（package）将类组织起来。借助于包可以方便地组织自己的代码，并将自己的代码与别人提供的代码库分开管理。")]),a._v(" "),s("p",[a._v("标准的 Java 类库分布在多个包中，包括 java.lang、java.util 和 java.net 等。标准的 Java 包具有一个层次结构。所有标准的 Java 包都处于 java 和 javax 包层次中。")]),a._v(" "),s("p",[a._v("使用包的主要原因是确保类名的唯一性。假如两个程序员不约而同地建立了 Employee 类。只要将这些类放置在不同的包中，就不会产生冲突。事实上，为了保证包名的绝对唯一性，Sun 公司建议将公司的因特网域名（这显然是独一无二的）以逆序的形式作为包名，并且对于不同的项目使用不同的子包。")]),a._v(" "),s("h3",{attrs:{id:"类的导入"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#类的导入"}},[a._v("#")]),a._v(" 类的导入")]),a._v(" "),s("p",[a._v("一个类可以使用所属包中的所有类，以及其他包中的公有类（public class）。我们可以采用两种方式访问另一个包中的公有类。第一种方式是在每个类名之前添加完整的包名。例如")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[s("span",{pre:!0,attrs:{class:"token namespace"}},[a._v("java"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("time"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")])]),a._v("LocalDatetoday")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[s("span",{pre:!0,attrs:{class:"token namespace"}},[a._v("java"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("time"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")])]),a._v("LocalDate")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("now")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("p",[a._v("这显然很繁琐。更简单且更常用的方式是使用 import 语句。import 语句是一种引用包含在包中的类的简明描述。一旦使用了 import 语句，在使用类时，就不必写出包的全名了。")]),a._v(" "),s("p",[a._v("可以使用 import 语句导人一个特定的类或者整个包。import 语句应该位于源文件的顶部（但位于 package 语句的后面）。例如，可以使用下面这条语句导入 java.time 包中所有的类。")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("import")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token namespace"}},[a._v("java"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("time"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")])]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("p",[a._v("然后，就可以使用")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("LocalDate")]),a._v(" today "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("LocalDate")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("now")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("p",[a._v("而无须在前面加上包前缀。 还可以导人一个包中的特定类：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("import")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token namespace"}},[a._v("java"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("time"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")])]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("LocalDate")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("p",[s("code",[a._v("import java.time.*;")]),a._v(" 的语法比较简单，对代码的大小也没有任何负面影响 。")]),a._v(" "),s("p",[a._v("需要注意的是，只能使用星号 "),s("code",[a._v("*")]),a._v(" 导入一个包，而不能使用 "),s("code",[a._v("import java.*")]),a._v(" 或 "),s("code",[a._v("import java.*.*")]),a._v(" 导入以 java 为前缀的所有包。")]),a._v(" "),s("h3",{attrs:{id:"静态导入"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#静态导入"}},[a._v("#")]),a._v(" 静态导入")]),a._v(" "),s("p",[a._v("import 语句不仅可以导入类，还增加了导入静态方法和静态域的功能。")]),a._v(" "),s("p",[a._v("例如，如果在源文件的顶部，添加一条指令：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("import")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token namespace"}},[a._v("java"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("lang"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")])]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("*"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("p",[a._v("就可以使用 System 类的静态方法和静态域，而不必加类名前缀：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[a._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"Goodbye,World!"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// i.e., System.out")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("exit")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// i.e., System.exit")]),a._v("\n")])])]),s("p",[a._v("另外，还可以导入特定的方法或域 ：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("import")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token namespace"}},[a._v("java"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("lang"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")])]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),s("p",[a._v("实际上，是否有更多的程序员采用 System.out 或 System.exit 的简写形式，似乎是一件值得怀疑的事情。这种编写形式不利于代码的清晰度。")]),a._v(" "),s("h3",{attrs:{id:"将类版入包中"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#将类版入包中"}},[a._v("#")]),a._v(" 将类版入包中")]),a._v(" "),s("p",[a._v("要想将一个类放入包中，就必须将包的名字放在源文件的开头，包中定义类的代码之前。例如：")]),a._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("package")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token namespace"}},[a._v("com"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("example"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("corejava")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Employee")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),s("p",[a._v("如果没有在源文件中放置 package 语句，这个源文件中的类就被放置在一个默认包（defaulf package）中。默认包是一个没有名字的包。")]),a._v(" "),s("p",[a._v("将包中的文件放到与完整的包名匹配的子目录中。例如，com.example.corejava 包中的所有源文件应该被放置在子目录 com/example/corejava（Windows 中 com\\example\\corejava）中。编译器将类文件也放在相同的目录结构中。")]),a._v(" "),s("h3",{attrs:{id:"包作用域"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#包作用域"}},[a._v("#")]),a._v(" 包作用域")]),a._v(" "),s("p",[a._v("标记为 public 的部分（类、方法或变量）可以被任意的类使用；标记为 private 的部分只能被定义它们的类使用。如果没有指定 public 或 private，这个部分可以被同一个包中的所有方法访问。")]),a._v(" "),s("h2",{attrs:{id:"_3-8-类路径"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-8-类路径"}},[a._v("#")]),a._v(" 3.8 类路径")]),a._v(" "),s("p",[a._v("为了使类能够被多个程序共享，需要做到下面几点：")]),a._v(" "),s("ul",[s("li",[a._v("把类放到一个目录中，例如 /home/user/classdir。需要注意，这个目录是包树状结构的基目录。如果希望将 com.example.corejava.Employee 类添加到其中，这个 Employee.class 类文件就必须位于子目录 /home/user/classdir/com/example/corejava 中。")]),a._v(" "),s("li",[a._v("将 JAR 文件放在一个目录中，例如：/home/user/archives。")]),a._v(" "),s("li",[a._v("设置类路径（classpath）。类路径是所有包含类文件的路径的集合。")])]),a._v(" "),s("p",[a._v("在 UNIX 环境中，类路径中的不同项目之间采用冒号 "),s("code",[a._v(".")]),a._v(" 分隔：")]),a._v(" "),s("p",[s("code",[a._v("/home/user/classdir:.:/home/user/archives/archive.jar")])]),a._v(" "),s("p",[a._v("在 Windows 环境中，则以分号 "),s("code",[a._v(";")]),a._v(" 分隔：")]),a._v(" "),s("p",[s("code",[a._v("C:\\classdir;.;C:\\archives\\archive.jar")])]),a._v(" "),s("p",[a._v("在上述两种情况中，句点 "),s("code",[a._v(".")]),a._v(" 表示当前目录。")]),a._v(" "),s("p",[a._v("类路径包括")]),a._v(" "),s("ul",[s("li",[a._v("基目录 "),s("code",[a._v("/home/user/classdir")]),a._v(" 或 "),s("code",[a._v("C:\\classdir")])]),a._v(" "),s("li",[a._v("当前目录 "),s("code",[a._v(".")])]),a._v(" "),s("li",[a._v("JAR 文件 "),s("code",[a._v("/home/user/archives/archive.jar")]),a._v(" 或 "),s("code",[a._v("C:\\archives\\archive.jar")])])]),a._v(" "),s("p",[a._v("由于运行时库文件（rt.jar 和 jre/lib 与 jre/lib/ext 目录下的一些其他的 JAR 文件）会被自动地搜索，所以不必将它们显式地列在类路径中。")]),a._v(" "),s("h3",{attrs:{id:"设置类路径"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#设置类路径"}},[a._v("#")]),a._v(" 设置类路径")]),a._v(" "),s("p",[a._v("建议采用 "),s("code",[a._v("-classpath")]),a._v("（或 "),s("code",[a._v("-cp")]),a._v("）选项指定类路径：")]),a._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[a._v("java -classpath /home/user/classdir:.:/home/user/archives/archive.jar MyProg\n")])])]),s("p",[a._v("或者")]),a._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[a._v("java -classpath C:"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("\\")]),a._v("classdir"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("C:"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("\\")]),a._v("archives"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("\\")]),a._v("archive.jar MyProg\n")])])]),s("p",[a._v("整个指令应该书写在一行中。将这样一个长的命令行放在一个 shell 脚本或一个批处理文件中是一个不错的主意。")]),a._v(" "),s("h2",{attrs:{id:"_3-9-文档注释"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-9-文档注释"}},[a._v("#")]),a._v(" 3.9 文档注释")]),a._v(" "),s("p",[a._v("// TODO")]),a._v(" "),s("p",[a._v("157 / 731")])])}),[],!1,null,null,null);t.default=e.exports}}]);