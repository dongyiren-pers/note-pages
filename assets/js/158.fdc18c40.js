(window.webpackJsonp=window.webpackJsonp||[]).push([[158],{1090:function(t,s,a){"use strict";a.r(s);var e=a(14),i=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"redis-简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-简介"}},[t._v("#")]),t._v(" Redis 简介")]),t._v(" "),a("p",[t._v("Redis 是一种基于内存的数据库，对数据的读写操作都是在内存中完成，因此 "),a("strong",[t._v("读写速度非常快")]),t._v("，常用于 "),a("strong",[t._v("缓存、消息队列、分布式锁等场景")]),t._v("。")]),t._v(" "),a("p",[t._v("Redis 提供了多种数据类型来支持不同的业务场景，比如 String（字符串）、List （列表）、Set（集合）、Zset（有序集合）、Hash（哈希）、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理信息）、Stream（流），并且对数据类型的操作都是 "),a("strong",[t._v("原子性")]),t._v(" 的，因为执行命令由单线程负责的，不存在并发竞争的问题。")]),t._v(" "),a("p",[t._v("除此之外，Redis 还支持 "),a("strong",[t._v("事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布/订阅模式，内存淘汰机制、过期删除机制")]),t._v(" 等等。")]),t._v(" "),a("h2",{attrs:{id:"redis-为什么那么快"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-为什么那么快"}},[t._v("#")]),t._v(" Redis 为什么那么快")]),t._v(" "),a("p",[t._v("官方使用基准测试的结果是，"),a("strong",[t._v("单线程的 Redis 吞吐量可以达到 10W/秒")]),t._v("。")]),t._v(" "),a("p",[a("strong",[t._v("内存操作")]),t._v("：Redis 的大部分操作都在内存中完成，而内存读写速度远远快于磁盘操作。这使得 Redis 能够以非常高的速度读取和写入数据，因为它不需要进行磁盘 I/O 操作。")]),t._v(" "),a("p",[a("strong",[t._v("高效的数据结构")]),t._v("：Redis 采用了高效的数据结构，如哈希表、有序集合等，这些数据结构在读写操作上都具有高效性能。例如，Redis 的哈希表可以在 "),a("eq",[a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[a("semantics",[a("mrow",[a("mi",[t._v("O")]),a("mo",{attrs:{stretchy:"false"}},[t._v("(")]),a("mn",[t._v("1")]),a("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(1)")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),a("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),a("span",{staticClass:"mopen"},[t._v("(")]),a("span",{staticClass:"mord"},[t._v("1")]),a("span",{staticClass:"mclose"},[t._v(")")])])])])]),t._v(" 的时间复杂度内完成数据的读写操作，有序集合可以在 "),a("eq",[a("span",{staticClass:"katex"},[a("span",{staticClass:"katex-mathml"},[a("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[a("semantics",[a("mrow",[a("mi",[t._v("O")]),a("mo",{attrs:{stretchy:"false"}},[t._v("(")]),a("mi",[t._v("l")]),a("mi",[t._v("o")]),a("mi",[t._v("g")]),a("mi",[t._v("N")]),a("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),a("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(log N)")])],1)],1)],1),a("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[a("span",{staticClass:"base"},[a("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),a("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),a("span",{staticClass:"mopen"},[t._v("(")]),a("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.01968em"}},[t._v("l")]),a("span",{staticClass:"mord mathdefault"},[t._v("o")]),a("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.03588em"}},[t._v("g")]),a("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.10903em"}},[t._v("N")]),a("span",{staticClass:"mclose"},[t._v(")")])])])])]),t._v(" 的时间复杂度内完成插入、删除和范围查找等操作。")],1),t._v(" "),a("p",[a("strong",[t._v("单线程模型")]),t._v("：Redis 采用单线程模型，避免了多线程之间的竞争和同步开销。在多线程环境中，线程之间需要频繁地切换和同步，而这些开销会降低系统的性能。而 Redis 的单线程模型可以专注于处理请求，避免了多线程带来的开销，提高了系统的响应速度。")]),t._v(" "),a("p",[a("strong",[t._v("I/O 多路复用")]),t._v("：Redis 利用 I/O 多路复用机制，能够处理大量的客户端 Socket 请求。这种机制允许一个线程同时监听多个 Socket，并在有请求到达时立即处理，而不需要为每个连接创建一个线程。这样可以有效地利用系统资源，提高系统的并发处理能力。")])])}),[],!1,null,null,null);s.default=i.exports}}]);