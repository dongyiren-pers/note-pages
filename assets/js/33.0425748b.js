(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{1057:function(v,_,a){"use strict";a.r(_);var t=a(14),r=Object(t.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"第3章-内存结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第3章-内存结构"}},[v._v("#")]),v._v(" 第3章 内存结构")]),v._v(" "),t("p",[v._v("内存是重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行。JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。")]),v._v(" "),t("p",[v._v("JVM 整体架构如下，中间部分就是 Java 虚拟机定义的各种运行时数据区域。")]),v._v(" "),t("p",[t("img",{attrs:{src:a(723),alt:"image-20230128000222719"}})]),v._v(" "),t("p",[v._v("JVM 定义了若干种程序运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程一一对应的数据区域会随着线程开始和结束而创建和销毁。")]),v._v(" "),t("ul",[t("li",[v._v("线程私有：程序计数器、虚拟机栈、本地方法栈")]),v._v(" "),t("li",[v._v("线程共享：堆、方法区、堆外内存")])]),v._v(" "),t("h2",{attrs:{id:"_3-1-程序计数器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-程序计数器"}},[v._v("#")]),v._v(" 3.1 程序计数器")]),v._v(" "),t("p",[v._v("程序计数器是一块较小的内存空间，可以看作是 "),t("strong",[v._v("当前线程正在执行的字节码的行号指示器")]),v._v("。")]),v._v(" "),t("h3",{attrs:{id:"功能"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#功能"}},[v._v("#")]),v._v(" 功能")]),v._v(" "),t("p",[v._v("程序计数器用来存储指向下一条指令（即将要执行的指令代码）的地址。由执行引擎读取下一条指令。")]),v._v(" "),t("p",[t("img",{attrs:{src:a(724),alt:"image-20230128001657008"}})]),v._v(" "),t("h3",{attrs:{id:"概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[v._v("#")]),v._v(" 概述")]),v._v(" "),t("p",[v._v("程序计数器是一块较小的内存空间，可以看作是 "),t("strong",[v._v("当前线程所执行的字节码的行号指示器")]),v._v("。在 Java 虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都依赖程序计数器完成。")]),v._v(" "),t("p",[v._v("由于 Java 虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为 "),t("strong",[v._v("“线程私有”")]),v._v(" 的内存。")]),v._v(" "),t("p",[v._v("如果线程正在执行的是一个 Java 方法，这个计数器 "),t("strong",[v._v("记录的是正在执行的虚拟机字节码指令的地址")]),v._v("；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。此内存区域是唯一一个在《Java 虚拟机规范》中 "),t("strong",[v._v("没有规定任何 OutOfMemoryError 情况")]),v._v(" 的区域。")]),v._v(" "),t("h2",{attrs:{id:"_3-2-虚拟机栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-虚拟机栈"}},[v._v("#")]),v._v(" 3.2 虚拟机栈")]),v._v(" "),t("h3",{attrs:{id:"概述-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概述-2"}},[v._v("#")]),v._v(" 概述")]),v._v(" "),t("p",[v._v("虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个 "),t("strong",[v._v("栈帧")]),v._v(" 用于存储 "),t("strong",[v._v("局部变量表、操作数栈、动态链接、方法出口")]),v._v(" 等信息。")]),v._v(" "),t("p",[t("strong",[v._v("特点")]),v._v("：")]),v._v(" "),t("ul",[t("li",[v._v("栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器")]),v._v(" "),t("li",[v._v("JVM 直接对虚拟机栈的操作只有两个：每个方法执行，伴随着入栈；方法执行结束出栈")]),v._v(" "),t("li",[v._v("栈不存在垃圾回收问题")])]),v._v(" "),t("p",[t("strong",[v._v("栈中可能出现的异常")]),v._v("：")]),v._v(" "),t("p",[v._v("《Java 虚拟机规范》允许虚拟机栈的大小是动态的或者是固定不变的。由此规定了两类异常状况：")]),v._v(" "),t("ul",[t("li",[v._v("如果采用固定大小的虚拟机栈，栈的大小直接决定了函数调用的最大可达深度。如果 "),t("strong",[v._v("线程请求的栈深度大于虚拟机所允许的深度")]),v._v("，JVM 将会抛出一个 "),t("strong",[v._v("StackOverflowError")]),v._v(" 异常。")]),v._v(" "),t("li",[v._v("如果虚拟机栈可以动态扩展，并且在尝试扩展的时候 "),t("strong",[v._v("无法申请到足够的内存")]),v._v("，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 JVM 将会抛出一个 "),t("strong",[v._v("OutOfMemoryError")]),v._v(" 异常。")])]),v._v(" "),t("p",[v._v("通过参数 "),t("code",[v._v("-Xss")]),v._v(" 可以设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度。")]),v._v(" "),t("h3",{attrs:{id:"栈帧"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#栈帧"}},[v._v("#")]),v._v(" 栈帧")]),v._v(" "),t("p",[v._v("栈中的数据是以 "),t("strong",[v._v("栈帧（Stack Frame）")]),v._v(" 的格式存在，在线程上正在执行的每个方法都各自有对应的一个栈帧。栈帧是一个内存区块，维系着方法执行过程中的各种数据信息。")]),v._v(" "),t("h3",{attrs:{id:"栈运行原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#栈运行原理"}},[v._v("#")]),v._v(" 栈运行原理")]),v._v(" "),t("p",[v._v("JVM 直接对虚拟机栈的操作只有两个，对栈帧的 "),t("strong",[v._v("压栈")]),v._v(" 和 "),t("strong",[v._v("出栈")]),v._v("，遵循 “先进后出” 原则。")]),v._v(" "),t("p",[v._v("在一条活动线程中，一个时间点只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为 "),t("strong",[v._v("当前栈帧（Current Frame）")]),v._v("，与当前栈帧对应的方法就是 "),t("strong",[v._v("当前方法（Current Method）")]),v._v("，定义这个方法的类就是 "),t("strong",[v._v("当前类（Current Class）")]),v._v("。")]),v._v(" "),t("p",[v._v("执行引擎运行的所有字节码指令只针对当前栈帧进行操作。")]),v._v(" "),t("p",[v._v("如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，称为新的当前栈帧。当前方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。")]),v._v(" "),t("p",[v._v("IDEA 在 debug 时候，可以在 debug 窗口看到 Frames 中各种方法的压栈和出栈情况：")]),v._v(" "),t("p",[t("img",{attrs:{src:a(725),alt:"image-20230128004109719"}})]),v._v(" "),t("h3",{attrs:{id:"栈帧结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#栈帧结构"}},[v._v("#")]),v._v(" 栈帧结构")]),v._v(" "),t("p",[t("img",{attrs:{src:a(726),alt:"image-20230128004459542"}})]),v._v(" "),t("div",{staticClass:"subtitle"},[t("p",[v._v("局部变量表")])]),t("p",[v._v("局部变量表主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型）。")]),v._v(" "),t("div",{staticClass:"subtitle"},[t("p",[v._v("操作数栈")])]),t("p",[v._v("操作数栈主要保存计算过程的中间结果，同时作为计算过程中临时变量的存储空间。")]),v._v(" "),t("div",{staticClass:"subtitle"},[t("p",[v._v("动态链接")])]),t("p",[v._v("在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在 Class 文件的常量池中。"),t("strong",[v._v("描述一个方法调用了另外的其他方法时")]),v._v("，就是通过常量池中 "),t("strong",[v._v("指向方法的符号引用")]),v._v(" 来表示的，动态链接的作用就是为了 "),t("strong",[v._v("将这些符号引用转换为调用方法的直接引用")]),v._v("。")]),v._v(" "),t("p",[t("img",{attrs:{src:a(727),alt:"image-20230128005332723"}})]),v._v(" "),t("div",{staticClass:"subtitle"},[t("p",[v._v("方法返回地址（方法出口）")])]),t("p",[v._v("方法返回地址存放调用该方法的 PC 寄存器的值。")]),v._v(" "),t("div",{staticClass:"subtitle"},[t("p",[v._v("附加信息")])]),t("p",[v._v("栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息，但这些信息取决于具体的虚拟机实现。")]),v._v(" "),t("h2",{attrs:{id:"_3-3-本地方法栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-本地方法栈"}},[v._v("#")]),v._v(" 3.3 本地方法栈")]),v._v(" "),t("h3",{attrs:{id:"概述-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概述-3"}},[v._v("#")]),v._v(" 概述")]),v._v(" "),t("p",[v._v("本地方法栈（Native Method Stacks）与虚拟机栈发挥的作用是非常相似的，其区别是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而 "),t("strong",[v._v("本地方法栈则是为虚拟机使用到的本地（Native）方法服务")]),v._v("。")]),v._v(" "),t("p",[v._v("允许线程使用固定或者可动态扩展的内存大小：")]),v._v(" "),t("ul",[t("li",[v._v("如果线程请求分配的栈容量超过本地方法栈允许的最大容量，JVM 将会抛出一个 StackOverflowError 异常。")]),v._v(" "),t("li",[v._v("如果本地方法栈可以动态扩展，但在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 JVM 将会抛出一个 OutofMemoryError 异常。")])]),v._v(" "),t("p",[v._v("在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一。")]),v._v(" "),t("blockquote",[t("p",[t("strong",[v._v("栈是运行时的单位，而堆是存储的单位")]),v._v("。")]),v._v(" "),t("p",[v._v("栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪。")])]),v._v(" "),t("h2",{attrs:{id:"_3-4-堆"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-堆"}},[v._v("#")]),v._v(" 3.4 堆")]),v._v(" "),t("h3",{attrs:{id:"内存划分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存划分"}},[v._v("#")]),v._v(" 内存划分")]),v._v(" "),t("p",[v._v("对于大多数应用，Java 堆是 JVM 管理的内存中最大的一块，"),t("strong",[v._v("被所有线程共享")]),v._v("。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数据都在这里分配内存。")]),v._v(" "),t("p",[v._v("根据《Java 虚拟机规范》的规定，Java 堆可以处于物理上不连续的内存空间中，但在逻辑上应该被视为连续的，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但对于大对象（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。")]),v._v(" "),t("p",[v._v("为了进行高效的垃圾回收，虚拟机把堆内存 "),t("strong",[v._v("逻辑上")]),v._v(" 划分成三块区域：")]),v._v(" "),t("ul",[t("li",[v._v("新生代：新对象和没达到一定年龄的对象都在新生代")]),v._v(" "),t("li",[v._v("老年代：被长时间使用的对象，老年代的内存空间应该要比年轻代更大")]),v._v(" "),t("li",[v._v("元空间（JDK1.8 之前叫永久代）：像一些方法中的操作临时对象等，JDK1.8 之前是占用 JVM 内存，JDK1.8 之后直接使用物理内存。")])]),v._v(" "),t("p",[t("img",{attrs:{src:a(728),alt:"image-20230128011513623"}})]),v._v(" "),t("div",{staticClass:"anchor",attrs:{id:"新生代（young-generation）"}},[v._v("新生代（Young Generation）")]),t("p",[v._v("年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。这种垃圾收集称为 "),t("strong",[v._v("Minor GC")]),v._v("。年轻一代被分为三个部分——"),t("strong",[v._v("伊甸园（Eden Memory）")]),v._v(" 和 "),t("strong",[v._v("两个幸存区（Survivor Memory，被称为 from/to 或 s0/s1）")]),v._v("，默认比例是 8:1:1。")]),v._v(" "),t("p",[v._v("大多数新创建的对象都位于 Eden 内存空间中。当 Eden 空间被对象填充时，执行 Minor GC，并将所有幸存者对象移动到一个幸存者空间中。Minor GC 检查幸存者对象，并将它们移动到另一个幸存者空间。因此，一个幸存者空间总是空的。")]),v._v(" "),t("p",[v._v("经过多次 GC 循环后存活下来的对象被移动到老年代。通常，这是通过设置年轻一代对象的年龄阈值来实现的，然后他们才有资格提升到老一代。")]),v._v(" "),t("div",{staticClass:"anchor",attrs:{id:"老年代（old-generation）"}},[v._v("老年代（Old Generation）")]),t("p",[v._v("旧的一代内存包含那些经过许多轮小型 GC 后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾收集称为 "),t("strong",[v._v("Major GC")]),v._v("，通常需要更长的时间。")]),v._v(" "),t("p",[v._v("大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在 Eden 区和两个Survivor 区之间发生大量的内存拷贝。")]),v._v(" "),t("div",{staticClass:"subtitle"},[t("p",[v._v("元空间")])]),t("p",[v._v("不管是 JDK8 之前的永久代，还是 JDK8 及以后的元空间，都可以看作是 《Java 虚拟机规范》中方法区的实现。")]),v._v(" "),t("p",[v._v("虽然《Java 虚拟机规范》把方法区描述为堆的一个逻辑部分，但它却有一个别名叫 Non-Heap（非堆），目的是与 Java 堆区分开来。")]),v._v(" "),t("h3",{attrs:{id:"设置堆内存大小"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设置堆内存大小"}},[v._v("#")]),v._v(" 设置堆内存大小")]),v._v(" "),t("p",[v._v("Java 堆用于存储 Java 对象实例，那么堆的大小在 JVM 启动的时候就确定了，我们可以通过 "),t("strong",[v._v("-Xms 和 -Xmx")]),v._v(" 来设定：")]),v._v(" "),t("ul",[t("li",[v._v("-Xms 用来表示堆的起始内存，等价于 -XX:InitialHeapSize")]),v._v(" "),t("li",[v._v("-Xmx 用来表示堆的最大内存，等价于 -XX:MaxHeapSize")])]),v._v(" "),t("p",[v._v("如果堆的内存大小超过 -Xmx 设定的最大内存，就会抛出 OutOfMemoryError 异常。")]),v._v(" "),t("p",[v._v("我们通常会将 -Xms 和 -Xmx 两个参数配置为相同的值，其目的是为了能够在垃圾回收机制清理完堆区后不再需要重新分隔计算堆的大小，从而提高性能。")]),v._v(" "),t("p",[v._v("默认情况下，初始堆内存大小为：电脑内存大小/64；默认情况下，最大堆内存大小为：电脑内存大小/4。")]),v._v(" "),t("p",[v._v("默认情况下 "),t("strong",[v._v("新生代和老年代的比例")]),v._v(" 是 1:2，可以通过 "),t("strong",[v._v("–XX:NewRatio")]),v._v(" 配置。")]),v._v(" "),t("p",[t("strong",[v._v("新生代中的 Eden : From Survivor : To Survivor 的比例")]),v._v("是 8:1:1，可以通过 "),t("strong",[v._v("-XX:SurvivorRatio")]),v._v(" 配置。")]),v._v(" "),t("p",[v._v("若在 JDK 7 中开启了 "),t("strong",[v._v("-XX:+UseAdaptiveSizePolicy")]),v._v("，JVM 会动态调整 JVM 堆中各个区域的大小以及进入老年代的年龄。此时 –XX:NewRatio 和 -XX:SurvivorRatio 将会失效，而 JDK 8 是默认开启 -XX:+UseAdaptiveSizePolicy，每次 GC 后都会重新计算 Eden、From Survivor、To Survivor 的大小，计算依据是 GC 过程中统计的 GC 时间、吞吐量、内存占用量。")]),v._v(" "),t("h2",{attrs:{id:"_3-5-方法区"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-5-方法区"}},[v._v("#")]),v._v(" 3.5 方法区")]),v._v(" "),t("h3",{attrs:{id:"概述-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概述-4"}},[v._v("#")]),v._v(" 概述")]),v._v(" "),t("p",[v._v("方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。")]),v._v(" "),t("p",[v._v("当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区存储已加载的 "),t("strong",[v._v("类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存")]),v._v(" 等数据。")]),v._v(" "),t("p",[v._v("方法区的大小和堆空间一样，可以选择固定大小或可扩展的，方法区的大小决定了系统可以放多少个类，如果系统类太多，导致方法区溢出，根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出 OutOfMemoryError 异常。")]),v._v(" "),t("h3",{attrs:{id:"方法区、永久代和元空间"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法区、永久代和元空间"}},[v._v("#")]),v._v(" 方法区、永久代和元空间")]),v._v(" "),t("p",[t("strong",[v._v("方法区（method area）")]),v._v(" 只是 《Java 虚拟机规范》中定义的一个概念，用于存储类信息、常量池、静态变量、JIT 编译后的代码等数据，并没有规定如何去实现它，不同的厂商有不同的实现。而 "),t("strong",[v._v("永久代（PermGen）")]),v._v(" 是 Hotspot 虚拟机特有的概念，Java 8 的时候又被 "),t("strong",[v._v("元空间")]),v._v(" 取代了。")]),v._v(" "),t("p",[v._v("永久代和元空间都可以理解为方法区的落地实现。")]),v._v(" "),t("p",[t("strong",[v._v("永久代物理上是堆的一部分")]),v._v("，和新生代、老年代地址是连续的（受垃圾回收器管理）。"),t("strong",[v._v("元空间存在于本地内存")]),v._v("（常说的堆外内存，不受垃圾回收器管理），不受 JVM 限制，较难发生 OOM（都会有溢出异常）。")]),v._v(" "),t("p",[v._v("Java 7 中我们通过 -XX:PermSize 和 -xx:MaxPermSize 设置永久代参数，Java 8 之后，随着永久代的取消，这些参数也就失效了，改为通过-XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 设置元空间参数。")]),v._v(" "),t("p",[t("strong",[v._v("永久代和元空间的存储内容不同，元空间存储类的元信息，静态变量和常量池等并入堆中。")]),v._v(" 即永久代的数据被分到了堆和元空间中。")]),v._v(" "),t("p",[v._v("《Java 虚拟机规范》说方法区在逻辑上是堆的一部分，但目前实际上是与 Java 堆分开的。")]),v._v(" "),t("p",[v._v("对于方法区，Java 8 之后的变化：")]),v._v(" "),t("ul",[t("li",[v._v("移除了永久代（PermGen），替换为元空间（Metaspace）；")]),v._v(" "),t("li",[v._v("永久代中的 class metadata 转移到了 native memory（本地内存，而不是虚拟机）；")]),v._v(" "),t("li",[v._v("永久代中的 interned Strings 和 class static variables 转移到了 Java heap；")]),v._v(" "),t("li",[v._v("永久代参数 （PermSize MaxPermSize） -> 元空间参数（MetaspaceSize MaxMetaspaceSize）")])]),v._v(" "),t("h3",{attrs:{id:"设置方法区内存的大小"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#设置方法区内存的大小"}},[v._v("#")]),v._v(" 设置方法区内存的大小")]),v._v(" "),t("p",[v._v("元数据区大小可以使用参数 -XX:MetaspaceSize 和 -XX:MaxMetaspaceSize 指定。")]),v._v(" "),t("p",[v._v("对于一个 64 位的服务器端 JVM 来说，其默认的 -XX:MetaspaceSize 的值为 20.75MB，这就是初始的高水位线，一旦触及这个水位线，Full GC 将会被触发并卸载可被 GC 的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置，新的高水位线的值取决于 GC 后释放了多少元空间。如果释放的空间不足，那么在不超过 MaxMetaspaceSize 时，适当提高该值。如果释放空间过多，则适当降低该值。")]),v._v(" "),t("h3",{attrs:{id:"运行时常量池"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#运行时常量池"}},[v._v("#")]),v._v(" 运行时常量池")]),v._v(" "),t("p",[v._v("在加载类和结构到虚拟机后，就会创建对应的运行时常量池。")]),v._v(" "),t("p",[v._v("常量池表（Constant Pool Table）是 Class 文件的一部分，用于存储编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的 "),t("strong",[v._v("运行时常量池")]),v._v(" 中。")]),v._v(" "),t("p",[v._v("JVM 为每个已加载的类型（类或接口）维护一个常量池。池中的数据项通过索引访问。")]),v._v(" "),t("p",[v._v("当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛出 OutOfMemoryError 异常。")]),v._v(" "),t("h3",{attrs:{id:"字符串常量池"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字符串常量池"}},[v._v("#")]),v._v(" 字符串常量池")]),v._v(" "),t("p",[v._v("字符串常量池是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。")]),v._v(" "),t("p",[v._v("JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动到 Java 堆。")])])}),[],!1,null,null,null);_.default=r.exports},723:function(v,_,a){v.exports=a.p+"assets/img/image-20230128000222719.b4773504.png"},724:function(v,_,a){v.exports=a.p+"assets/img/image-20230128001657008.c137e6b9.png"},725:function(v,_,a){v.exports=a.p+"assets/img/image-20230128004109719.9d9170f2.png"},726:function(v,_,a){v.exports=a.p+"assets/img/image-20230128004459542.91851084.png"},727:function(v,_,a){v.exports=a.p+"assets/img/image-20230128005332723.46e28dd0.png"},728:function(v,_,a){v.exports=a.p+"assets/img/image-20230128011513623.af4055dd.png"}}]);