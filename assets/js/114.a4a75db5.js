(window.webpackJsonp=window.webpackJsonp||[]).push([[114],{1005:function(t,_,r){"use strict";r.r(_);var v=r(14),a=Object(v.a)({},(function(){var t=this,_=t.$createElement,r=t._self._c||_;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"第1章-设计模式概述"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第1章-设计模式概述"}},[t._v("#")]),t._v(" 第1章 设计模式概述")]),t._v(" "),r("h2",{attrs:{id:"_1-1-软件设计七大原则"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-软件设计七大原则"}},[t._v("#")]),t._v(" 1.1 软件设计七大原则")]),t._v(" "),r("ul",[r("li",[r("p",[r("strong",[t._v("单一职责原则")]),t._v("：一个类负责一项职责。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("里氏替换原则")]),t._v("：指的是任何基类可以出现的地方，子类一定可以出现。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("依赖倒置原则")]),t._v("：高层模块不应该依赖低层模块，二者都应该依赖其抽象；"),r("strong",[t._v("抽象不应该依赖细节，细节应该依赖抽象")]),t._v("。即针对接口编程，不要针对实现编程。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("接口隔离原则")]),t._v("：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("迪米特法则")]),t._v("：高内聚，低耦合。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("开闭原则")]),t._v("：一个软件实体如类、模块和函数应该 "),r("strong",[t._v("对扩展开放、对修改关闭")]),t._v("。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("组合/聚合复用原则")]),t._v("：尽量使用组合和聚合，少使用继承的关系来达到复用的原则。")])])]),t._v(" "),r("h2",{attrs:{id:"_1-2-设计模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-设计模式"}},[t._v("#")]),t._v(" 1.2 设计模式")]),t._v(" "),r("h3",{attrs:{id:"创建型设计模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#创建型设计模式"}},[t._v("#")]),t._v(" 创建型设计模式")]),t._v(" "),r("ul",[r("li",[r("strong",[t._v("单例模式（Singleton Pattern）")]),t._v("：确保一个类只有一个实例，并提供该实例的全局访问。")]),t._v(" "),r("li",[r("strong",[t._v("简单工厂（Simple Factory）")]),t._v("：把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化，这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。")]),t._v(" "),r("li",[r("strong",[t._v("工厂方法模式（Factory Method Pattern）")]),t._v("：定义了一个用于创建对象的接口，但将具体对象的创建延迟到子类中进行。工厂方法模式通过将对象的实例化推迟到子类来实现解耦，使得客户端代码与具体对象的创建过程分离。")]),t._v(" "),r("li",[r("strong",[t._v("抽象工厂（Abstract Factory Pattern）")]),t._v("：抽象工厂模式创建的是对象家族，即很多对象而不是一个对象，并且这些对象是相关的，必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。")]),t._v(" "),r("li",[r("strong",[t._v("生成器模式（Builder Pattern）")]),t._v("：封装一个对象的构造过程，并允许按步骤构造。")]),t._v(" "),r("li",[r("strong",[t._v("原型模式（Prototype Pattern）")]),t._v("：使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。")])]),t._v(" "),r("h3",{attrs:{id:"结构型设计模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#结构型设计模式"}},[t._v("#")]),t._v(" 结构型设计模式")]),t._v(" "),r("ul",[r("li",[r("p",[r("strong",[t._v("外观模式（Facade Pattern）")]),t._v("：当一个系统或子系统变得非常复杂，拥有大量的类和接口时，对这个系统的直接使用可能会变得困难且混乱。Facade模式通过提供一个统一的、高层次的接口来隐藏系统的复杂性，从而让客户端能够更简单地与系统交互。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("适配器模式（Adapter Pattern）")]),t._v("：允许将一个类的接口转换为客户端期望的另一个接口，让原本接口不兼容的类可以合作无间。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("桥接模式（Bridge Pattern）")]),t._v("：通过创建一个桥接接口，将抽象部分和实现部分解耦，使得它们可以独立地进行扩展和修改，而不会相互影响。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("组合模式（Composite Pattern）")]),t._v("：允许将对象组合成树形结构来表现 “整体/部分” 层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("装饰者模式（Decorator Pattern）")]),t._v("：动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("享元模式（Flyweight Pattern）")]),t._v("：利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。它让某个类的一个实例能用来提供许多 “虚拟实例”。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("代理模式（Proxy pattern）")]),t._v("：通过创建一个代理对象来控制对其他对象的访问。代理对象充当原始对象的中间人，客户端与代理对象进行交互，并由代理对象将请求传递给原始对象，以实现间接访问和控制。")])])]),t._v(" "),r("h3",{attrs:{id:"行为型设计模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#行为型设计模式"}},[t._v("#")]),t._v(" 行为型设计模式")]),t._v(" "),r("ul",[r("li",[r("p",[r("strong",[t._v("策略模式（Strategy Pattern）")]),t._v("：定义了一系列可互换的算法或策略，并使得这些算法或策略可以独立于客户端而变化。策略模式通过将算法的实现封装在不同的策略类中，并将其作为对象之间的可互换组件来使用。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("模板方法模式（Template Pattern）")]),t._v("：定义了一个算法的框架，将具体的实现步骤延迟到子类中。模板方法通过将算法的骨架固定下来，但允许子类在特定步骤上进行自定义实现，以满足不同的需求。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("命令模式（Command Pattern）")]),t._v("：将 “请求” 封闭成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("观察者模式（Observer Pattern）")]),t._v("：定义了一种一对多的依赖关系，使得当一个对象的状态发生变化时，所有依赖于它的对象都会得到通知并自动更新。观察者模式将被观察者（主题）和观察者分离，使它们能够独立地进行变化和扩展。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("责任链模式（Chain of Responsibility Pattern）")]),t._v("：将请求的发送者和接收者解耦，并允许多个对象都有机会处理该请求。责任链模式形成一个链式结构，每个处理者都有机会处理请求，直到请求被处理或者到达链的末尾。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("访问者模式（Visitor Pattern）")]),t._v("：当你想要为一个对象的组合增加新的能力，且封装并不重要时，就使用访问者模式。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("状态模式（State Pattern）")]),t._v("：允许对象在内部状态改变时改变它的行为，对象看起来好象改了它的类。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("迭代器模式（Iterator Pattern）")]),t._v("：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("中介者模式（Mediator pattern）")]),t._v(" ：使用中介者模式来集中相关对象之间复杂的沟通和控制方式。")])]),t._v(" "),r("li",[r("p",[r("strong",[t._v("备忘录模式（Memento Pattern）")]),t._v("：当需要让对象返回之前的状态时，使用备忘录模式。")])])])])}),[],!1,null,null,null);_.default=a.exports}}]);