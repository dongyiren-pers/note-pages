(window.webpackJsonp=window.webpackJsonp||[]).push([[131],{1035:function(t,e,v){"use strict";v.r(e);var _=v(14),r=Object(_.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"消息队列"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#消息队列"}},[t._v("#")]),t._v(" 消息队列")]),t._v(" "),v("p"),v("div",{staticClass:"table-of-contents"},[v("ul",[v("li",[v("a",{attrs:{href:"#基础"}},[t._v("基础")]),v("ul",[v("li",[v("a",{attrs:{href:"#消息队列的优点和缺点"}},[t._v("消息队列的优点和缺点")])]),v("li",[v("a",{attrs:{href:"#常见消息队列的比较"}},[t._v("常见消息队列的比较")])])])]),v("li",[v("a",{attrs:{href:"#rocketmq"}},[t._v("RocketMQ")]),v("ul",[v("li",[v("a",{attrs:{href:"#如何解决消息丢失"}},[t._v("如何解决消息丢失")])]),v("li",[v("a",{attrs:{href:"#如何解决消息重复"}},[t._v("如何解决消息重复")])]),v("li",[v("a",{attrs:{href:"#如何解决消息堆积"}},[t._v("如何解决消息堆积")])]),v("li",[v("a",{attrs:{href:"#如何实现顺序消息"}},[t._v("如何实现顺序消息")])]),v("li",[v("a",{attrs:{href:"#消息事务-半消息-是什么"}},[t._v("消息事务（半消息）是什么")])])])])])]),v("p"),t._v(" "),v("h2",{attrs:{id:"基础"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[t._v("#")]),t._v(" 基础")]),t._v(" "),v("h3",{attrs:{id:"消息队列的优点和缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#消息队列的优点和缺点"}},[t._v("#")]),t._v(" 消息队列的优点和缺点")]),t._v(" "),v("div",{staticClass:"tag-group"},[v("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("京东")])],1),v("p",[t._v("优点：")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("解耦")]),t._v("： 消息队列能够解耦系统之间的强耦合关系，允许系统彼此独立地演化和升级。消息发送者只需将消息发送到消息队列，而无需直接知道消息接收者是谁，从而实现了松耦合。")]),t._v(" "),v("li",[v("strong",[t._v("异步")]),t._v("：通过消息队列，发送者可以异步地将消息发送到队列中，而无需等待接收者的响应。这在需要长时间处理的操作中尤其有用，如发送电子邮件等。提高了系统的响应性能和吞吐量。")]),t._v(" "),v("li",[v("strong",[t._v("削峰")]),t._v("：消息队列可以处理突发的大量请求，从而平滑系统的负载。系统可以将请求缓存到消息队列中，然后逐渐消费，防止系统崩溃或者过载。")])]),t._v(" "),v("p",[t._v("缺点：")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("复杂度增加")]),t._v("：引入消息队列会增加系统的复杂性。需要考虑消息的发送、消费、确认、重试等多个方面的问题，从而导致开发、维护和排查问题的难度增加。")]),t._v(" "),v("li",[v("strong",[t._v("一致性问题")]),t._v("：在一些场景下，如分布式事务，消息队列可能引发一致性问题。例如，消息发送成功后，但消息消费失败，可能导致数据不一致。")]),t._v(" "),v("li",[v("strong",[t._v("消息顺序性：")]),t._v(" 消息队列的一些实现可能无法保证消息的严格顺序性，而这对某些业务场景可能是一个问题。在需要确保顺序性的情况下，需要特别注意。")]),t._v(" "),v("li",[v("strong",[t._v("性能影响：")]),t._v(" 引入消息队列可能会对系统性能产生影响。消息的序列化、反序列化、存储和网络传输都需要一定的资源，如果消息的吞吐量非常大，可能会对系统造成压力。")])]),t._v(" "),v("h3",{attrs:{id:"常见消息队列的比较"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常见消息队列的比较"}},[t._v("#")]),t._v(" 常见消息队列的比较")]),t._v(" "),v("div",{staticStyle:{"font-size":"14px"}},[v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}}),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("ActiveMQ")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("RabbitMQ")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("RocketmQ")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("Kafka")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[v("strong",[t._v("性能")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("6000/单机")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("12000/单机")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("10万/单机")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("100万/单机")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[v("strong",[t._v("持久化")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("支持（性能下降）")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("支持（性能下降）")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("天生支持")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("天生支持")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[v("strong",[t._v("语言支持")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("主流语言")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("主流语言")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("Java")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("主流语言")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[v("strong",[t._v("优点")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}}),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("高可用（Erlang）")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("模型简单、接口易用"),v("br"),t._v("阿里大规模运用"),v("br"),t._v("性能比较好")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("天生分布式"),v("br"),t._v("性能最好、大数据支持")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[v("strong",[t._v("缺点")])]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("缺乏大规模的运用"),v("br"),t._v("不推荐")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("内部机制很难去了解"),v("br"),t._v("集群不支持动态扩展")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("仅支持 Java")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("运维难度大"),v("br"),t._v("带宽有一定要求")])])])])]),v("h2",{attrs:{id:"rocketmq"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#rocketmq"}},[t._v("#")]),t._v(" RocketMQ")]),t._v(" "),v("h3",{attrs:{id:"如何解决消息丢失"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何解决消息丢失"}},[t._v("#")]),t._v(" 如何解决消息丢失")]),t._v(" "),v("p",[v("strong",[t._v("消息发送阶段")]),t._v("：主要通过请求确认机制，保证消息可靠传递。")]),t._v(" "),v("p",[t._v("RocketMQ 提供了发送 "),v("RouterLink",{attrs:{to:"/rocket-mq/3jgi5r/#发送范例"}},[v("strong",[t._v("同步、异步和单向")])]),t._v(" 的多种范例。同步和异步发送能够保证消息不丢失：")],1),t._v(" "),v("ul",[v("li",[t._v("同步发送的时候，要注意处理响应结果和异常。如果返回响应 ACK，表示消息成功发送到了 Broker，如果响应失败，或者发生其它异常，则进行重试。")]),t._v(" "),v("li",[t._v("异步发送的时候，需要在回调方法里检查，如果发送失败或者异常，则进行重试。")]),t._v(" "),v("li",[t._v("如果发生超时的情况，可以通过查询日志的 API，来检查是否在 Broker 存储成功。")])]),t._v(" "),v("p",[v("strong",[t._v("消息存储阶段")]),t._v("：通过配置 "),v("strong",[t._v("可靠性优先")]),t._v(" 的 Broker 参数来避免因为宕机丢消息，简单说就是使用 "),v("strong",[t._v("同步")]),t._v("。")]),t._v(" "),v("p",[t._v("消息只要持久化到 commitLog 日志文件中，即使 Broker 宕机，未消费的消息也能重新恢复再消费。")]),t._v(" "),v("ul",[v("li",[t._v("刷盘机制：同步刷盘和异步刷盘都可以保证消息一定存储在 PageCache 中（Broker 内存中），但是 "),v("strong",[t._v("同步刷盘更可靠")]),t._v("，它是 Producer 发送消息后等数据持久化到磁盘之后再返回响应给 Producer。")]),t._v(" "),v("li",[t._v("集群部署：Broker 通过主从集群来保证高可用，主从间复制支持同步和异步模式。"),v("strong",[t._v("同步复制更可靠")]),t._v("，可以保证即使 Master 宕机，消息在 Slave 中仍有备份，保证了消息不会丢失。")])]),t._v(" "),v("p",[v("strong",[t._v("消息消费阶段")]),t._v("：Consumer 保证消息成功消费的关键在于确认的时机，不要在收到消息后就立即发送消费确认，而是 "),v("strong",[t._v("在执行完所有消费业务逻辑后，再发送消费确认")]),t._v("。消息队列维护了消费到的位置，即使业务逻辑执行失败了，没有确认，再去队列拉取消息，就还是之前的一条。")]),t._v(" "),v("h3",{attrs:{id:"如何解决消息重复"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何解决消息重复"}},[t._v("#")]),t._v(" 如何解决消息重复")]),t._v(" "),v("p",[t._v("RocketMQ 能保证消息不丢失，但 "),v("strong",[t._v("无法保证消息不重复")]),t._v("，实现幂等的最好方式是从业务逻辑上入手，将消费的业务逻辑设计成具备 "),v("strong",[t._v("幂等性")]),t._v(" 的操作。")]),t._v(" "),v("h3",{attrs:{id:"如何解决消息堆积"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何解决消息堆积"}},[t._v("#")]),t._v(" 如何解决消息堆积")]),t._v(" "),v("p",[v("strong",[t._v("场景一")]),t._v("：新上线的消费者功能有 BUG，"),v("strong",[t._v("消息无法被消费")]),t._v("。")]),t._v(" "),v("p",[t._v("解决场景一，要做好 "),v("strong",[t._v("灰度发布")]),t._v("。每次新功能上线前，选取一定比例的消费实例做灰度，若出现问题，及时回滚；若消费者消费正常，平稳运行一段时间后，再升级其它实例。如果需要按规则选出一部分账号做灰度，则需要做好消息过滤， 让正常消费实例排除灰度消息，让灰度消费实例过滤出灰度消息。")]),t._v(" "),v("p",[v("strong",[t._v("场景二")]),t._v("：消费者实例宕机或因网络等问题暂时 "),v("strong",[t._v("无法同 Broker 建立连接")]),t._v("。")]),t._v(" "),v("p",[t._v("解决场景二，要做到 "),v("strong",[t._v("多活")]),t._v("。极端情况下，当一个集群内消费实例全部宕机时，需要做到让其他集群内的消费实例正常消费消息。同时，若一个集群内 Broker 全部宕机，需要支持生产者将消息发送至其它集群的 Broker。")]),t._v(" "),v("p",[v("strong",[t._v("场景三")]),t._v("：生产者短时间内推送大量消息至 Broker，"),v("strong",[t._v("消费者消费能力不足")]),t._v("。")]),t._v(" "),v("p",[t._v("解决场景三，要 "),v("strong",[t._v("增强消费能力")]),t._v("。增强消费能力，主要是 "),v("strong",[t._v("增加消费者线程数")]),t._v(" 或 "),v("strong",[t._v("增加消费者实例个数")]),t._v("。")]),t._v(" "),v("ul",[v("li",[t._v("增加消费者线程数，要注意消费者及其下游服务的消费能力，上线前就要将线程池参数调至最优状态。")]),t._v(" "),v("li",[t._v("增加消费者实例个数，要注意 Queue 数量。如果消费实例数量超过 Queue 数量，多出的消费实例分不到 Queue。如果消费实例数量比 Queue 数量少，每个消费实例承载的流量是不同的。")])]),t._v(" "),v("p",[v("strong",[t._v("场景四")]),t._v("：生产者 "),v("strong",[t._v("未感知 Broker 消费堆积")]),t._v(" 持续向 Broker 推送消息。")]),t._v(" "),v("p",[t._v("解决场景四，要做到 "),v("strong",[t._v("熔断与隔离")]),t._v("。当一个 Broker 的队列出现消息积压时，要对其熔断，将其隔离，将新消息发送至其它队列，过一定的时间，再解除其隔离。")]),t._v(" "),v("h3",{attrs:{id:"如何实现顺序消息"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何实现顺序消息"}},[t._v("#")]),t._v(" 如何实现顺序消息")]),t._v(" "),v("div",{staticClass:"tag-group"},[v("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("用友")])],1),v("p",[t._v("顺序消息分为全局顺序消息与部分顺序消息，全局顺序是指某个 Topic 下的所有消息都要保证顺序；部分顺序消息只要保证每一组消息被顺序消费即可。")]),t._v(" "),v("p",[t._v("顺序消费实际上有两个核心点，一个是生产者有序发送，另一个是消费者有序消费。")]),t._v(" "),v("p",[v("strong",[t._v("生产者有序发送")]),t._v("：只需要保证一组相同的消息按照给定的顺序 "),v("strong",[t._v("存入同一个队列")]),t._v(" 中，就能保证生产者有序发送。"),v("strong",[t._v("RocketMQ 支持生产者投放消息时自定义投放策略")]),t._v("，实现 "),v("strong",[t._v("MessageQueueSelector 接口")]),t._v("，使用 "),v("strong",[t._v("Hash 取模法")]),t._v(" 来保证同一个订单在同一个队列中")]),t._v(" "),v("p",[v("strong",[t._v("消费者有序消费")]),t._v("：MessageListener 回调提供了两种消费模式：有序消费模式 MessageListenerOrderly 和并发消费模式 MessageListenerConcurrently。"),v("strong",[t._v("MessageListenerOrderly")]),t._v(" 通过加 "),v("RouterLink",{attrs:{to:"/rocket-mq/e70sbg/#broker-的分布式锁"}},[v("strong",[t._v("Broker 的分布式锁")])]),t._v(" 和 "),v("RouterLink",{attrs:{to:"/rocket-mq/e70sbg/#messagequeue-的本地-synchronized-锁"}},[v("strong",[t._v("Queue 的本地锁")])]),t._v(" 保证同时只有一条线程去消费一个队列上的数据。")],1),t._v(" "),v("h3",{attrs:{id:"消息事务-半消息-是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#消息事务-半消息-是什么"}},[t._v("#")]),t._v(" 消息事务（半消息）是什么")]),t._v(" "),v("div",{staticClass:"tag-group"},[v("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("滴滴")])],1),v("p",[v("strong",[t._v("事务消息")]),t._v("：MQ 提供类似 X/Open XA 的分布事务功能，通过事务消息能达到分布式事务的最终一致。")]),t._v(" "),v("p",[v("strong",[t._v("半消息")]),t._v("：暂不能投递的消息，发送方已经将消息成功发送到了 MQ 服务端，但是服务端未收到生产者对该消息的二次确认，此时该消息被标记成“暂不能投递”状态，处于该种状态下的消息即半消息。")]),t._v(" "),v("p",[v("strong",[t._v("半消息回查")]),t._v("：由于网络闪断、生产者应用重启等原因，导致某条事务消息的二次确认丢失，MQ 服务端通过扫描发现某条消息长期处于“半消息”时，需要主动向消息生产者询问该消息的最终状态（Commit 或是 Rollback），该过程即消息回查。")])])}),[],!1,null,null,null);e.default=r.exports}}]);