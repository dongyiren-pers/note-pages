(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{564:function(t,s,a){t.exports=a.p+"assets/img/image-20220611211546599.5b541e8a.png"},565:function(t,s,a){t.exports=a.p+"assets/img/image-20220611145811015.461744c0.png"},983:function(t,s,a){"use strict";a.r(s);var _=a(14),v=Object(_.a)({},(function(){var t=this,s=t.$createElement,_=t._self._c||s;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"第7章-链接"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第7章-链接"}},[t._v("#")]),t._v(" 第7章 链接")]),t._v(" "),_("h2",{attrs:{id:"_7-1-编译器驱动程序"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-编译器驱动程序"}},[t._v("#")]),t._v(" 7.1 编译器驱动程序")]),t._v(" "),_("p",[t._v("多数编译系统提供编译驱动程序（compiler driver），它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。")]),t._v(" "),_("div",{staticClass:"language- extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("gcc -O2 -g -o p main.c swap.c  \n")])])]),_("p",[_("img",{attrs:{src:a(564),alt:"image-20220611211546599"}})]),t._v(" "),_("h2",{attrs:{id:"_7-2-静态链接"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-静态链接"}},[t._v("#")]),t._v(" 7.2 静态链接")]),t._v(" "),_("p",[t._v("像 Linux LD 程序这样的静态链接器以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码和数据节（section）组成，每一节都是一个连续的字节序列。指令在一节中，初始化了的全局变量在另一节中，而未初始化的变量又在另外节中。")]),t._v(" "),_("p",[t._v("为了构造可执行文件，链接器必须完成两个主要任务：")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("符号解析（symbol resolution）。目标文件定义和引用符号，"),_("strong",[t._v("每个符号对应于一个函数、一个全局变量或一个静态变量（即 C 语言中任何以 static 属性声明的变量）")]),t._v("。符号解析的目的是将每个符号引用正好和一个符号定义关联起来。")])]),t._v(" "),_("li",[_("p",[t._v("重定位（relocation）。编译器和汇编器生成从地址 0 开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。链接器使用汇编器产生的重定位条目（relocation entry）的详细指令，不加甄别地执行这样的重定位。")])])]),t._v(" "),_("h2",{attrs:{id:"_7-3-目标文件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-3-目标文件"}},[t._v("#")]),t._v(" 7.3 目标文件")]),t._v(" "),_("p",[t._v("目标文件有三种形式：")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("可重定位目标文件。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。")])]),t._v(" "),_("li",[_("p",[t._v("可执行目标文件。包含二进制代码和数据，其形式可以被直接复制到内存并执行。")])]),t._v(" "),_("li",[_("p",[t._v("共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或运行时被动态地加载进内存并链接。")])])]),t._v(" "),_("p",[t._v("编译器和汇编器生成可重定位目标文件（包括共享目标文件）。链接器生成可执行目标文件。")]),t._v(" "),_("h2",{attrs:{id:"_7-4-可重定位目标文件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-4-可重定位目标文件"}},[t._v("#")]),t._v(" 7.4 可重定位目标文件")]),t._v(" "),_("p",[_("code",[t._v(".text")]),t._v("："),_("strong",[t._v("已编译程序的机器代码")]),t._v("。")]),t._v(" "),_("p",[_("code",[t._v(".rodata")]),t._v("："),_("strong",[t._v("只读数据")]),t._v("，比如 printf 语句中的格式串和开关语句的跳转表。")]),t._v(" "),_("p",[_("code",[t._v(".data")]),t._v("："),_("strong",[t._v("已初始化的全局和静态 C 变量")]),t._v("。局部 C 变量在运行时被保存在栈中，既不出现在 "),_("code",[t._v(".data")]),t._v(" 节中，也不出现在 "),_("code",[t._v(".bss")]),t._v(" 节中")]),t._v(" "),_("p",[_("code",[t._v(".bss")]),t._v("："),_("strong",[t._v("未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量")]),t._v("。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。")]),t._v(" "),_("p",[t._v("区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为 0。")]),t._v(" "),_("p",[_("code",[t._v(".symtab")]),t._v("："),_("strong",[t._v("一个符号表，定义和引用的函数和全局变量的信息")]),t._v("。但与编译器中的符号表不同， "),_("code",[t._v(".symtab")]),t._v(" 符号表不包含局部变量的条目。")]),t._v(" "),_("p",[_("code",[t._v(".rel.text")]),t._v("："),_("strong",[t._v("一个 "),_("code",[t._v(".text")]),t._v(" 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置")]),t._v("。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改，调用本地函数的指令则不需要修改。可执行目标文件中并不需要重定位信息，通常省略，除非用户显式地指示链接器包含这些信息。")]),t._v(" "),_("p",[_("code",[t._v(".rel.data")]),t._v("："),_("strong",[t._v("被模块引用或定义的所有全局变量的重定位信息")]),t._v("。对于任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。")]),t._v(" "),_("p",[_("code",[t._v(".debug")]),t._v("："),_("strong",[t._v("一个调试符号表，其条目是程序中定义的局部变量和类型定义、程序中定义和引用的全局变量以及原始的 C 源文件")]),t._v("。只有以 "),_("code",[t._v("-g")]),t._v(" 选项调用编译器驱动程序时，才会得到这张表。")]),t._v(" "),_("p",[_("code",[t._v(".line")]),t._v("："),_("strong",[t._v("原始 C 源程序中的行号和 "),_("code",[t._v(".text")]),t._v(" 节中机器指令之间的映射")]),t._v("。只有以 "),_("code",[t._v("-g")]),t._v(" 选项调用编译器驱动程序时，才会得到这张表。")]),t._v(" "),_("p",[_("code",[t._v(".strtab")]),t._v("："),_("strong",[t._v("一个字符串表，其内容包括 "),_("code",[t._v(".symtab")]),t._v(" 和  "),_("code",[t._v(".debug")]),t._v(" 节中的符号表，以及节头部中的节名字")]),t._v("。字符串表就是以 null 结尾的字符串的序列。")]),t._v(" "),_("h2",{attrs:{id:"_7-5-符号和符号表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-5-符号和符号表"}},[t._v("#")]),t._v(" 7.5 符号和符号表")]),t._v(" "),_("p",[t._v("每个可重定位目标模块 m 都有一个符号表，它包含 m 定义和引用的符号的信息。")]),t._v(" "),_("p",[t._v("在链接器的上下文中，有三种不同的符号：")]),t._v(" "),_("ul",[_("li",[t._v("由模块 m 定义并能被其他模块引用的"),_("strong",[t._v("全局符号")]),t._v("。全局链接器符号对应于非静态的 C 函数和全局变量。")]),t._v(" "),_("li",[t._v("由其他模块定义并被模块 m 引用的全局符号。这些符号称为"),_("strong",[t._v("外部符号")]),t._v("，对应于在其他模块中定义的非静态 C 函数和全局变量。")]),t._v(" "),_("li",[t._v("只被模块 m 定义和引用的"),_("strong",[t._v("局部符号")]),t._v("。它们对应于带 static 属性的 C 函数和全局变量。这些符号在模块 m 中任何位置都可见，但是不能被其他模块引用。")])]),t._v(" "),_("h2",{attrs:{id:"_7-6-符号解析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-6-符号解析"}},[t._v("#")]),t._v(" 7.6 符号解析")]),t._v(" "),_("p",[t._v("链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义联系起来。对于那些和引用定义在相同模块中的本地符号的引用，符号解析是非常简单明了的。编译器只允许每个模块中每个本地符号只有一个定义。编译器还确保静态本地变量，它们也会有本地链接器符号，拥有唯一的名字。")]),t._v(" "),_("p",[t._v("不过，对全局符号的引用解析就棘手得多。当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，它会假设该符号是在其他某个模块中定义的，将生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用的符号，它就输出一条（通常很难阅读的）错误信息并终止。")]),t._v(" "),_("h3",{attrs:{id:"解析多重定义的全局符号"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#解析多重定义的全局符号"}},[t._v("#")]),t._v(" 解析多重定义的全局符号")]),t._v(" "),_("p",[t._v("链接器的输入是一组可重定位目标模块。每个模块定义一组符号，有些是局部的（只对定义该符号的模块可见），有些是全局的（对其他模块也可见）。如果多个模块定义同名的全局符号，如何处理呢？下面是 Linux 编译系统采用的方法。")]),t._v(" "),_("p",[t._v("在编译时，编译器向汇编器输出每个全局符号，或者是强（strong）或者是弱（weak），而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。")]),t._v(" "),_("p",[_("strong",[t._v("函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。")])]),t._v(" "),_("p",[t._v("根据强弱符号的定义， Linux 链接器使用下面的规则来处理多重定义的符号名")]),t._v(" "),_("ul",[_("li",[t._v("规则1：不允许有多个同名的强符号。")]),t._v(" "),_("li",[t._v("规则2：如果有一个强符号和多个弱符号同名，那么选择强符号。")]),t._v(" "),_("li",[t._v("规则3：如果有多个弱符号同名，那么从这些弱符号中任意选择一个。")])]),t._v(" "),_("h2",{attrs:{id:"_7-7-重定位"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-7-重定位"}},[t._v("#")]),t._v(" 7.7 重定位")]),t._v(" "),_("p",[t._v("一旦链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义（即它的一个输入目标模块中的一个符号表条目）关联起来。此时，链接器知道它的输入目标模块中的代码节和数据节的确切大小。现在就可以开始重定位步骤了，在这个步骤中，将合并输入模块，并为每个符号分配运行时地址。重定位由两步组成：")]),t._v(" "),_("ul",[_("li",[_("p",[_("strong",[t._v("重定位节和符号定义")]),t._v("。在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。例如，来自所有输入模块的 "),_("code",[t._v(".data")]),t._v(" 节被全部合并成一个节，这个节成为输出的可执行目标文件的 "),_("code",[t._v(".data")]),t._v(" 节。然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。")])]),t._v(" "),_("li",[_("p",[_("strong",[t._v("重定位节中的符号引用")]),t._v("。在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为重定位条目（relocation entry）的数据结构，我们接下来将会描述这种数据结构。")])])]),t._v(" "),_("h2",{attrs:{id:"_7-8-加载可执行目标文件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-8-加载可执行目标文件"}},[t._v("#")]),t._v(" 7.8 加载可执行目标文件")]),t._v(" "),_("p",[t._v("每个 Linux 程序都有一个运行时内存映像，类似于下图所示。在 Linux x86-64 系统中，代码段总是从地址 0x400000 处开始，后面是数据段。运行时堆在数据段之后，通过调用 malloc 库往上增长。堆后面的区域是为共享模块保留的。用户栈总是从最大的合法用户地址（"),_("eq",[_("span",{staticClass:"katex"},[_("span",{staticClass:"katex-mathml"},[_("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[_("semantics",[_("mrow",[_("msup",[_("mn",[t._v("2")]),_("mn",[t._v("48")])],1),_("mo",[t._v("−")]),_("mn",[t._v("1")])],1),_("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("2^{48}-1")])],1)],1)],1),_("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[_("span",{staticClass:"base"},[_("span",{staticClass:"strut",staticStyle:{height:"0.897438em","vertical-align":"-0.08333em"}}),_("span",{staticClass:"mord"},[_("span",{staticClass:"mord"},[t._v("2")]),_("span",{staticClass:"msupsub"},[_("span",{staticClass:"vlist-t"},[_("span",{staticClass:"vlist-r"},[_("span",{staticClass:"vlist",staticStyle:{height:"0.8141079999999999em"}},[_("span",{staticStyle:{top:"-3.063em","margin-right":"0.05em"}},[_("span",{staticClass:"pstrut",staticStyle:{height:"2.7em"}}),_("span",{staticClass:"sizing reset-size6 size3 mtight"},[_("span",{staticClass:"mord mtight"},[_("span",{staticClass:"mord mtight"},[t._v("4")]),_("span",{staticClass:"mord mtight"},[t._v("8")])])])])])])])])]),_("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}}),_("span",{staticClass:"mbin"},[t._v("−")]),_("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}})]),_("span",{staticClass:"base"},[_("span",{staticClass:"strut",staticStyle:{height:"0.64444em","vertical-align":"0em"}}),_("span",{staticClass:"mord"},[t._v("1")])])])])]),t._v("）开始，向较小内存地址增长。栈上的区域，从地址 "),_("eq",[_("span",{staticClass:"katex"},[_("span",{staticClass:"katex-mathml"},[_("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[_("semantics",[_("mrow",[_("msup",[_("mn",[t._v("2")]),_("mn",[t._v("48")])],1),_("mo",[t._v("−")]),_("mn",[t._v("1")])],1),_("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("2^{48}-1")])],1)],1)],1),_("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[_("span",{staticClass:"base"},[_("span",{staticClass:"strut",staticStyle:{height:"0.897438em","vertical-align":"-0.08333em"}}),_("span",{staticClass:"mord"},[_("span",{staticClass:"mord"},[t._v("2")]),_("span",{staticClass:"msupsub"},[_("span",{staticClass:"vlist-t"},[_("span",{staticClass:"vlist-r"},[_("span",{staticClass:"vlist",staticStyle:{height:"0.8141079999999999em"}},[_("span",{staticStyle:{top:"-3.063em","margin-right":"0.05em"}},[_("span",{staticClass:"pstrut",staticStyle:{height:"2.7em"}}),_("span",{staticClass:"sizing reset-size6 size3 mtight"},[_("span",{staticClass:"mord mtight"},[_("span",{staticClass:"mord mtight"},[t._v("4")]),_("span",{staticClass:"mord mtight"},[t._v("8")])])])])])])])])]),_("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}}),_("span",{staticClass:"mbin"},[t._v("−")]),_("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}})]),_("span",{staticClass:"base"},[_("span",{staticClass:"strut",staticStyle:{height:"0.64444em","vertical-align":"0em"}}),_("span",{staticClass:"mord"},[t._v("1")])])])])]),t._v(" 开始，是为内核（kernel）中的代码和数据保留的，所谓内核就是操作系统驻留在内存的部分。")],1),t._v(" "),_("p",[_("img",{attrs:{src:a(565),alt:"image-20220611145811015"}})]),t._v(" "),_("p",[t._v("为了简洁，我们把堆、数据和代码段画得彼此相邻，并且把栈顶放在了最大的合法用户地址处。实际上，由于 "),_("code",[t._v(".data")]),t._v(" 段有对齐要求，所以代码段和数据段之间是有间隙的。同时，分配栈、共享库和堆段运行时地址的时候，链接器还会使用地址空间布局随机化。虽然每次程序运行时这些区域的地址都会改变，它们的相对位置是不变的。")]),t._v(" "),_("p",[t._v("当加载器运行时，它创建类似于上图所示的内存映像。在程序头部表的引导下，加载器将可执行文件的片（chunk）复制到代码段和数据段。接下来，加载器跳转到程序的入口点，也就是 "),_("code",[t._v("_start")]),t._v(" 函数的地址。这个函数是在系统目标文件 ctrl.o 中定义的，对所有的 C 程序都是一样的。 "),_("code",[t._v("_start")]),t._v(" 函数调用系统启动函数 "),_("code",[t._v("__libc_start_main")]),t._v("，该函数定义在 libc.so 中。它会初始化执行环境，调用用户层的 main 函数，处理 main 函数的返回值，并且在需要的时候把控制返回给内核。")]),t._v(" "),_("h2",{attrs:{id:"_7-9-小结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-9-小结"}},[t._v("#")]),t._v(" 7.9 小结")]),t._v(" "),_("p",[t._v("链接可以在编译时由静态编译器来完成，也可以在加载时和运行时由动态链接器来完成。链接器处理称为目标文件的二进制文件，它有3种不同的形式：可重定位的、可执行的和共享的。可重定位的目标文件由静态链接器合并成一个可执行的目标文件，它可以加载到内存中并执行。共享目标文件（共享库）是在运行时由动态链接器链接和加载的，或者隐含地在调用程序被加载和开始执行时，或者根据需要在程序调用dlopen库的函数时。")]),t._v(" "),_("p",[t._v("链接器的两个主要任务是符号解析和重定位，符号解析将目标文件中的每个全局符号都绑定到一个唯一的定义，而重定位确定每个符号的最终内存地址，并修改对那些目标的引用。")]),t._v(" "),_("p",[t._v("静态链接器是由像GCC这样的编译驱动程序调用的。它们将多个可重定位目标文件合并成一个单独的可执行目标文件。多个目标文件可以定义相同的符号，而链接器用来悄悄地解析这些多重定义的规则可能在用户程序中引入微妙的错误。")]),t._v(" "),_("p",[t._v("多个目标文件可以被连接到一个单独的静态库中。链接器用库来解析其他目标模块中的符号引用。许多链接器通过从左到右的顺序扫描来解析符号引用，这是另一个引起令人迷惑的链接时错误的来源。")]),t._v(" "),_("p",[t._v("加载器将可执行文件的内容映射到内存，并运行这个程序。链接器还可能生成部分链接的可执行目标文件，这样的文件中有对定义在共享库中的例程和数据的未解析的引用。在加载时，加载器将部分链接的可执行文件映射到内存，然后调用动态链接器，它通过加载共享库和重定位程序中的引用来完成链接任务。")]),t._v(" "),_("p",[t._v("被编译为位置无关代码的共享库可以加载到任何地方，也可以在运行时被多个进程共享。为了加载链接和访问共享库的函数和数据，应用程序也可以在运行时使用动态链接器。")])])}),[],!1,null,null,null);s.default=v.exports}}]);