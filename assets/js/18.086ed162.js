(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{448:function(_,v,t){_.exports=t.p+"assets/img/image-20220610171647096.96654cf9.png"},553:function(_,v,t){_.exports=t.p+"assets/img/image-20220610163551253.697cbab3.png"},554:function(_,v,t){_.exports=t.p+"assets/img/image-20220610164511459.c16a2ffd.png"},555:function(_,v,t){_.exports=t.p+"assets/img/image-20220610191442411.709e21c1.png"},556:function(_,v,t){_.exports=t.p+"assets/img/image-20220610192523993.aab5baea.png"},557:function(_,v,t){_.exports=t.p+"assets/img/image-20220610192857012.37cf912c.png"},558:function(_,v,t){_.exports=t.p+"assets/img/image-20220610193006934.5c3096ae.png"},559:function(_,v,t){_.exports=t.p+"assets/img/image-20220610193346366.0d5efc3d.png"},560:function(_,v,t){_.exports=t.p+"assets/img/image-20220610195746144.84ad9ac6.png"},980:function(_,v,t){"use strict";t.r(v);var a=t(14),r=Object(a.a)({},(function(){var _=this,v=_.$createElement,a=_._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("h1",{attrs:{id:"第4章-处理器体系结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#第4章-处理器体系结构"}},[_._v("#")]),_._v(" 第4章 处理器体系结构")]),_._v(" "),a("h2",{attrs:{id:"_4-1-指令集结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-指令集结构"}},[_._v("#")]),_._v(" 4.1 指令集结构")]),_._v(" "),a("p",[_._v("指令集结构（ISA, Instruction Set Architecture）是微处理器的接口，包含了与该微处理器进行交互所需要的信息，但并不涉及微处理器自身如何设计和实现的细节。")]),_._v(" "),a("p",[_._v("ISA 包括：")]),_._v(" "),a("ul",[a("li",[_._v("微处理器的指令集")]),_._v(" "),a("li",[_._v("程序员可直接访问的寄存器的细节")]),_._v(" "),a("li",[_._v("访问内存所需的信息")]),_._v(" "),a("li",[_._v("微处理器如何响应中断")])]),_._v(" "),a("h3",{attrs:{id:"编译与汇编"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编译与汇编"}},[_._v("#")]),_._v(" 编译与汇编")]),_._v(" "),a("p",[a("img",{attrs:{src:t(553),alt:"image-20220610163551253"}})]),_._v(" "),a("p",[_._v("同一高级语言源代码可以经过编译在不同的微处理器和操作系统或者计算平台上运行。")]),_._v(" "),a("p",[_._v("每一种汇编语言对应一种微处理器，不需要针对不同平台的汇编器。")]),_._v(" "),a("h3",{attrs:{id:"指令格式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#指令格式"}},[_._v("#")]),_._v(" 指令格式")]),_._v(" "),a("p",[_._v("指令代码（Instruction Code）：汇编语言指令转换成对应的机器代码，以二进制数值的形式表现。")]),_._v(" "),a("p",[_._v("位的不同分组代表着指令的不同部分。某一组可能代表要执行的操作（操作码），而其它的组则选取操作的操作数。")]),_._v(" "),a("p",[a("img",{attrs:{src:t(554),alt:"image-20220610164511459"}})]),_._v(" "),a("h3",{attrs:{id:"指令集结构设计"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#指令集结构设计"}},[_._v("#")]),_._v(" 指令集结构设计")]),_._v(" "),a("p",[_._v("设计指令集结构并没有万能公式可言。相同的需求可能会产生不同的 ISA 设计。在设计ISA规范时，必须在性能、大小和成本限制间有个评估折衷。")]),_._v(" "),a("p",[a("strong",[_._v("完整性问题")]),_._v("：该指令集是否有足够的指令可以让程序完成它必须的任务？")]),_._v(" "),a("p",[a("strong",[_._v("正交性问题")]),_._v("：如果指令不重叠或者不执行同样的操作，那么它们就是正交的。在最小的指令集中为程序员提供必需的操作。")]),_._v(" "),a("p",[a("strong",[_._v("寄存器组")]),_._v("：设计者可以通过指定寄存器用途等方式优化 ISA。")]),_._v(" "),a("p",[a("strong",[_._v("要考虑的其它问题")]),_._v("：")]),_._v(" "),a("ul",[a("li",[_._v("处理器必须向下兼容其它的微处理器吗？")]),_._v(" "),a("li",[_._v("微处理器将处理何种类型和大小的数据？")]),_._v(" "),a("li",[_._v("需要中断吗？中断向量")]),_._v(" "),a("li",[_._v("需要条件指令吗？标志（flags）")])]),_._v(" "),a("h2",{attrs:{id:"_4-2-计算机组成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-计算机组成"}},[_._v("#")]),_._v(" 4.2 计算机组成")]),_._v(" "),a("h3",{attrs:{id:"冯-诺依曼结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#冯-诺依曼结构"}},[_._v("#")]),_._v(" 冯-诺依曼结构")]),_._v(" "),a("p",[_._v("计算机由五大部件组成：运算器、控制器、存储器、输入设备、输出设备")]),_._v(" "),a("p",[a("strong",[_._v("冯·诺依曼计算机硬件框图")]),_._v("：")]),_._v(" "),a("p",[a("img",{attrs:{src:t(448),alt:"image-20220610171647096"}})]),_._v(" "),a("p",[a("strong",[_._v("基本工作原理")]),_._v("：")]),_._v(" "),a("p",[_._v("运算器（ALU）与控制器（CU）共同构成 CPU 的核心部分。")]),_._v(" "),a("p",[_._v("存储器分为主存和辅存（缓存 cache）。")]),_._v(" "),a("p",[_._v("输入输出设备通过向 CPU 发送请求获得读写数据的权限以及相应的数据。")]),_._v(" "),a("h3",{attrs:{id:"总线与子系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总线与子系统"}},[_._v("#")]),_._v(" 总线与子系统")]),_._v(" "),a("p",[a("strong",[_._v("总线（BUS）")]),_._v("：一组传递数据的导线，是连接各个部件的信息传输线，是各个部件共享的传输介质。")]),_._v(" "),a("p",[_._v("总线优势：较少的连接数量、较少的空间、更低的功耗、较少的引脚。")]),_._v(" "),a("p",[_._v("总线分类：")]),_._v(" "),a("ul",[a("li",[_._v("片内总线：芯片内部的总线")]),_._v(" "),a("li",[_._v("系统总线：计算机各部件之间的信息传输线")])]),_._v(" "),a("p",[a("strong",[_._v("三个主要的子系统")]),_._v("：")]),_._v(" "),a("ul",[a("li",[_._v("中央处理单元（CPU）：执行多种操作并控制整个计算机，微处理器（Microprocessor）通常作为微机的CPU。")]),_._v(" "),a("li",[_._v("存储器：用来存储 CPU 正在执行的程序和数据。")]),_._v(" "),a("li",[_._v("输入输出系统：允许 CPU 与输入输出设备交互。比如个人计算机的键盘和显示器，或者微波炉的面板和数字显示等。")])]),_._v(" "),a("h3",{attrs:{id:"指令周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#指令周期"}},[_._v("#")]),_._v(" 指令周期")]),_._v(" "),a("p",[_._v("指令周期（Instruction Cycle）是微处理器完成一条指令处理的过程。包括取指（Fetch），译码（Decode），执行（Execute）三个阶段。")]),_._v(" "),a("h3",{attrs:{id:"中央处理器组成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#中央处理器组成"}},[_._v("#")]),_._v(" 中央处理器组成")]),_._v(" "),a("p",[_._v("CPU 控制整个计算机，内部有三大部分：")]),_._v(" "),a("ul",[a("li",[_._v("寄存器部分（Register Section）")]),_._v(" "),a("li",[_._v("算术/逻辑单元（Arithmetic/Logic Unit，也叫ALU）")]),_._v(" "),a("li",[_._v("控制单元（Control Unit）")])]),_._v(" "),a("p",[_._v("CPU 的重要组成部分：")]),_._v(" "),a("ul",[a("li",[_._v("程序计数器（Program Counter, PC）：用来存放下一条要提取（执行）的指令的地址。")]),_._v(" "),a("li",[_._v("指令寄存器（Instruction Register, IR）：用来存储从系统数据总线上读取到的指令。")]),_._v(" "),a("li",[_._v("算术逻辑单元：执行大部分的算术和逻辑运算，如加、与等操作。从 CPU 的寄存器部分取得操作数，运算结果再存回到寄存器部分。由于必须在一个时钟周期内完成操作，只采用组合逻辑构造而成。")]),_._v(" "),a("li",[_._v("控制单元：同 CPU 控制整个计算机一样，控制单元控制着 CPU。")])]),_._v(" "),a("h2",{attrs:{id:"_4-3-寄存器传送语言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-寄存器传送语言"}},[_._v("#")]),_._v(" 4.3 寄存器传送语言")]),_._v(" "),a("h3",{attrs:{id:"微操作和寄存器传送语言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微操作和寄存器传送语言"}},[_._v("#")]),_._v(" 微操作和寄存器传送语言")]),_._v(" "),a("p",[_._v("微操作（micro operation--μop）：大部分时序数字系统的基础，是更简单的行为。")]),_._v(" "),a("ul",[a("li",[_._v("数据从一个寄存器、存储器单元或者I/O设备到另一个的传送")]),_._v(" "),a("li",[_._v("修改已存储的值")]),_._v(" "),a("li",[_._v("执行算术或逻辑运算")])]),_._v(" "),a("p",[_._v("确定时序数字系统：确定正确的微操作传送及其条件，以保证微操作按正确的顺序执行。")]),_._v(" "),a("p",[a("strong",[_._v("微操作的格式")])]),_._v(" "),a("p",[_._v("考虑有两个1位寄存器 X 和 Y 的一个数字系统，拷贝寄存器 Y 的内容到寄存器 X 中的微操作：X←Y。")]),_._v(" "),a("p",[_._v("两种实现：（a）由直接连接实现；（b）通过总线连接实现。")]),_._v(" "),a("p",[a("img",{attrs:{src:t(555),alt:"image-20220610191442411"}})]),_._v(" "),a("p",[a("strong",[_._v("传送发生的条件")])]),_._v(" "),a("p",[_._v("假定传送应发生在输入控制 α 为高电平时，则传送过程可以写为 "),a("code",[_._v("IF α THEN X←Y")])]),_._v(" "),a("p",[_._v("表示微操作和它们发生的条件："),a("code",[_._v("条件: 微操作")]),_._v("。当条件满足时，执行微操作规定的数据传送。")]),_._v(" "),a("p",[_._v("具有控制信号的数据传送 "),a("code",[_._v("α: X←Y")]),_._v(" 的实现：（a）直接通路；（b）总线。")]),_._v(" "),a("p",[a("img",{attrs:{src:t(556),alt:"image-20220610192523993"}})]),_._v(" "),a("p",[a("strong",[_._v("提高系统性能的一种方法： 同时执行两个或多个微操作")])]),_._v(" "),a("p",[_._v("如果某系统在 α=1 时执行 X←Y 和 Y←Z 的传送，可以表示成："),a("code",[_._v("α: X ← Y,Y ← Z")]),_._v(" 或者 "),a("code",[_._v("α: Y ← Z, X ← Y")])]),_._v(" "),a("p",[a("img",{attrs:{src:t(557),alt:"image-20220610192857012"}})]),_._v(" "),a("p",[_._v("同时拷贝相同的数据到多个目的地："),a("code",[_._v("α: X ← Y, Z ← Y")])]),_._v(" "),a("p",[a("img",{attrs:{src:t(558),alt:"image-20220610193006934"}})]),_._v(" "),a("p",[_._v("数字系统不能同时往同一寄存器中写入两个不同的值。")]),_._v(" "),a("p",[a("strong",[_._v("传送常量的有效条件和微操作")])]),_._v(" "),a("p",[a("code",[_._v("α: X ← 0")]),_._v(" "),a("code",[_._v("β: X ← 1")])]),_._v(" "),a("p",[_._v("实现这两个传送的三种不同方法：")]),_._v(" "),a("ul",[a("li",[_._v("通过两个传送通路装载数据来设置 X 的值（多路选择器）")]),_._v(" "),a("li",[_._v("装载数据与 a 完全相同，但它的数据直接由信号 β 产生（用 β 作为数据输入）")]),_._v(" "),a("li",[_._v("为简化硬件可使用寄存器的清除输入功能（用 CLR 信号）")])]),_._v(" "),a("p",[a("img",{attrs:{src:t(559),alt:"image-20220610193346366"}})]),_._v(" "),a("p",[a("strong",[_._v("寄存器之间的多位数据传送")])]),_._v(" "),a("p",[_._v("同样大小寄存器对应位之间传送数据：例如 α: X ← Y")]),_._v(" "),a("p",[_._v("访问一个寄存器的某一位或位组：例如 X"),a("sub",[_._v("3")])]),_._v(" "),a("p",[_._v("表示位组：例如 γ: X(3-0) ← X(2-0), X"),a("sub",[_._v("3")]),_._v(" 或 γ: X(3-0) ← X(2-0,3)")]),_._v(" "),a("p",[a("strong",[_._v("执行数据的算术运算、 逻辑运算和移位运算的微操作")])]),_._v(" "),a("p",[_._v("常见算术运算和逻辑运算的微操作：")]),_._v(" "),a("table",[a("thead",[a("tr",[a("th",[_._v("操 作")]),_._v(" "),a("th",[_._v("示 例")])])]),_._v(" "),a("tbody",[a("tr",[a("td",[_._v("Add")]),_._v(" "),a("td",[_._v("X←X + Y")])]),_._v(" "),a("tr",[a("td",[_._v("Subtract")]),_._v(" "),a("td",[_._v("X←X – Y 或 X←X + Y’+ 1")])]),_._v(" "),a("tr",[a("td",[_._v("Increment")]),_._v(" "),a("td",[_._v("X←X + 1")])]),_._v(" "),a("tr",[a("td",[_._v("Decrement")]),_._v(" "),a("td",[_._v("X←X - 1")])]),_._v(" "),a("tr",[a("td",[_._v("And")]),_._v(" "),a("td",[_._v("X←X ∧ Y 或 X←XY")])]),_._v(" "),a("tr",[a("td",[_._v("OR")]),_._v(" "),a("td",[_._v("X←X ∨ Y")])]),_._v(" "),a("tr",[a("td",[_._v("XOR")]),_._v(" "),a("td",[_._v("X←X ⊕ Y")])]),_._v(" "),a("tr",[a("td",[_._v("NOT")]),_._v(" "),a("td",[_._v("X←/X 或 X←X’")])])])]),_._v(" "),a("p",[_._v("移位微操作：")]),_._v(" "),a("ul",[a("li",[_._v("线性移位：每一位的值依次向左（或右）移位，空位补入 0 值。")]),_._v(" "),a("li",[_._v("循环移位：将在线性移位中被丢弃的位循环回来，替代补入的 0 值。")]),_._v(" "),a("li",[_._v("算术移位：用于带符号数的移位。符号位在移位操作中保持不变，工作原理与线性移位相似。")]),_._v(" "),a("li",[_._v("十进制移位：与线性移位很相似，但它移动 1 个数字或 4 位，而不是移动 1 位。")])]),_._v(" "),a("table",[a("thead",[a("tr",[a("th",[_._v("操 作")]),_._v(" "),a("th",[_._v("示 例")])])]),_._v(" "),a("tbody",[a("tr",[a("td",[_._v("线性左移")]),_._v(" "),a("td",[_._v("shl(X)")])]),_._v(" "),a("tr",[a("td",[_._v("线性右移")]),_._v(" "),a("td",[_._v("shr(X)")])]),_._v(" "),a("tr",[a("td",[_._v("循环左移")]),_._v(" "),a("td",[_._v("cil(X)")])]),_._v(" "),a("tr",[a("td",[_._v("循环右移")]),_._v(" "),a("td",[_._v("cir(X)")])]),_._v(" "),a("tr",[a("td",[_._v("算术左移")]),_._v(" "),a("td",[_._v("ashl(X)")])]),_._v(" "),a("tr",[a("td",[_._v("算术右移")]),_._v(" "),a("td",[_._v("ashr(X)")])]),_._v(" "),a("tr",[a("td",[_._v("十进制左移")]),_._v(" "),a("td",[_._v("dshl(X)")])]),_._v(" "),a("tr",[a("td",[_._v("十进制右移")]),_._v(" "),a("td",[_._v("dshr(X)")])])])]),_._v(" "),a("p",[a("strong",[_._v("寄存器与存储器之间的数据传送")])]),_._v(" "),a("p",[_._v("例如：M[55]←AC 和 AC←M[55]")]),_._v(" "),a("p",[_._v("寄存器 AC 与存储器中 55 号单元之间的数据传送。")]),_._v(" "),a("h3",{attrs:{id:"描述数字系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#描述数字系统"}},[_._v("#")]),_._v(" 描述数字系统")]),_._v(" "),a("p",[a("strong",[_._v("数字元件表示")])]),_._v(" "),a("p",[_._v("D触发器："),a("code",[_._v("LD: Q ← D")])]),_._v(" "),a("p",[a("img",{attrs:{src:t(560),alt:"image-20220610195746144"}})]),_._v(" "),a("p",[_._v("有同步清零输入端的 D 触发器："),a("code",[_._v("LD: Q ← D")]),_._v(" "),a("code",[_._v("CLR: Q ← 0")])]),_._v(" "),a("p",[_._v("// TODO")]),_._v(" "),a("h2",{attrs:{id:"_4-4-中央处理器设计规范"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-中央处理器设计规范"}},[_._v("#")]),_._v(" 4.4 中央处理器设计规范")]),_._v(" "),a("h3",{attrs:{id:"设计-cpu-的两种方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计-cpu-的两种方法"}},[_._v("#")]),_._v(" 设计 CPU 的两种方法")]),_._v(" "),a("ul",[a("li",[_._v("硬布线逻辑控制（hardwired control）")]),_._v(" "),a("li",[_._v("微序列控制器（micro sequencer）")])]),_._v(" "),a("h3",{attrs:{id:"设计-cpu-的步骤"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计-cpu-的步骤"}},[_._v("#")]),_._v(" 设计 CPU 的步骤")]),_._v(" "),a("ul",[a("li",[_._v("确定它的用途，使 CPU 的处理能力和它所执行的任务匹配")]),_._v(" "),a("li",[_._v("设计指令集结构")]),_._v(" "),a("li",[_._v("设计状态图：列出在每个状态中执行的微操作，从一个状态转移到另外一个状态的条件")])]),_._v(" "),a("h3",{attrs:{id:"cpu-执行的操作序列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cpu-执行的操作序列"}},[_._v("#")]),_._v(" CPU 执行的操作序列")]),_._v(" "),a("ul",[a("li",[_._v("取指令周期：从存储器中取出一条指令，然后转到译码周期。")]),_._v(" "),a("li",[_._v("译码周期：对该指令进行译码，即确定取到的是哪一种指令，然后转移到这种指令对应的执行周期。")]),_._v(" "),a("li",[_._v("执行周期：执行该指令，然后转移到取指令周期去取下一条指令。")])])])}),[],!1,null,null,null);v.default=r.exports}}]);