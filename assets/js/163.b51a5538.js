(window.webpackJsonp=window.webpackJsonp||[]).push([[163],{1104:function(_,v,t){"use strict";t.r(v);var s=t(14),r=Object(s.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"第6章-实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第6章-实现"}},[_._v("#")]),_._v(" 第6章 实现")]),_._v(" "),t("h2",{attrs:{id:"_6-1-编码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-编码"}},[_._v("#")]),_._v(" 6.1 编码")]),_._v(" "),t("p",[_._v("编码：就是把软件设计的结果翻译成计算机可以理解的形式。")]),_._v(" "),t("ul",[t("li",[_._v("机器语言、汇编语言、高级语言。")])]),_._v(" "),t("p",[_._v("选择一种语言的标准：系统用户的要求，可以使用的编译程序，可以得到的软件工具，工程规模，程序员的知识，软件可移植性要求，软件的应用领域。")]),_._v(" "),t("p",[_._v("程序设计过程中要避免使用指针和复杂的表。")]),_._v(" "),t("h2",{attrs:{id:"_6-2-软件测试基础"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-软件测试基础"}},[_._v("#")]),_._v(" 6.2 软件测试基础")]),_._v(" "),t("p",[_._v("软件测试的定义：测试是为了 "),t("strong",[_._v("发现程序中的错误")]),_._v(" 而 "),t("strong",[_._v("执行程序的过程")]),_._v("。")]),_._v(" "),t("p",[_._v("软件测试的目标：")]),_._v(" "),t("ul",[t("li",[_._v("好的测试方案是极可能发现迄今为止尚未发现的错误的测试方案。")]),_._v(" "),t("li",[_._v("成功的测试是发现了至今为止尚未发现的错误的测试。")])]),_._v(" "),t("blockquote",[t("p",[t("strong",[_._v("注意")]),_._v("：测试只能查找出程序中的错误，不能证明程序中没有错误。测试的目标是发现错误，调试的任务是在测试的基础上去改正错误。")])]),_._v(" "),t("h2",{attrs:{id:"_6-3-软件测试方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-软件测试方法"}},[_._v("#")]),_._v(" 6.3 软件测试方法")]),_._v(" "),t("h3",{attrs:{id:"白盒测试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#白盒测试"}},[_._v("#")]),_._v(" 白盒测试")]),_._v(" "),t("p",[t("strong",[_._v("白盒测试（结构测试）")]),_._v(" 把程序看成装在一个透明的白盒子里，"),t("strong",[_._v("测试者完全知道程序的结构和处理算法")]),_._v("。")]),_._v(" "),t("p",[_._v("按照程序内部的逻辑测试程序，检测程序中的主要 "),t("strong",[_._v("执行通路")]),_._v(" 是否都能按预定要求正确工作。")]),_._v(" "),t("h3",{attrs:{id:"黑盒测试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#黑盒测试"}},[_._v("#")]),_._v(" 黑盒测试")]),_._v(" "),t("p",[t("strong",[_._v("黑盒测试（功能测试）")]),_._v(" 把程序看作一个黑盒子，"),t("strong",[_._v("完全不考虑程序的内部结构和处理过程")]),_._v("。")]),_._v(" "),t("p",[_._v("黑盒测试是在程序接口进行的测试，只检查程序功能是否能按照规格说明书的规定正常使用。")]),_._v(" "),t("h2",{attrs:{id:"_6-4-软件测试过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-4-软件测试过程"}},[_._v("#")]),_._v(" 6.4 软件测试过程")]),_._v(" "),t("p",[_._v("软件测试过程包括 "),t("strong",[_._v("单元测试、集成测试")]),_._v(" 和 "),t("strong",[_._v("验收测试")]),_._v("。")]),_._v(" "),t("h3",{attrs:{id:"单元测试-模块测试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单元测试-模块测试"}},[_._v("#")]),_._v(" 单元测试（模块测试)")]),_._v(" "),t("p",[_._v("定义：单元测试把每个 "),t("strong",[_._v("模块")]),_._v(" 作为一个单独的实体来测试，检验其正确性。")]),_._v(" "),t("p",[_._v("目的：保证每个模块作为一个单元能正确运行。")]),_._v(" "),t("blockquote",[t("p",[t("strong",[_._v("注意")]),_._v("：单元测试发现的是 "),t("strong",[_._v("编码和详细设计")]),_._v(" 的错误，其测试用例主要根据 "),t("strong",[_._v("详细设计")]),_._v(" 的结果来设计。")])]),_._v(" "),t("h3",{attrs:{id:"集成测试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#集成测试"}},[_._v("#")]),_._v(" "),t("strong",[_._v("集成测试")])]),_._v(" "),t("div",{staticClass:"anchor",attrs:{id:"子系统测试"}},[_._v("子系统测试")]),t("p",[_._v("定义：子系统测试把经过单元测试的模块放在一起形成一个子系统来测试。")]),_._v(" "),t("p",[_._v("目的：着重测试模块的接口。")]),_._v(" "),t("div",{staticClass:"anchor",attrs:{id:"系统测试"}},[_._v("系统测试")]),t("p",[_._v("定义：系统测试是把经过测试的子系统装配成一个完整的系统来测试。")]),_._v(" "),t("p",[_._v("目的：发现设计和编码的错误，并验证系统确实能提供需求说明书中指定的功能。")]),_._v(" "),t("p",[_._v("包括：恢复测试、压力测试、性能测试、安全测试")]),_._v(" "),t("blockquote",[t("p",[t("strong",[_._v("注意")]),_._v("：子系统测试和系统测试都属于 "),t("strong",[_._v("集成测试")]),_._v("。")])]),_._v(" "),t("h3",{attrs:{id:"验收测试-确认测试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#验收测试-确认测试"}},[_._v("#")]),_._v(" 验收测试（确认测试)")]),_._v(" "),t("p",[_._v("定义：在用户的参与下，把软件系统作为单一的实体，使用实际数据进行测试。")]),_._v(" "),t("p",[_._v("目的：验证系统确实能够满足用户的需要。")]),_._v(" "),t("blockquote",[t("p",[t("strong",[_._v("注意")]),_._v("：验收测试发现的是系统 "),t("strong",[_._v("需求说明书")]),_._v(" 中的错误。")])]),_._v(" "),t("h2",{attrs:{id:"_6-5-白盒测试技术"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-5-白盒测试技术"}},[_._v("#")]),_._v(" 6.5 白盒测试技术")]),_._v(" "),t("p",[_._v("有选择地执行程序中某些最有代表性的通路是对穷尽测试的惟一可行的替代办法。")]),_._v(" "),t("p",[_._v("从覆盖源程序语句的详尽程度分析，大致有以下一些不同的覆盖标准：")]),_._v(" "),t("ul",[t("li",[_._v("语句覆盖：选择足够多的测试数据，使被测程序中每个 "),t("strong",[_._v("语句")]),_._v(" 至少执行一次。")]),_._v(" "),t("li",[_._v("判定覆盖：不仅每个语句至少执行一次，而且使 "),t("strong",[_._v("判定表达式")]),_._v(" 都取到各种可能的结果。")]),_._v(" "),t("li",[_._v("条件覆盖：不仅每个语句至少执行一次，而且使 "),t("strong",[_._v("判定表达式中的每个条件")]),_._v(" 都取到各种可能的结果。")]),_._v(" "),t("li",[_._v("判定/条件覆盖：使 "),t("strong",[_._v("判定表达式")]),_._v(" 和 "),t("strong",[_._v("判定表达式中的每个条件")]),_._v(" 都取到各种可能的结果。")]),_._v(" "),t("li",[_._v("条件组合覆盖：要求选取足够多的测试数据，使得每个 "),t("strong",[_._v("判定表达式中条件的各种可能组合")]),_._v(" 都至少出现一次。")]),_._v(" "),t("li",[_._v("点覆盖：选取足够多的测试数据，使得程序执行路径至少经过 "),t("strong",[_._v("流图的每个结点")]),_._v(" 一次。")]),_._v(" "),t("li",[_._v("边覆盖：选取足够多的测试数据，使得程序执行路径至少经过 "),t("strong",[_._v("流图中每条边")]),_._v(" 一次。")]),_._v(" "),t("li",[_._v("路径覆盖：选取足够多测试数据，"),t("strong",[_._v("使程序的每条可能路径都至少执行一次")]),_._v("（如果程序图中有环，则要求每个环至少经过一次）。")])]),_._v(" "),t("p",[_._v("在白盒测试技术测试用例的设计中，"),t("strong",[_._v("路径覆盖是最强的覆盖标准，语句覆盖是最弱的覆盖标准。")])]),_._v(" "),t("h2",{attrs:{id:"_6-6-黑盒测试技术"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-6-黑盒测试技术"}},[_._v("#")]),_._v(" 6.6 黑盒测试技术")]),_._v(" "),t("h3",{attrs:{id:"等价划分"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#等价划分"}},[_._v("#")]),_._v(" 等价划分")]),_._v(" "),t("p",[t("strong",[_._v("把程序的输入域划分成若干个数据类，选取每个等价类中的一个典型值或任意值作为测试数据。")])]),_._v(" "),t("p",[_._v("等价类的划分有两种不同的情况：")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("有效等价类")]),_._v("： 是指对于程序规格说明来说是合理的、有意义的输入数据构成的集合。利用它可以测试软件在 "),t("strong",[_._v("合法输入")]),_._v(" 的情况下，是否给出了符合规格说明的输出。")]),_._v(" "),t("li",[t("strong",[_._v("无效等价类")]),_._v("： 是指对于程序规格说明来说是不合理的、无意义的输入数据构成的集合。利用它可以测试软件对于 "),t("strong",[_._v("不合理的输入")]),_._v(" 数据是否进行充分判断并给出提示信息。")])]),_._v(" "),t("h3",{attrs:{id:"边界值分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#边界值分析"}},[_._v("#")]),_._v(" 边界值分析")]),_._v(" "),t("p",[_._v("边界是指，相当于输入等价类和输出等价类而言，"),t("strong",[_._v("稍高于")]),_._v(" 其边界值及 "),t("strong",[_._v("稍低于")]),_._v(" 其边界值的一些特定情况。")]),_._v(" "),t("p",[t("strong",[_._v("边界值分析方法是最有效的黑盒测试方法")]),_._v("，但当边界情况很复杂的时候，要找出适当的测试用例还需针对问题的输入域、输出域边界，耐心细致地逐个考虑。")]),_._v(" "),t("h3",{attrs:{id:"错误推测"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#错误推测"}},[_._v("#")]),_._v(" 错误推测")]),_._v(" "),t("p",[_._v("错误推测法的基本想法是：列举出程序中所有可能有的错误和容易发生错误的特殊情况，根据它们选择测试用例。")]),_._v(" "),t("h2",{attrs:{id:"_6-7-调试"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-7-调试"}},[_._v("#")]),_._v(" 6.7 调试")]),_._v(" "),t("p",[_._v("调试是在测试发现错误之后排除错误的过程。")])])}),[],!1,null,null,null);v.default=r.exports}}]);