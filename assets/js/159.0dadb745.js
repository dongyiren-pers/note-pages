(window.webpackJsonp=window.webpackJsonp||[]).push([[159],{1095:function(t,e,r){"use strict";r.r(e);var s=r(14),_=Object(s.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"第1章-rocketmq-概念和特性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第1章-rocketmq-概念和特性"}},[t._v("#")]),t._v(" 第1章 RocketMQ 概念和特性")]),t._v(" "),r("h2",{attrs:{id:"_1-1-mq-的三大特性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-mq-的三大特性"}},[t._v("#")]),t._v(" 1.1 MQ 的三大特性")]),t._v(" "),r("h3",{attrs:{id:"异步解耦"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#异步解耦"}},[t._v("#")]),t._v(" 异步解耦")]),t._v(" "),r("p",[t._v("当上游系统以同步调用方式调用下游系统时，系统的吞吐量和并发度可能会大幅下降，并且系统之间的耦合度也会增加。为了解决这些问题，可以采用异步调用的方式。为了实现从同步到异步的转换，一种常见的做法是在上游系统和下游系统之间引入一个消息队列（MQ）层。")]),t._v(" "),r("h3",{attrs:{id:"限流削峰"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#限流削峰"}},[t._v("#")]),t._v(" 限流削峰")]),t._v(" "),r("p",[t._v("MQ 可以将系统的超量请求暂存其中，以便后期可以慢慢进行处理，从而避免请求的丢失或系统被压垮。")]),t._v(" "),r("h3",{attrs:{id:"数据收集"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据收集"}},[t._v("#")]),t._v(" 数据收集")]),t._v(" "),r("p",[t._v("分布式系统会产生海量级数据流，如：业务日志、监控数据、用户行为等。针对这些数据流进行实时或批量采集汇总，然后对这些数据流进行大数据分析，这是当前互联网平台的必备技术。通过 MQ 完成此类数据收集是最好的选择。")]),t._v(" "),r("h2",{attrs:{id:"_1-2-rocketmq-的特点"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-rocketmq-的特点"}},[t._v("#")]),t._v(" 1.2 RocketMQ 的特点")]),t._v(" "),r("p",[t._v("亿级消息的堆积能力，单个队列中的百万级消息的累积容量。")]),t._v(" "),r("p",[r("strong",[t._v("高可用性")]),t._v("：Broker 服务器支持多 Master 多 Slave 的同步双写以及 Master 多 Slave 的异步复制模式，其中同步双写可保证消息不丢失。")]),t._v(" "),r("p",[r("strong",[t._v("高可靠性")]),t._v("：生产者将消息发送到 Broker 端有三种方式，同步、异步和单向，其中同步和异步都可以保证消息成功的成功发送。Broker 在对于消息刷盘有两种策略：同步刷盘和异步刷盘，其中同步刷盘可以保证消息成功的存储到磁盘中。消费者的消费模式也有集群消费和广播消费两种，默认集群消费，如果集群模式中消费者挂了，一个组里的其他消费者会接替其消费。综上所述，是高可靠的。")]),t._v(" "),r("p",[r("strong",[t._v("支持分布式事务消息")]),t._v("：采用半消息确认和消息回查机制来保证分布式事务消息。")]),t._v(" "),r("p",[r("strong",[t._v("支持消息过滤")]),t._v("：建议采用消费者业务端的 tag 过滤。")]),t._v(" "),r("p",[r("strong",[t._v("支持顺序消息")]),t._v("：消息在 Broker 中是采用队列的 FIFO 模式存储的，即发送是顺序的，只要保证消费的顺序性即可。")]),t._v(" "),r("p",[r("strong",[t._v("支持定时消息和延迟消息")]),t._v("：Broker 中有定时消息的机制，消息发送到 Broker 中，不会立即被 Consumer 消费，会等到一定的时间才被消费。延迟消息也是一样，延迟一定时间之后才会被 Consumer 消费。")]),t._v(" "),r("h2",{attrs:{id:"_1-3-rocketmq-的专业术语"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-rocketmq-的专业术语"}},[t._v("#")]),t._v(" 1.3 RocketMQ 的专业术语")]),t._v(" "),r("p",[r("strong",[t._v("消息（Message）")]),t._v("：消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。")]),t._v(" "),r("p",[r("strong",[t._v("主题（Topic）")]),t._v("：表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是 RocketMQ 进行消息订阅的基本单位。")]),t._v(" "),r("blockquote",[r("p",[t._v("一个生产者可以同时发送多种 Topic 的消息；而一个消费者只对某种特定的 Topic 感兴趣，即只可以订阅和消费一种 Topic 的消息。")])]),t._v(" "),r("p",[r("strong",[t._v("标签（Tag）")]),t._v("：为消息设置的标签，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。消费者可以根据 Tag 实现对不同子主题的不同消费逻辑，实现更好的扩展性。")]),t._v(" "),r("blockquote",[r("p",[t._v("Topic是消息的一级分类，Tag是消息的二级分类。")])]),t._v(" "),r("p",[r("strong",[t._v("队列（Queue）")]),t._v("：存储消息的物理实体。一个 Topic 中可以包含多个 Queue，每个 Queue 中存放的就是该 Topic 的消息。一个 Topic 的 Queue 也被称为一个 Topic 中消息的分区（Partition）。")]),t._v(" "),r("p",[t._v("一个 Topic 的 Queue 中的消息只能被一个消费者组中的一个消费者消费。一个 Queue 中的消息不允许同一个消费者组中的多个消费者同时消费。")]),t._v(" "),r("p",[r("strong",[t._v("消息标识（Message/Key）")]),t._v("：RocketMQ 中每个消息拥有唯一的 MessageId，且可以携带具有业务标识的 Key，以方便对消息的查询。不过需要注意的是，MessageId 有两个：在生产者发送消息时会自动生成一个 MessageId（msgId），当消息到 Broker 后，Broker 也会自动生成一个 MessageId（offsetMsgId）。msgId、offsetMsgId 与 key 都称为消息标识。")]),t._v(" "),r("p",[r("strong",[t._v("组（Group）")]),t._v("：可分为 "),r("strong",[t._v("ProducerGroup 生产者组")]),t._v(" 和 "),r("strong",[t._v("ConsumerGroup 消费者组")]),t._v("，一个组可以订阅多个 Topic。一般来说，某一类相同业务的生产者和消费者放在一个组里。")]),t._v(" "),r("p",[r("strong",[t._v("偏移量（offset）")]),t._v("：消息队列中的 offset 可以认为就是下标，消息队列可看做数组。offset 是 java long 型，64 位，理论上 100 年不会溢出，因此可以认为消息队列是一个长度无限的数据结构。")])])}),[],!1,null,null,null);e.default=_.exports}}]);