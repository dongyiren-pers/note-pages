(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{1040:function(t,a,v){"use strict";v.r(a);var _=v(14),r=Object(_.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"第3章-线程状态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第3章-线程状态"}},[t._v("#")]),t._v(" 第3章 线程状态")]),t._v(" "),_("p",[t._v("一个线程只能处于一种状态。")]),t._v(" "),_("p",[t._v("这里的线程状态特指 Java 虚拟机的线程状态，不能反映线程在特定操作系统下的状态。")]),t._v(" "),_("h2",{attrs:{id:"_3-1-线程的-6-个状态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-线程的-6-个状态"}},[t._v("#")]),t._v(" 3.1 线程的 6 个状态")]),t._v(" "),_("h3",{attrs:{id:"新建-new"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#新建-new"}},[t._v("#")]),t._v(" 新建（NEW）")]),t._v(" "),_("p",[_("strong",[t._v("NEW：新建状态。")])]),t._v(" "),_("p",[t._v("当程序使用 new 关键字创建了一个线程之后，该线程就处于新建状态，此时它和其他的 Java 对象一样，仅仅由 Java 虚拟机为其分配内存，并初始化其成员变量的值。此时的线程对象没有表现出任何线程的动态特征，程序不会执行线程的线程执行体。")]),t._v(" "),_("h3",{attrs:{id:"可运行-runable"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#可运行-runable"}},[t._v("#")]),t._v(" 可运行（RUNABLE）")]),t._v(" "),_("p",[_("strong",[t._v("RUNABLE：正在 Java 虚拟机中运行。")])]),t._v(" "),_("p",[t._v("Java 线程中将就绪（READY）和运行中（RUNNING）两种状态笼统的称为 “可运行”。")]),t._v(" "),_("p",[t._v("当线程对象调用了 start() 方法之后，该线程处于就绪状态，Java 虚拟机会为其创建方法调用栈和程序计数器，处于这个状态中的线程并没有开始运行，只是表示该线程可以运行了。至于该线程何时开始运行，取决于 JVM 里线程调度器的调度。")]),t._v(" "),_("p",[t._v("在操作系统层面，它可能处于运行状态，也可能等待资源调度（例如处理器资源），资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度。")]),t._v(" "),_("h3",{attrs:{id:"阻塞-blocked"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#阻塞-blocked"}},[t._v("#")]),t._v(" 阻塞（BLOCKED）")]),t._v(" "),_("p",[_("strong",[t._v("BLOCKED：线程正等待监视器锁。")])]),t._v(" "),_("p",[t._v("请求获取 monitor lock 从而进入 synchronized 函数或者代码块，但是其它线程已经占用了该 monitor lock，因此处于阻塞状态。要结束该状态进入从而 RUNABLE 需要其他线程释放 monitor lock。")]),t._v(" "),_("h3",{attrs:{id:"无限期等待-waiting"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#无限期等待-waiting"}},[t._v("#")]),t._v(" 无限期等待（WAITING）")]),t._v(" "),_("p",[_("strong",[t._v("WAITING：等待其它线程显式地唤醒。")])]),t._v(" "),_("p",[t._v("阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 monitor lock。而等待是主动的，通过调用 "),_("code",[t._v("Object.wait()")]),t._v(" 等方法进入。")]),t._v(" "),_("div",{staticClass:"table-column-50-50-container"},[_("table",[_("thead",[_("tr",[_("th",[t._v("进入方法")]),t._v(" "),_("th",[t._v("退出方法")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("没有设置 Timeout 参数的 Object.wait() 方法")]),t._v(" "),_("td",[t._v("Object.notify() / Object.notifyAll()")])]),t._v(" "),_("tr",[_("td",[t._v("没有设置 Timeout 参数的 Thread.join() 方法")]),t._v(" "),_("td",[t._v("被调用的线程执行完毕")])]),t._v(" "),_("tr",[_("td",[t._v("LockSupport.park() 方法")]),t._v(" "),_("td",[t._v("LockSupport.unpark(Thread)")])])])])]),_("h3",{attrs:{id:"限期等待-timed-waiting"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#限期等待-timed-waiting"}},[t._v("#")]),t._v(" 限期等待（TIMED_WAITING）")]),t._v(" "),_("p",[_("strong",[t._v("TIMED_WAITING：无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。")])]),t._v(" "),_("div",{staticClass:"table-column-50-50-container"},[_("table",[_("thead",[_("tr",[_("th",[t._v("进入方法")]),t._v(" "),_("th",[t._v("退出方法")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("Thread.sleep() 方法")]),t._v(" "),_("td",[t._v("时间结束")])]),t._v(" "),_("tr",[_("td",[t._v("设置了 Timeout 参数的 Object.wait() 方法")]),t._v(" "),_("td",[t._v("时间结束 / Object.notify() / Object.notifyAll()")])]),t._v(" "),_("tr",[_("td",[t._v("设置了 Timeout 参数的 Thread.join() 方法")]),t._v(" "),_("td",[t._v("时间结束 / 被调用的线程执行完毕")])]),t._v(" "),_("tr",[_("td",[t._v("LockSupport.parkNanos() 方法")]),t._v(" "),_("td",[t._v("LockSupport.unpark(Thread)")])]),t._v(" "),_("tr",[_("td",[t._v("LockSupport.parkUntil() 方法")]),t._v(" "),_("td",[t._v("LockSupport.unpark(Thread)")])])])])]),_("blockquote",[_("p",[t._v("调用 "),_("code",[t._v("Thread.sleep()")]),t._v(" 方法使线程进入限期等待状态时，常常用 “使一个线程睡眠” 进行描述。调用 "),_("code",[t._v("Object.wait()")]),t._v(" 方法使线程进入限期等待或者无限期等待时，常常用 “挂起一个线程” 进行描述。睡眠和挂起是用来描述行为，而阻塞和等待是用来描述状态的。")])]),t._v(" "),_("h3",{attrs:{id:"死亡-terminated"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#死亡-terminated"}},[t._v("#")]),t._v(" 死亡（TERMINATED）")]),t._v(" "),_("p",[t._v("线程结束任务之后自己结束，或者产生了异常而结束。")]),t._v(" "),_("h2",{attrs:{id:"_3-2-线程状态的迁移"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-线程状态的迁移"}},[t._v("#")]),t._v(" 3.2 线程状态的迁移")]),t._v(" "),_("p",[_("img",{attrs:{src:v(660),alt:"image-20230123003302462"}})])])}),[],!1,null,null,null);a.default=r.exports},660:function(t,a,v){t.exports=v.p+"assets/img/image-20230123003302462.da2b95c4.png"}}]);