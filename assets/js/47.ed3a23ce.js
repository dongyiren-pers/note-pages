(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{1088:function(v,_,t){"use strict";t.r(_);var s=t(14),a=Object(s.a)({},(function(){var v=this,_=v.$createElement,s=v._self._c||_;return s("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[s("h1",{attrs:{id:"第4章-redis-缓存问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第4章-redis-缓存问题"}},[v._v("#")]),v._v(" 第4章 Redis 缓存问题")]),v._v(" "),s("h2",{attrs:{id:"_4-1-缓存穿透"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-缓存穿透"}},[v._v("#")]),v._v(" 4.1 缓存穿透")]),v._v(" "),s("h3",{attrs:{id:"问题描述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#问题描述"}},[v._v("#")]),v._v(" 问题描述")]),v._v(" "),s("p",[v._v("缓存穿透是指查找的数据在 "),s("strong",[v._v("缓存和数据库中都不存在")]),v._v("，导致每一次请求数据从缓存中都获取不到，而将请求打到数据库服务器。")]),v._v(" "),s("p",[v._v("如果在高并发场景或有人恶意攻击，就会导致后台数据库服务器压力增大，最终系统可能崩掉。")]),v._v(" "),s("h3",{attrs:{id:"解决方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解决方案"}},[v._v("#")]),v._v(" 解决方案")]),v._v(" "),s("ul",[s("li",[s("strong",[v._v("限制非法请求")]),v._v("：判断求请求参数是否合理，请求参数是否含有非法值、请求字段是否存在，如果判断出是恶意请求就直接返回错误，避免进一步访问缓存和数据库。")]),v._v(" "),s("li",[s("strong",[v._v("缓存空对象")]),v._v("：存储层未命中，仍将空值存入缓存层，客户端再次访问数据时，缓存层会直接返回空值。")]),v._v(" "),s("li",[s("strong",[v._v("布隆过滤器")]),v._v("：将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。")])]),v._v(" "),s("p",[s("strong",[v._v("缓存空对象带来的问题：")])]),v._v(" "),s("ul",[s("li",[v._v("空值做了缓存，意味着缓存中存了更多的键，需要更多的内存空间，比较有效的方法是针对这类数据设置一个较短的过期时间，让其自动剔除。")]),v._v(" "),s("li",[v._v("缓存和存储的数据会有一段时间窗口的不一致，可能会对业务有一定影响。例如：过期时间设置为 5 分钟，如果此时存储添加了这个数据，此段时间就会出现缓存和存储数据的不一致，此时可以利用消息系统或者其他方式清除掉缓存层中的空对象。")])]),v._v(" "),s("p",[s("strong",[v._v("布隆过滤器的问题")]),v._v("：布隆过滤器不能删除，因此查询删除的数据一定会发生穿透。")]),v._v(" "),s("h2",{attrs:{id:"_4-2-缓存击穿"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-缓存击穿"}},[v._v("#")]),v._v(" 4.2 缓存击穿")]),v._v(" "),s("h3",{attrs:{id:"问题描述-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#问题描述-2"}},[v._v("#")]),v._v(" 问题描述")]),v._v(" "),s("p",[v._v("缓存击穿是指 "),s("strong",[v._v("超级热点数据突然过期")]),v._v("，导致大量针对超级热点的数据请求在过期期间直接打到数据库，引起数据库压力瞬间增大，造成过大压力。")]),v._v(" "),s("h3",{attrs:{id:"解决方案-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解决方案-2"}},[v._v("#")]),v._v(" 解决方案")]),v._v(" "),s("ul",[s("li",[s("strong",[v._v("永不过期")]),v._v("：热点数据不设置过期时间，所以不会出现上述问题，这是 “物理”上的永不过期。或者为每个数据设置逻辑过期时间，当发现热点数据逻辑过期时，使用单独的线程重建缓存。")]),v._v(" "),s("li",[s("strong",[v._v("加互斥锁")]),v._v("：对数据访问加互斥锁，当一个线程访问该数据时，其他线程只能等待。这个线程访问过后，缓存中的数据将被重建，届时其他线程就可以直接从缓存中取值。")])]),v._v(" "),s("h2",{attrs:{id:"_4-3-缓存雪崩"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-缓存雪崩"}},[v._v("#")]),v._v(" 4.3 缓存雪崩")]),v._v(" "),s("h3",{attrs:{id:"问题描述-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#问题描述-3"}},[v._v("#")]),v._v(" 问题描述")]),v._v(" "),s("p",[v._v("缓存雪崩是指缓存中 "),s("strong",[v._v("大量缓存数据在同一时间过期")]),v._v(" 或 "),s("strong",[v._v("Redis 实例宕机")]),v._v("，导致大量请求进入数据库。")]),v._v(" "),s("h3",{attrs:{id:"解决方案-3"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解决方案-3"}},[v._v("#")]),v._v(" 解决方案")]),v._v(" "),s("div",{staticClass:"subtitle"},[s("p",[v._v("大量缓存数据在同一时间过期")])]),s("ul",[s("li",[s("strong",[v._v("避免数据同时过期")]),v._v("：设置过期时间时，附加一个随机数，避免大量的 key 同时过期。")]),v._v(" "),s("li",[s("strong",[v._v("服务限流、降级")]),v._v("：启动服务限流机制，减少业务应用对缓存服务的访问。若应用访问的不是核心数据，则可以直接返回预定义信息/空值/错误信息。")])]),v._v(" "),s("blockquote",[s("p",[s("strong",[v._v("服务限流")]),v._v("：指当系统资源不够，不足以应对大量请求，即系统资源与访问量出现矛盾的时候，我们为了保证有限的资源能够正常服务，因此对系统按照预设的规则进行流量限制或功能限制的一种方法。")]),v._v(" "),s("p",[s("strong",[v._v("服务降级")]),v._v("：服务发生熔断后，一般会让请求走事先配置的处理方法，这个处理方法就是一个降级逻辑。服务降级是一种兜底的服务策略，体现了一种“实在不行就怎么这么样”的思想。")])]),v._v(" "),s("div",{staticClass:"subtitle"},[s("p",[v._v("Redis 实例宕机")])]),s("ul",[s("li",[s("strong",[v._v("构建高可用的 Redis 服务")]),v._v("：采用哨兵或者集群模式，部署多个 Redis 实例，个别节点宕机，依然可以保持服务的整体可用。")]),v._v(" "),s("li",[s("strong",[v._v("服务熔断、降级")]),v._v("：启动服务熔断机制，暂停业务应用对缓存服务的访问。若应用访问的不是核心数据，则可以直接返回预定义信息/空值/错误信息。")])]),v._v(" "),s("blockquote",[s("p",[s("strong",[v._v("服务熔断")]),v._v("：指调用方访问服务时通过断路器做代理进行访问，断路器会持续观察服务返回的成功、失败的状态，当失败超过设置的阈值时断路器打开，请求就不能真正地访问到服务了。")])]),v._v(" "),s("h2",{attrs:{id:"_4-4-缓存与数据库一致性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-缓存与数据库一致性"}},[v._v("#")]),v._v(" 4.4 缓存与数据库一致性")]),v._v(" "),s("h3",{attrs:{id:"更新缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#更新缓存"}},[v._v("#")]),v._v(" 更新缓存")]),v._v(" "),s("p",[v._v("当数据发生更新时，我们不仅要更新数据库，还要一并更新缓存。对应的方案有 2 个：")]),v._v(" "),s("ul",[s("li",[v._v("先更新缓存，后更新数据库")]),v._v(" "),s("li",[v._v("先更新数据库，后更新缓存")])]),v._v(" "),s("div",{staticClass:"anchor",attrs:{id:"更新缓存方案中的第二步失败"}},[v._v("更新缓存方案中的第二步失败")]),s("p",[v._v("因为操作分为两步，那么就很有可能存在第一步成功、第二步失败的情况发生。")]),v._v(" "),s("ul",[s("li",[v._v("先更新缓存，后更新数据库：第二步操作失败，此时缓存中是最新值，但数据库中是旧值。虽然此时读请求可以命中缓存，拿到正确的值，但是，一旦缓存失效，就会从数据库中读取到旧值，重建缓存也是这个旧值。")]),v._v(" "),s("li",[v._v("先更新数据库，后更新缓存：第二步操作失败，此时数据库中是最新值，缓存中是旧值。之后的读请求读到的都是旧数据，只有当缓存失效后，才能从数据库中得到正确的值。")])]),v._v(" "),s("div",{staticClass:"anchor",attrs:{id:"更新缓存方案中的并发问题"}},[v._v("更新缓存方案中的并发问题")]),s("p",[v._v("假设我们采用 "),s("strong",[v._v("先更新数据库，再更新缓存")]),v._v(" 的方案，并且两步都可以 "),s("strong",[v._v("成功执行")]),v._v(" 的前提下，如果存在并发，情况会是怎样的呢？")]),v._v(" "),s("p",[v._v("有线程 A 和线程 B 两个线程，需要更新同一条数据，会发生这样的场景：")]),v._v(" "),s("p",[s("img",{attrs:{src:t(878),alt:"image-20230816161952705"}})]),v._v(" "),s("p",[v._v("最终 X 在缓存中是 1，在数据库中是 2，发生不一致。A 虽然先于 B 发生，但 B 操作数据库和缓存的时间，却要比 A 的时间短，执行时序发生错乱，最终这条数据结果是不符合预期的。")]),v._v(" "),s("blockquote",[s("p",[v._v("同样地，采用 “先更新缓存，再更新数据库” 的方案，也会有类似问题，这里不再详述。")])]),v._v(" "),s("p",[v._v("那怎么解决这个问题呢？这里通常的解决方案是，加 "),s("strong",[v._v("分布式锁")]),v._v(" 。")]),v._v(" "),s("p",[v._v("两个线程要修改 "),s("strong",[v._v("同一条")]),v._v(" 数据，每个线程在改之前，先去申请分布式锁，拿到锁的线程才允许更新数据库和缓存，拿不到锁的线程，返回失败，等待下次重试。")]),v._v(" "),s("p",[v._v("这么做的目的，就是为了只允许一个线程去操作数据和缓存，避免并发问题。")]),v._v(" "),s("div",{staticClass:"anchor",attrs:{id:"缓存资源浪费和机器性能浪费"}},[v._v("缓存资源浪费和机器性能浪费")]),s("p",[v._v("每次数据发生变更，都会更新缓存，但是缓存中的数据不一定会被马上读取，这就会导致缓存中可能存放了很多不常访问的数据，浪费缓存资源。")]),v._v(" "),s("p",[v._v("而且很多情况下，写到缓存中的值，并不是与数据库中的值一一对应的，很有可能是先查询数据库，再经过一系列 "),s("strong",[v._v("计算")]),v._v(" 得出一个值，才把这个值才写到缓存中。")]),v._v(" "),s("p",[v._v("由此可见，这种 "),s("strong",[v._v("更新数据库 + 更新缓存")]),v._v(" 的方案，不仅缓存利用率不高，还会造成机器性能的浪费。")]),v._v(" "),s("p",[v._v("此时我们需要考虑另外一种方案："),s("strong",[v._v("删除缓存")]),v._v("。")]),v._v(" "),s("h3",{attrs:{id:"删除缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#删除缓存"}},[v._v("#")]),v._v(" 删除缓存")]),v._v(" "),s("p",[v._v("删除缓存对应的方案有 2 种：")]),v._v(" "),s("ul",[s("li",[v._v("先删除缓存，后更新数据库")]),v._v(" "),s("li",[v._v("先更新数据库，后删除缓存")])]),v._v(" "),s("div",{staticClass:"anchor",attrs:{id:"删除缓存方案中的第二步失败"}},[v._v("删除缓存方案中的第二步失败")]),s("ul",[s("li",[v._v("先删除缓存，后更新数据库：第二步操作失败，数据库没有更新成功，那下次读缓存发现不存在，则从数据库中读取，并重建缓存，此时数据库和缓存依旧保持一致。")]),v._v(" "),s("li",[v._v("先更新数据库，后删除缓存：第二步操作失败，数据库是最新值，缓存中是旧值，发生不一致。因此，这个方案依旧存在问题。")])]),v._v(" "),s("div",{staticClass:"anchor",attrs:{id:"删除缓存方案中的并发问题"}},[v._v("删除缓存方案中的并发问题")]),s("ul",[s("li",[v._v("先删除缓存，后更新数据库：当发生 "),s("strong",[v._v("读+写")]),v._v(" 并发时，还是存在数据不一致的情况。")])]),v._v(" "),s("p",[s("img",{attrs:{src:t(879),alt:"image-20230816155832527.drawio"}})]),v._v(" "),s("ul",[s("li",[v._v("先更新数据库，后删除缓存：发生 "),s("strong",[v._v("读+写")]),v._v(" 并发时，同样存在数据不一致的情况。")])]),v._v(" "),s("p",[s("img",{attrs:{src:t(880),alt:"image-20230816161513000"}})]),v._v(" "),s("p",[v._v("这种情况 "),s("strong",[v._v("理论")]),v._v(" 来说是可能发生的，但实际发生概率 "),s("strong",[v._v("很低")]),v._v(" ，这是因为它必须满足 3 个条件：")]),v._v(" "),s("ul",[s("li",[v._v("缓存刚好已失效")]),v._v(" "),s("li",[v._v("读请求 + 写请求并发")]),v._v(" "),s("li",[v._v("更新数据库 + 删除缓存的时间，要比读数据库 + 写缓存时间短")])]),v._v(" "),s("p",[v._v("条件 3 发生的概率其实是非常低的。因为写数据库一般会先 "),s("strong",[v._v("加锁")]),v._v(" ，因此写数据库通常是要比读数据库的时间更长的。")]),v._v(" "),s("p",[v._v("这么来看， "),s("strong",[v._v("先更新数据库 + 再删除缓存")]),v._v(" 的方案，是可以保证数据一致性的。")]),v._v(" "),s("div",{staticClass:"anchor",attrs:{id:"如何保证两步都执行成功"}},[v._v("如何保证两步都执行成功")]),s("p",[v._v("前面分析到，无论是更新缓存还是删除缓存，只要第二步发生失败，那么就会导致数据库和缓存不一致。")]),v._v(" "),s("p",[v._v("保证第二步成功执行，就是解决问题的关键。")]),v._v(" "),s("p",[v._v("推荐采用 "),s("strong",[v._v("先更新数据库，再删除缓存")]),v._v(" 方案，并配合 "),s("strong",[v._v("消息队列")]),v._v(" 或 "),s("strong",[v._v("订阅变更日志")]),v._v(" 的方式来保证第二步成功执行。")]),v._v(" "),s("blockquote",[s("p",[v._v("同步重试的问题：立即重试很大概率 "),s("strong",[v._v("还会失败")]),v._v("，且重试会一直 "),s("strong",[v._v("占用")]),v._v(" 线程资源。")])]),v._v(" "),s("h3",{attrs:{id:"延迟双删"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#延迟双删"}},[v._v("#")]),v._v(" 延迟双删")]),v._v(" "),s("div",{staticClass:"anchor",attrs:{id:"主从复制延迟问题"}},[v._v("主从复制延迟问题")]),s("p",[v._v("在 "),s("strong",[v._v("读写分离 + 主从复制延迟")]),v._v(" 场景下，缓存和数据库同样存在一致性问题。")]),v._v(" "),s("p",[s("img",{attrs:{src:t(881),alt:"image-20230817131657025"}})]),v._v(" "),s("p",[v._v("缓解此问题的方案是 "),s("strong",[v._v("延迟双删")]),v._v(" ，发送 "),s("strong",[v._v("延迟消息")]),v._v(" 到任务队列中，延迟删除缓存，同时要控制主从库延迟，尽可能降低不一致发生的概率。")])])}),[],!1,null,null,null);_.default=a.exports},878:function(v,_,t){v.exports=t.p+"assets/img/image-20230816161952705.d4167e0a.png"},879:function(v,_,t){v.exports=t.p+"assets/img/image-20230816155832527.drawio.da0d032d.png"},880:function(v,_,t){v.exports=t.p+"assets/img/image-20230816161513000.1867e9a4.png"},881:function(v,_,t){v.exports=t.p+"assets/img/image-20230817131657025.08e0a7b3.png"}}]);