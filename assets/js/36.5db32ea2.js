(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{1069:function(t,_,a){"use strict";a.r(_);var s=a(14),v=Object(s.a)({},(function(){var t=this,_=t.$createElement,s=t._self._c||_;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"第3章-事务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第3章-事务"}},[t._v("#")]),t._v(" 第3章 事务")]),t._v(" "),s("h2",{attrs:{id:"_7-1-事务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-1-事务"}},[t._v("#")]),t._v(" 7.1 事务")]),t._v(" "),s("p",[t._v("简单来说，数据库事务可以保证多个对数据库的操作（即 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循："),s("strong",[t._v("要么全部执行成功，要么全部不执行 。")])]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 开启一个事务")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("START")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("TRANSACTION")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 多条 SQL 语句")]),t._v("\nSQL1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("SQL2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 提交事务")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("COMMIT")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("h2",{attrs:{id:"_7-2-acid-特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-2-acid-特性"}},[t._v("#")]),t._v(" 7.2 ACID 特性")]),t._v(" "),s("p",[t._v("事务需遵循 ACID 四个特性：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("A（atomicity）原子性")]),t._v("：指⼀个事务中的操作要么全部成功，要么全部失败")]),t._v(" "),s("li",[s("strong",[t._v("C（consistency）一致性")]),t._v("：指事务将数据库从一个一致性状态变到另一个一致性状态。在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。")]),t._v(" "),s("li",[s("strong",[t._v("I（isolation）隔离性")]),t._v("：指的是⼀个事务的修改在最终提交前，对其他事务是不可⻅的。")]),t._v(" "),s("li",[s("strong",[t._v("D（durability）持久性")]),t._v("：指的是⼀旦事务提交，所做的修改就会永久保存到数据库中。")])]),t._v(" "),s("h3",{attrs:{id:"如何保证-acid-特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何保证-acid-特性"}},[t._v("#")]),t._v(" 如何保证 ACID 特性")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("原子性")]),t._v(" 由 undo log 保证，它记录了需要回滚的⽇志信息，事务回滚时撤销已经执⾏成功的 SQL。")]),t._v(" "),s("li",[s("strong",[t._v("⼀致性")]),t._v(" 由其他三⼤特性保证，程序代码要保证业务上的⼀致性  。")]),t._v(" "),s("li",[s("strong",[t._v("隔离性")]),t._v(" 由 MVCC 和锁来保证。")]),t._v(" "),s("li",[s("strong",[t._v("持久性")]),t._v(" 由内存和 redo log 来保证，MySQL 修改数据同时在内存和 redo log 记录这次操作，宕机时从 redo log 恢复。")])]),t._v(" "),s("h2",{attrs:{id:"_7-3-并发事务带来的问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-3-并发事务带来的问题"}},[t._v("#")]),t._v(" 7.3 并发事务带来的问题")]),t._v(" "),s("p",[t._v("在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。")]),t._v(" "),s("h3",{attrs:{id:"脏读"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#脏读"}},[t._v("#")]),t._v(" 脏读")]),t._v(" "),s("p",[t._v("读 “脏” 数据是指事务 T1 修改某一数据，并将其写回磁盘，事务 T2 读取同一数据后，T1 由于某种原因被撤销，这时 T1 已修改过的数据恢复原值，T2 读到的数据就与数据库中的数据不一致，则 T2 读到的数据就为 “脏” 数据，即不正确的数据。")]),t._v(" "),s("p",[t._v("例如：事务 1 读取某表中的数据 A = 20，事务 1 修改 A = A - 1，事务 2 读取到 A = 19，事务 1 回滚导致对 A 的修改并未提交到数据库，A 的值还是 20。")]),t._v(" "),s("p",[s("img",{attrs:{src:a(765),alt:"image-20230201165046628"}})]),t._v(" "),s("h3",{attrs:{id:"丢失修改"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#丢失修改"}},[t._v("#")]),t._v(" 丢失修改")]),t._v(" "),s("p",[t._v("丢失修改是指两个事务 T1 和 T2 读入同一数据并修改，T2提交的结果破坏了（覆盖了）T1提交的结果，导致 T1 的修改被丢失。")]),t._v(" "),s("p",[t._v("例如：事务 1 读取某表中的数据 A = 20，事务 2 也读取 A = 20，事务 1 先修改 A = A - 1，事务 2 后来也修改 A = A-1，最终结果 A = 19，事务 1 的修改被丢失。")]),t._v(" "),s("p",[s("img",{attrs:{src:a(766),alt:"image-20230201165503783"}})]),t._v(" "),s("h3",{attrs:{id:"不可重复读"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#不可重复读"}},[t._v("#")]),t._v(" 不可重复读")]),t._v(" "),s("p",[t._v("不可重复读是指事务 T1 读取某一数据后，事务 T2 对其执行更新操作，使 T1 无法再现前一次读取结果。")]),t._v(" "),s("p",[t._v("例如：事务 1 读取某表中的数据 A = 20，事务 2 也读取 A = 20，事务 1 修改 A = A-1，事务 2 再次读取 A =19，此时读取的结果和第一次读取的结果不同。")]),t._v(" "),s("p",[s("img",{attrs:{src:a(767),alt:"image-20230201170007291"}})]),t._v(" "),s("h3",{attrs:{id:"幻读"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#幻读"}},[t._v("#")]),t._v(" 幻读")]),t._v(" "),s("p",[t._v("幻读可以看作是不可重复读的一种特殊情况，重点在于记录新增。比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。")]),t._v(" "),s("p",[t._v("单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。")]),t._v(" "),s("p",[t._v("执行 DELETE 和 UPDATE 时，可以直接对记录加锁，保证事务安全。而执行 INSERT 时，由于记录锁（Record Lock）只能锁住已存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。即执行 INSERT 操作的时候需要依赖 Next-Key Lock（Record Lock + Gap Lock） 加锁来保证不出现幻读。")]),t._v(" "),s("h2",{attrs:{id:"_7-4-事务隔离级别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-4-事务隔离级别"}},[t._v("#")]),t._v(" 7.4 事务隔离级别")]),t._v(" "),s("p",[t._v("SQL 标准定义了四个隔离级别：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("读未提交（READ-UNCOMMITTED）")]),t._v("：最低的隔离级别，"),s("strong",[t._v("允许读取尚未提交的数据变更")]),t._v("，这可能会导致脏读、不可重复读和幻读。")]),t._v(" "),s("li",[s("strong",[t._v("读已提交（READ-COMMITTED, RC）")]),t._v("："),s("strong",[t._v("允许读取并发事务已经提交的数据")]),t._v("，可以阻止脏读，但是不可重复读和幻读仍有可能发生。")]),t._v(" "),s("li",[s("strong",[t._v("可重复读（REPEATABLE-READ, RR）")]),t._v("："),s("strong",[t._v("对同一字段的多次读取结果是一致的")]),t._v("，除非数据被本身事务自己修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。")]),t._v(" "),s("li",[s("strong",[t._v("可串行化（SERIALIZABLE）")]),t._v("：最高的隔离级别，"),s("strong",[t._v("完全服从 ACID 的隔离级别")]),t._v("。事务依次逐个执行，这样事务之间就完全不可能产生干扰。该级别可以防止脏读、不可重复读以及幻读。")])]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",{staticStyle:{"text-align":"center"}},[t._v("隔离级别")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("脏读")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("不可重复读")]),t._v(" "),s("th",{staticStyle:{"text-align":"center"}},[t._v("幻读")])])]),t._v(" "),s("tbody",[s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("读未提交")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("√")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("√")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("√")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("读已提交")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("×")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("√")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("√")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("可重复读")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("×")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("×")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("√")])]),t._v(" "),s("tr",[s("td",{staticStyle:{"text-align":"center"}},[t._v("可串行化")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("×")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("×")]),t._v(" "),s("td",{staticStyle:{"text-align":"center"}},[t._v("×")])])])]),t._v(" "),s("p",[t._v("MySQL InnoDB 存储引擎的 "),s("strong",[t._v("默认隔离级别是 RR")]),t._v("。")]),t._v(" "),s("h3",{attrs:{id:"特殊的幻读问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#特殊的幻读问题"}},[t._v("#")]),t._v(" 特殊的幻读问题")]),t._v(" "),s("p",[t._v("可重复读隔离级别是通过 MVCC 实现的。理论上，新增记录的 trx_id 一定不满足当前事务的 Read View 可见性规则，因此对当前事务是不可见的。")]),t._v(" "),s("p",[t._v("但存在这样的特殊情况：如果当前事务对此新增数据执行 UPDATE 操作（UPDATE 是当前读，因此能够成功执行），这条记录的 trx_id 变为了当前事务本身，此时这条记录对当前事务可见，导致幻读。")]),t._v(" "),s("h2",{attrs:{id:"_7-5-mvcc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7-5-mvcc"}},[t._v("#")]),t._v(" 7.5 MVCC")]),t._v(" "),s("p",[t._v("MVCC，即 "),s("strong",[t._v("Multi-Version Concurrency Control （多版本并发控制）")]),t._v("。")]),t._v(" "),s("p",[t._v("通俗的讲，数据库中同时存在多个版本的数据，并不是整个数据库的多个版本，而是 "),s("strong",[t._v("某一条记录的多个版本同时存在")]),t._v("，在某个事务对其进行操作的时候，需要查看这一条记录的隐藏列事务版本 id，比对事务 id 并根据事物隔离级别去判断读取哪个版本的数据。")]),t._v(" "),s("p",[t._v("数据库隔离级别 "),s("strong",[t._v("读已提交、可重复读")]),t._v(" 都是基于 MVCC 实现的，相对于加锁简单粗暴的方式，它用更好的方式去处理读写冲突，能有效提高数据库并发性能。")]),t._v(" "),s("h3",{attrs:{id:"版本链"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#版本链"}},[t._v("#")]),t._v(" 版本链")]),t._v(" "),s("div",{staticClass:"subtitle"},[s("p",[t._v("事务版本号")])]),s("p",[t._v("事务每次开启前，都会从数据库获得一个 "),s("strong",[t._v("自增")]),t._v(" 长的事务 ID，可以从事务 ID 判断事务的执行先后顺序。这就是事务版本号。")]),t._v(" "),s("div",{staticClass:"subtitle"},[s("p",[t._v("trx_id、roll_pointer")])]),s("p",[t._v("对于 InnoDB 存储引擎，每一行记录都有两个隐藏列 trx_id、roll_pointer。")]),t._v(" "),s("ul",[s("li",[t._v("trx_id：记录操作该数据事务的事务 ID。")]),t._v(" "),s("li",[t._v("roll_pointer：相当于一个指针，指向回滚段的 undo 日志。")])]),t._v(" "),s("div",{staticClass:"subtitle"},[s("p",[t._v("undo log")])]),s("p",[t._v("undo log，即回滚日志，记录数据被修改前的信息。在表记录修改之前，会先把数据拷贝到 undo log 里，如果事务回滚，即可以通过 undo log 来还原数据。")]),t._v(" "),s("p",[t._v("当 delete 一条记录时，undo log 中记录一条对应的 insert 记录，当 update 一条记录时，undo log 中记录一条对应相反的 update 记录。")]),t._v(" "),s("div",{staticClass:"subtitle"},[s("p",[t._v("版本链")])]),s("p",[t._v("多个事务并行操作某一行数据时，不同事务对该行数据的修改会产生多个版本，然后通过 "),s("strong",[t._v("回滚指针（roll_pointer）")]),t._v("，连成一个链表，这个链表就称为 "),s("strong",[t._v("版本链")]),t._v("。如下：")]),t._v(" "),s("p",[s("img",{attrs:{src:a(456),alt:"image-20230211134738454"}})]),t._v(" "),s("h3",{attrs:{id:"快照读和当前读"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#快照读和当前读"}},[t._v("#")]),t._v(" 快照读和当前读")]),t._v(" "),s("div",{staticClass:"subtitle"},[s("p",[t._v("快照读")])]),s("p",[t._v("快照读的执行方式是生成 ReadView，直接利用 MVCC 机制来进行读取，并不会对记录进行加锁。")]),t._v(" "),s("div",{staticClass:"subtitle"},[s("p",[t._v("当前读")])]),s("p",[t._v("当前读，读取的是最新版本，并且需要先获取对应记录的锁，如以下这些 SQL 类型：")]),t._v(" "),s("div",{staticClass:"language-sql extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FOR")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("UPDATE")]),t._v(" \n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("LOCK")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("IN")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SHARE")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("MODE")]),t._v("\n")])])]),s("h3",{attrs:{id:"read-view"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#read-view"}},[t._v("#")]),t._v(" Read View")]),t._v(" "),s("p",[t._v("Read View 就是事务进行快照读操作的时候生产的 "),s("strong",[t._v("读视图（Read View）")]),t._v("，在该事务执行到快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的 ID。")]),t._v(" "),s("p",[t._v("Read View 的重要属性：")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("属性")]),t._v(" "),s("th",[t._v("描述")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("m_ids")]),t._v(" "),s("td",[t._v("当前系统中活跃（未提交）的读写事务 ID，数据结构为一个 List。")])]),t._v(" "),s("tr",[s("td",[t._v("min_limit_id")]),t._v(" "),s("td",[t._v("表示在生成 Read View 时，当前系统中活跃的读写事务中最小的事务 ID，即 m_ids 中的最小值。")])]),t._v(" "),s("tr",[s("td",[t._v("max_limit_id")]),t._v(" "),s("td",[t._v("表示生成 Read View 时，系统中应该分配给下一个事务的 ID 值。")])]),t._v(" "),s("tr",[s("td",[t._v("creator_trx_id")]),t._v(" "),s("td",[t._v("生成当前 Read View 的事务 ID。")])])])]),t._v(" "),s("div",{staticClass:"subtitle"},[s("p",[t._v("Read View 可见性规则")])]),s("p",[s("img",{attrs:{src:a(768),alt:"image-20230211152726771"}})]),t._v(" "),s("p",[t._v("如果 "),s("code",[t._v("trx_id == creator_trx_id")]),t._v("，表明该版本是当前事务生成的，因此，该版本可以被当前事务访问。")]),t._v(" "),s("p",[t._v("否则：")]),t._v(" "),s("p",[t._v("如果 "),s("code",[t._v("trx_id < min_limit_id")]),t._v("，表明生成该版本的事务在生成 Read View 前已经提交（因为事务 ID 是递增的），因此，该版本可以被当前事务访问。")]),t._v(" "),s("p",[t._v("如果 "),s("code",[t._v("trx_id >= max_limit_id")]),t._v("，表明生成该版本的事务在生成 Read View 后生成，因此，该版本不可以被当前事务访问。")]),t._v(" "),s("p",[t._v("如果 "),s("code",[t._v("min_limit_id =< trx_id < max_limit_id")]),t._v("，且 trx_id 不在 m_ids 中，表明生成该版本的事务在生成 Read View 前已经提交，因此，该版本可以被当前事务访问。")]),t._v(" "),s("p",[t._v("如果 "),s("code",[t._v("min_limit_id =< trx_id < max_limit_id")]),t._v("，且 trx_id 在 m_ids 中，表明生成该版本的事务在生成 Read View 时尚未提交，因此，该版本不可以被当前事务访问。")]),t._v(" "),s("h3",{attrs:{id:"隔离级别-rc-的实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#隔离级别-rc-的实现"}},[t._v("#")]),t._v(" 隔离级别 RC 的实现")]),t._v(" "),s("p",[t._v("RC 隔离级别下，每个快照读都会生成并获取最新的 Read View。")]),t._v(" "),s("h3",{attrs:{id:"隔离级别-rr-的实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#隔离级别-rr-的实现"}},[t._v("#")]),t._v(" 隔离级别 RR 的实现")]),t._v(" "),s("p",[t._v("RR 隔离级别下，只有在同一个事务的第一个快照读才会创建 Read View，之后的每次快照读都使用的同一个 Read View。")])])}),[],!1,null,null,null);_.default=v.exports},456:function(t,_,a){t.exports=a.p+"assets/img/image-20230211134738454.a4e72493.png"},765:function(t,_,a){t.exports=a.p+"assets/img/image-20230201165046628.9d1c8499.png"},766:function(t,_,a){t.exports=a.p+"assets/img/image-20230201165503783.b060ae42.png"},767:function(t,_,a){t.exports=a.p+"assets/img/image-20230201170007291.30b73512.png"},768:function(t,_,a){t.exports=a.p+"assets/img/image-20230211152726771.23ae4003.png"}}]);