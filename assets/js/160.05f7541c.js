(window.webpackJsonp=window.webpackJsonp||[]).push([[160],{1094:function(_,v,r){"use strict";r.r(v);var t=r(14),s=Object(t.a)({},(function(){var _=this,v=_.$createElement,r=_._self._c||v;return r("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[r("h1",{attrs:{id:"第4章-rocketmq-常见问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第4章-rocketmq-常见问题"}},[_._v("#")]),_._v(" 第4章 RocketMQ 常见问题")]),_._v(" "),r("h2",{attrs:{id:"_4-1-消息丢失"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-消息丢失"}},[_._v("#")]),_._v(" 4.1 消息丢失")]),_._v(" "),r("h3",{attrs:{id:"消息丢失的场景和解决方案"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#消息丢失的场景和解决方案"}},[_._v("#")]),_._v(" 消息丢失的场景和解决方案")]),_._v(" "),r("p",[r("strong",[_._v("消息发送阶段")]),_._v("：主要通过请求确认机制，保证消息可靠传递。")]),_._v(" "),r("p",[_._v("RocketMQ 提供了发送 "),r("RouterLink",{attrs:{to:"/rocket-mq/3jgi5r/#发送范例"}},[r("strong",[_._v("同步、异步和单向")])]),_._v(" 的多种范例。同步和异步发送能够保证消息不丢失：")],1),_._v(" "),r("ul",[r("li",[_._v("同步发送的时候，要注意处理响应结果和异常。如果返回响应 ACK，表示消息成功发送到了 Broker，如果响应失败，或者发生其它异常，则进行重试。")]),_._v(" "),r("li",[_._v("异步发送的时候，需要在回调方法里检查，如果发送失败或者异常，则进行重试。")]),_._v(" "),r("li",[_._v("如果发生超时的情况，可以通过查询日志的 API，来检查是否在 Broker 存储成功。")])]),_._v(" "),r("p",[r("strong",[_._v("消息存储阶段")]),_._v("：通过配置 "),r("strong",[_._v("可靠性优先")]),_._v(" 的 Broker 参数来避免因为宕机丢消息，简单说就是使用 "),r("strong",[_._v("同步")]),_._v("。")]),_._v(" "),r("p",[_._v("消息只要持久化到 commitLog 日志文件中，即使 Broker 宕机，未消费的消息也能重新恢复再消费。")]),_._v(" "),r("ul",[r("li",[_._v("刷盘机制：同步刷盘和异步刷盘都可以保证消息一定存储在 PageCache 中（Broker 内存中），但是 "),r("strong",[_._v("同步刷盘更可靠")]),_._v("，它是 Producer 发送消息后等数据持久化到磁盘之后再返回响应给 Producer。")]),_._v(" "),r("li",[_._v("集群部署：Broker 通过主从集群来保证高可用，主从间复制支持同步和异步模式。"),r("strong",[_._v("同步复制更可靠")]),_._v("，可以保证即使 Master 宕机，消息在 Slave 中仍有备份，保证了消息不会丢失。")])]),_._v(" "),r("p",[r("strong",[_._v("消息消费阶段")]),_._v("：Consumer 保证消息成功消费的关键在于确认的时机，不要在收到消息后就立即发送消费确认，而是在执行完所有消费业务逻辑之后，再发送消费确认。消息队列维护了消费到的位置，即使业务逻辑执行失败了，没有确认，再去队列拉取消息，就还是之前的一条。")]),_._v(" "),r("h2",{attrs:{id:"_4-2-消息重复"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-消息重复"}},[_._v("#")]),_._v(" 4.2 消息重复")]),_._v(" "),r("p",[_._v("RocketMQ 消费的至少一次原则：每条消息必须要被成功消费一次。")]),_._v(" "),r("p",[_._v("Consumer 在消费完消息后会向其消费进度记录器提交其消费消息的 offset，offset 被成功记录到记录器中，那么这条消费就被成功消费了。")]),_._v(" "),r("blockquote",[r("p",[_._v("对于广播消费模式来说，Consumer 本身就是消费进度记录器。对于集群消费模式来说，Broker 是消费进度记录器。")])]),_._v(" "),r("h3",{attrs:{id:"消费幂等"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#消费幂等"}},[_._v("#")]),_._v(" 消费幂等")]),_._v(" "),r("p",[_._v("当出现消费者对某条消息重复消费的情况时，重复消费的结果与消费一次的结果是相同的，并且多次消费并未对业务系统产生任何负面影响，那么这个消费过程就是消费幂等的。")]),_._v(" "),r("blockquote",[r("p",[r("strong",[_._v("幂等")]),_._v("：若某操作执行多次与执行一次对系统产生的影响是相同的，则称该操作是幂等的。")])]),_._v(" "),r("p",[_._v("在互联网应用中，尤其在网络不稳定的情况下，消息很有可能会出现重复发送或重复消费。如果重复的消息可能会影响业务处理，那么就应该对消息做幂等处理。")]),_._v(" "),r("h3",{attrs:{id:"消息重复的场景和解决方案"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#消息重复的场景和解决方案"}},[_._v("#")]),_._v(" 消息重复的场景和解决方案")]),_._v(" "),r("p",[r("strong",[_._v("发送时消息重复")]),_._v("：当一条消息已被成功发送到 Broker 并完成持久化，此时出现了网络闪断，从而导致 Broker 对 Producer 应答失败。如果 Producer 意识到消息发送失败并尝试再次发送消息，此时 Broker 中就可能会出现两条内容相同并且 Message ID 也相同的消息，那么后续 Consumer 就一定会消费两次该消息。")]),_._v(" "),r("p",[r("strong",[_._v("消费时消息重复")]),_._v("：消息已投递到 Consumer 并完成业务处理，当 Consumer 给 Broker 反馈应答时网络闪断，Broker 没有接收到消费成功响应。为了保证消息至少被消费一次的原则，Broker 将在网络恢复后再次尝试投递之前已被处理过的消息。此时消费者就会收到与之前处理过的内容相同、Message ID 也相同的消息。")]),_._v(" "),r("p",[r("strong",[_._v("Rebalance 时消息重复")]),_._v("：当 Consumer Group 中的 Consumer 数量发生变化时，或其订阅的 Topic 的 Queue 数量发生变化时，会触发 Rebalance，此时 Consumer 可能会收到曾经被消费过的消息。")]),_._v(" "),r("div",{staticClass:"anchor",attrs:{id:"解决方案"}},[_._v("解决方案")]),r("p",[_._v("RocketMQ 能保证消息不丢失，但 "),r("strong",[_._v("无法保证消息不重复")]),_._v("，实现幂等的最好方式是从业务逻辑上入手，将消费的业务逻辑设计成具备 "),r("strong",[_._v("幂等性")]),_._v(" 的操作。")]),_._v(" "),r("h2",{attrs:{id:"_4-3-消息堆积"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-消息堆积"}},[_._v("#")]),_._v(" 4.3 消息堆积")]),_._v(" "),r("h3",{attrs:{id:"消费能力"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#消费能力"}},[_._v("#")]),_._v(" 消费能力")]),_._v(" "),r("p",[_._v("消息堆积的主要瓶颈在于客户端的消费能力，而消费能力由 "),r("strong",[_._v("消费耗时")]),_._v(" 和 "),r("strong",[_._v("消费并发度")]),_._v(" 决定。注意，消费耗时的优先级要高于消费并发度。即在保证了消费耗时的合理性前提下，再考虑消费并发度问题。")]),_._v(" "),r("div",{staticClass:"subtitle"},[r("p",[_._v("消费耗时")])]),r("p",[_._v("影响消息处理时长的主要因素是代码逻辑。而代码逻辑中可能会影响处理时长代码主要有两种类型："),r("strong",[_._v("CPU 内部计算型代码")]),_._v(" 和 "),r("strong",[_._v("外部 I/O 操作型代码")]),_._v("。")]),_._v(" "),r("p",[_._v("内部计算耗时相对外部 I/O 操作来说几乎可以忽略，因此外部 IO 型代码是影响消息处理时长的主要症结所在，通常消息堆积是由于 "),r("strong",[_._v("下游系统出现了服务异常")]),_._v(" 或达到了 "),r("strong",[_._v("DBMS 容量限制")]),_._v("，导致消费耗时增加。")]),_._v(" "),r("div",{staticClass:"subtitle"},[r("p",[_._v("消费并发度")])]),r("p",[_._v("消费者端的消费并发度由单节点线程数和节点数量共同决定，其值为 "),r("strong",[_._v("单节点线程数 * 节点数量")]),_._v("。不过，通常需要优先调整单节点的线程数，若单机硬件资源达到了上限，则需要通过横向扩展来提高消费并发度。")]),_._v(" "),r("p",[r("strong",[_._v("单节点线程数")]),_._v("，即单个 Consumer 包含的线程数量；"),r("strong",[_._v("节点数量")]),_._v("，即 Consumer Group 包含的 Consumer 数量。")]),_._v(" "),r("h3",{attrs:{id:"消息堆积的场景和解决方案"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#消息堆积的场景和解决方案"}},[_._v("#")]),_._v(" 消息堆积的场景和解决方案")]),_._v(" "),r("p",[r("strong",[_._v("场景一")]),_._v("：新上线的消费者功能有 BUG，"),r("strong",[_._v("消息无法被消费")]),_._v("。")]),_._v(" "),r("p",[_._v("解决场景一，要做好 "),r("strong",[_._v("灰度发布")]),_._v("。每次新功能上线前，选取一定比例的消费实例做灰度，若出现问题，及时回滚；若消费者消费正常，平稳运行一段时间后，再升级其它实例。如果需要按规则选出一部分账号做灰度，则需要做好消息过滤， 让正常消费实例排除灰度消息，让灰度消费实例过滤出灰度消息。")]),_._v(" "),r("p",[r("strong",[_._v("场景二")]),_._v("：消费者实例宕机或因网络等问题暂时 "),r("strong",[_._v("无法同 Broker 建立连接")]),_._v("。")]),_._v(" "),r("p",[_._v("解决场景二，要做到 "),r("strong",[_._v("多活")]),_._v("。极端情况下，当一个集群内消费实例全部宕机时，需要做到让其他集群内的消费实例正常消费消息。同时，若一个集群内 Broker 全部宕机，需要支持生产者将消息发送至其它集群的 Broker。")]),_._v(" "),r("p",[r("strong",[_._v("场景三")]),_._v("：生产者短时间内推送大量消息至 Broker，"),r("strong",[_._v("消费者消费能力不足")]),_._v("。")]),_._v(" "),r("p",[_._v("解决场景三，要 "),r("strong",[_._v("增强消费能力")]),_._v("。增强消费能力，主要是 "),r("strong",[_._v("增加消费者线程数")]),_._v(" 或 "),r("strong",[_._v("增加消费者实例个数")]),_._v("。")]),_._v(" "),r("ul",[r("li",[_._v("增加消费者线程数，要注意消费者及其下游服务的消费能力，上线前就要将线程池参数调至最优状态。")]),_._v(" "),r("li",[_._v("增加消费者实例个数，要注意 Queue 数量。如果消费实例数量超过 Queue 数量，多出的消费实例分不到 Queue。如果消费实例数量比 Queue 数量少，每个消费实例承载的流量是不同的。")])]),_._v(" "),r("p",[r("strong",[_._v("场景四")]),_._v("：生产者 "),r("strong",[_._v("未感知 Broker 消费堆积")]),_._v(" 持续向 Broker 推送消息。")]),_._v(" "),r("p",[_._v("解决场景四，要做到 "),r("strong",[_._v("熔断与隔离")]),_._v("。当一个 Broker 的队列出现消息积压时，要对其熔断，将其隔离，将新消息发送至其它队列，过一定的时间，再解除其隔离。")])])}),[],!1,null,null,null);v.default=s.exports}}]);