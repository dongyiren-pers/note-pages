(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{596:function(_,v,t){_.exports=t.p+"assets/img/image-20240123003534631.f2430b79.png"},597:function(_,v,t){_.exports=t.p+"assets/img/image-20240123003919992.33ad0b3b.png"},997:function(_,v,t){"use strict";t.r(v);var s=t(14),a=Object(s.a)({},(function(){var _=this,v=_.$createElement,s=_._self._c||v;return s("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[s("h1",{attrs:{id:"第11章-并发控制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第11章-并发控制"}},[_._v("#")]),_._v(" 第11章 并发控制")]),_._v(" "),s("h2",{attrs:{id:"_11-1-并发控制概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_11-1-并发控制概述"}},[_._v("#")]),_._v(" 11.1 并发控制概述")]),_._v(" "),s("p",[_._v("事务是并发控制的基本单位。")]),_._v(" "),s("p",[_._v("并发操作带来的数据不一致性：")]),_._v(" "),s("ul",[s("li",[s("strong",[_._v("丢失修改")]),_._v("：两个事务 T1 和 T2 读入同一数据并修改，T2 提交的结果破坏了（覆盖了）T1 提交的结果，导致 T1 的修改被丢失。")]),_._v(" "),s("li",[s("strong",[_._v("不可重复读")]),_._v("：不可重复读是指事务 T1 读取某一数据后，事务 T2 对其执行更新操作，使 T1 无法再现前一次读取结果。")]),_._v(" "),s("li",[s("strong",[_._v("读 “脏” 数据")]),_._v("：读“脏”数据是指事务 T1 修改某一数据，并将其写回磁盘，事务 T2 读取同一数据后，T1 由于某种原因被撤销，这时 T1 已修改过的数据恢复原值，T2 读到的数据就与数据库中的数据不一致，则 T2 读到的数据就为“脏”数据，即不正确的数据。")])]),_._v(" "),s("h2",{attrs:{id:"_11-2-封锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_11-2-封锁"}},[_._v("#")]),_._v(" 11.2 封锁")]),_._v(" "),s("p",[s("strong",[_._v("封锁")]),_._v(" 就是 "),s("strong",[_._v("事务 T 在对某个数据对象例如表、记录等操作之前，先向系统发出请求，对其加锁")]),_._v("。加锁后事务 T 就对该数据对象有了一定的控制，在事务 T 释放它的锁之前，其他的事务不能更新或读取此数据对象。")]),_._v(" "),s("p",[_._v("基本的封锁类型有两种：**排他锁（简称 X 锁） **和 "),s("strong",[_._v("共享锁（简称 S 锁）")]),_._v("。")]),_._v(" "),s("ul",[s("li",[s("strong",[_._v("排他锁")]),_._v(" 又称为写锁。若事务 T 对数据对象 A 加上 X 锁，则只允许 T 读取和修改 A，其他任何事务都不能再对 A 加任何类型的锁，直到 T 释放 A 上的锁。这就保证了其他事务在 T 释放 A 上的锁之前不能再读取和修改 A。")]),_._v(" "),s("li",[s("strong",[_._v("共享锁")]),_._v(" 又称为读锁。若事务 T 对数据对象 A 加上 S 锁，则事务 T 可以读 A 但不能修改 A，其他事务只能再对 A 加 S 锁，而不能加 X 锁，直到 T 释放 A 上的 S 锁。这就保证了其他事务可以读 A，但在 T 释放 A 上的 S 锁之前不能对 A 做任何修改。")])]),_._v(" "),s("h3",{attrs:{id:"封锁协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#封锁协议"}},[_._v("#")]),_._v(" 封锁协议")]),_._v(" "),s("h4",{attrs:{id:"一级封锁协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一级封锁协议"}},[_._v("#")]),_._v(" 一级封锁协议")]),_._v(" "),s("p",[_._v("事务 T 在修改数据 R 之前必须先对其加 X 锁，直到事务结束才释放。")]),_._v(" "),s("p",[_._v("一级封锁协议可以 "),s("strong",[_._v("防止丢失修改")]),_._v("，并保证事务 T 是可恢复的。")]),_._v(" "),s("h4",{attrs:{id:"二级封锁协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二级封锁协议"}},[_._v("#")]),_._v(" 二级封锁协议")]),_._v(" "),s("p",[_._v("一级封锁协议加上事务 T 在读取数据 R 之前必须先对其加 S 锁，"),s("strong",[_._v("读完后即可释放 S 锁。")])]),_._v(" "),s("p",[_._v("二级封锁协议可以 "),s("strong",[_._v("防止丢失修改和读 “脏” 数据")]),_._v("。")]),_._v(" "),s("h4",{attrs:{id:"三级封锁协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三级封锁协议"}},[_._v("#")]),_._v(" 三级封锁协议")]),_._v(" "),s("p",[_._v("一级封锁协议加上事务 T 在读取数据 R 之前必须先对其加 S 锁，"),s("strong",[_._v("直到事务结束才释放")]),_._v("。")]),_._v(" "),s("p",[_._v("三级封锁协议可防止 "),s("strong",[_._v("丢失修改、读脏数据和不可重复读。")])]),_._v(" "),s("h3",{attrs:{id:"活锁和死锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#活锁和死锁"}},[_._v("#")]),_._v(" 活锁和死锁")]),_._v(" "),s("h4",{attrs:{id:"活锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#活锁"}},[_._v("#")]),_._v(" 活锁")]),_._v(" "),s("p",[_._v("如果事务 T1 封锁了数据 R，事务 T2 又请求封锁 R，于是 T2 等待。T3 也请求封锁 R，当 T1 释放了 R 上的封锁之后系统首先批准了 T3 的请求，T2 仍然等待。然后 T4 又请求封锁 R，当 T3 释放了 R 上的封锁之后系统又批准了 T4 的请求……T2 有可能永远等待。这就是活锁的情形。"),s("strong",[_._v("活锁的含义是该等待事务等待时间太长，似乎被锁住了，实际上可能被激活")]),_._v("。")]),_._v(" "),s("p",[_._v("活锁产生的原因："),s("strong",[_._v("当一系列封锁不能按照其先后顺序执行时，就可能导致一些事务无限期等待某个封锁")]),_._v("，从而导致活锁。")]),_._v(" "),s("p",[_._v("避免活锁：**避免活锁的简单方法是采用先来先服务的策略。**当多个事务请求封锁同一数据对象时，封锁子系统按请求封锁的先后次序对事务排队，数据对象上的锁一旦释放就批准申请队列中第一个事务获得锁。")]),_._v(" "),s("h4",{attrs:{id:"死锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#死锁"}},[_._v("#")]),_._v(" 死锁")]),_._v(" "),s("p",[_._v("如果事务 T1 封锁了数据 R1，T2 封锁了数据 R2，然后 T1 又请求封锁 R2，因 T2 已封锁了 R2，于是 T1 等待 T2 释放 R2 上的锁。接着 T2 又申请封锁 R1，因 T1 已封锁了 R1，T2 也只能等待 T1 释放 R1 上的锁。这样就出现了 "),s("strong",[_._v("T1 在等待 T2，而 T2 又在等待 T1 的局面，T1 和 T2 两个事务永远不能结束，形成死锁")]),_._v("。")]),_._v(" "),s("p",[_._v("防止死锁的发生其实就是要破坏产生死锁的条件。预防死锁通常有两种方法：")]),_._v(" "),s("ul",[s("li",[s("strong",[_._v("一次封锁法")]),_._v("：要求每个事务必须一次将所有要使用的数据全部加锁，否则就不能继续执行。")]),_._v(" "),s("li",[s("strong",[_._v("顺序封锁法")]),_._v("：预先对数据对象规定一个封锁顺序，所有事务都按这个顺序实行封锁。")])]),_._v(" "),s("p",[_._v("数据库系统一般采用的方法是允许死锁发生，DBMS 检测到死锁后加以解除。")]),_._v(" "),s("p",[_._v("DBMS中诊断死锁的方法与操作系统类似，一般使用 "),s("strong",[_._v("超时法")]),_._v(" 或 "),s("strong",[_._v("事务等待图法")]),_._v("。超时法是指如果一个事务的等待时间超过了规定的时限，就认为发生了死锁。")]),_._v(" "),s("p",[_._v("DBMS 并发控制子系统检测到死锁后，就要设法解除。通常采用的方法是 "),s("strong",[_._v("选择一个处理死锁代价最小的事务，将其撤销，释放此事务持有的所有锁")]),_._v("，使其他事务得以继续运行下去。")]),_._v(" "),s("h3",{attrs:{id:"并发调度的可串行性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#并发调度的可串行性"}},[_._v("#")]),_._v(" 并发调度的可串行性")]),_._v(" "),s("p",[s("strong",[_._v("可串行化的调度是正确的调度")]),_._v("。")]),_._v(" "),s("p",[_._v("可串行化的调度的定义：多个事务的并发执行是正确的，当且仅当其结果 "),s("strong",[_._v("与按某一次序串行地执行它们时的结果相同")]),_._v("，称这种调度策略为可串行化的调度。")]),_._v(" "),s("div",{staticClass:"anchor",attrs:{id:"冲突可串行化的调度"}},[_._v("冲突可串行化的调度")]),s("p",[_._v("一个调度 Sc 在保证冲突操作的次序不变的情况下，通过 "),s("strong",[_._v("交换两个事务不冲突操作的次序")]),_._v(" 得到另一个调度 Sc’，如果 Sc’ 是串行的，称调度 Sc 是冲突可串行化的调度。")]),_._v(" "),s("p",[s("strong",[_._v("冲突操作")]),_._v("：是指不同的事务对同一数据的读写操作和写写操作。")]),_._v(" "),s("h3",{attrs:{id:"两段锁协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#两段锁协议"}},[_._v("#")]),_._v(" 两段锁协议")]),_._v(" "),s("p",[_._v("两段锁协议：")]),_._v(" "),s("ul",[s("li",[s("strong",[_._v("扩展阶段")]),_._v("：事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁；")]),_._v(" "),s("li",[s("strong",[_._v("收缩阶段")]),_._v("：事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁。")])]),_._v(" "),s("p",[_._v("事务遵守两段锁协议是可串行化调度的 "),s("strong",[_._v("充分条件")]),_._v("，而不是必要条件。")]),_._v(" "),s("h3",{attrs:{id:"封锁的粒度"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#封锁的粒度"}},[_._v("#")]),_._v(" 封锁的粒度")]),_._v(" "),s("p",[_._v("封锁对象的大小称为封锁粒度。")]),_._v(" "),s("h4",{attrs:{id:"多粒度封锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#多粒度封锁"}},[_._v("#")]),_._v(" 多粒度封锁")]),_._v(" "),s("div",{staticStyle:{"text-align":"center"}},[s("img",{staticStyle:{zoom:"67%"},attrs:{src:t(596),alt:"image-20240123003534631"}})]),s("p",[_._v("对一个结点加锁意味着这个结点的所有后裔结点也被加以同样类型的锁。")]),_._v(" "),s("p",[_._v("在多粒度封锁中一个数据对象可能以两种方式封锁：显式封锁和隐式封锁。")]),_._v(" "),s("ul",[s("li",[_._v("显式封锁: 直接加到数据对象上的封锁；")]),_._v(" "),s("li",[_._v("隐式封锁: 是该数据对象没有独立加锁，是由于其上级结点加锁而使该数据对象加上了锁。")])]),_._v(" "),s("h4",{attrs:{id:"意向锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#意向锁"}},[_._v("#")]),_._v(" 意向锁")]),_._v(" "),s("p",[_._v("引进意向锁是为了 "),s("strong",[_._v("提高封锁子系统的效率")]),_._v("。")]),_._v(" "),s("p",[s("strong",[_._v("原因是")]),_._v("：在多粒度封锁方法中，一个数据对象可能以两种方式加锁——显式封锁和隐式封锁。因此系统在对某一数据对象加锁时，不仅要检查该数据对象上有无（显式和隐式）封锁与之冲突，还要检查其所有上级结点和所有下级结点，看申请的封锁是否与这些结点上的（显式和隐式）封锁冲突。显然，这样的检查方法效率很低。为此引进了意向锁。")]),_._v(" "),s("p",[s("strong",[_._v("意向锁的含义是")]),_._v("："),s("strong",[_._v("对任一结点加锁时，必须先对它的上层结点加意向锁")]),_._v("。引进意向锁后，系统对某一数据对象加锁时不必逐个检查与下一级结点的封锁冲突了。")]),_._v(" "),s("div",{staticClass:"anchor",attrs:{id:"常用意向锁"}},[_._v("常用意向锁")]),s("ul",[s("li",[s("strong",[_._v("意向共享锁 （IS 锁）")]),_._v("：如果对一个数据对象加 IS 锁，表示它的后裔结点拟（意向）加 S 锁。例如，要对某个元组加 S 锁，则要首先对关系和数据库加 IS 锁。")]),_._v(" "),s("li",[s("strong",[_._v("意向排它锁（IX 锁）")]),_._v("：如果对一个数据对象加 IX 锁，表示它的后裔结点拟（意向）加 X 锁。例如，要对某个元组加 X 锁，则要首先对关系和数据库加 IX 锁。")]),_._v(" "),s("li",[s("strong",[_._v("共享意向排它锁（SIX 锁）")]),_._v("：如果对一个数据对象加 SIX 锁，表示对它加 S 锁，再加 IX 锁，即对数据对象加 S 锁，后裔结点拟加 X 锁。")])]),_._v(" "),s("p",[_._v("意向锁的相容矩阵：")]),_._v(" "),s("p",[s("img",{attrs:{src:t(597),alt:"image-20240123003919992"}})]),_._v(" "),s("blockquote",[s("p",[s("strong",[_._v("问题：意向锁中为什么存在 SIX 锁，而没有 XIS 锁。")])]),_._v(" "),s("p",[_._v("X 锁与任何其他类型的锁都不相容，如果数据对象被加上 X 锁，后裔结点不可能被以任何锁的形式访问，因此 XIS 锁没有意义。")])])])}),[],!1,null,null,null);v.default=a.exports}}]);