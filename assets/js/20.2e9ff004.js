(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{1058:function(a,t,s){"use strict";s.r(t);var e=s(14),v=Object(e.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"第4章-垃圾回收"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第4章-垃圾回收"}},[a._v("#")]),a._v(" 第4章 垃圾回收")]),a._v(" "),e("h2",{attrs:{id:"_4-1-判断对象是否可被回收"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-判断对象是否可被回收"}},[a._v("#")]),a._v(" 4.1 判断对象是否可被回收")]),a._v(" "),e("h3",{attrs:{id:"引用计数算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#引用计数算法"}},[a._v("#")]),a._v(" 引用计数算法")]),a._v(" "),e("p",[a._v("给对象添加一个引用计数器，每当有一个其他对象引用它时，计数器加 1；引用失效时，计数器减 1。")]),a._v(" "),e("p",[a._v("引用计数为 0 的对象可被回收。")]),a._v(" "),e("p",[a._v("两个对象出现循环引用的情况下，引用计数器永远不为 0，导致无法对它们进行回收。正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。")]),a._v(" "),e("h3",{attrs:{id:"可达性分析算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#可达性分析算法"}},[a._v("#")]),a._v(" 可达性分析算法")]),a._v(" "),e("p",[a._v("通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是存活的，不可达的对象可被回收。")]),a._v(" "),e("p",[e("img",{attrs:{src:s(729),alt:"image-20230128153430190"}})]),a._v(" "),e("div",{staticClass:"anchor",attrs:{id:"gc-roots"}},[a._v("GC Roots")]),e("p",[a._v("Java 虚拟机使用该算法来判断对象是否可被回收，在 Java 中 "),e("strong",[a._v("GC Roots 一般包含以下内容：")])]),a._v(" "),e("ul",[e("li",[e("strong",[a._v("本地方法栈")]),a._v(" 和 "),e("strong",[a._v("虚拟机栈")]),a._v(" 中引用的对象")]),a._v(" "),e("li",[a._v("方法区中类的 "),e("strong",[a._v("静态属性")]),a._v(" 和 "),e("strong",[a._v("常量")]),a._v(" 引用的对象")]),a._v(" "),e("li",[a._v("跨代引用对象")]),a._v(" "),e("li",[a._v("被同步锁持有的对象")])]),a._v(" "),e("h3",{attrs:{id:"引用类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#引用类型"}},[a._v("#")]),a._v(" 引用类型")]),a._v(" "),e("p",[a._v("无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关。Java 具有四种强度不同的引用类型。")]),a._v(" "),e("div",{staticClass:"anchor",attrs:{id:"强引用"}},[a._v("强引用")]),e("p",[a._v("被强引用关联的对象不会被回收。")]),a._v(" "),e("p",[a._v("使用 new 一个新对象的方式来创建强引用。")]),a._v(" "),e("div",{staticClass:"language-java extra-class"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" obj "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),e("div",{staticClass:"anchor",attrs:{id:"软引用"}},[a._v("软引用")]),e("p",[a._v("被软引用关联的对象只有在内存不够的情况下才会被回收。")]),a._v(" "),e("p",[a._v("使用 SoftReference 类来创建软引用。")]),a._v(" "),e("div",{staticClass:"language-java extra-class"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" obj "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SoftReference")]),e("span",{pre:!0,attrs:{class:"token generics"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" sf "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("SoftReference")]),e("span",{pre:!0,attrs:{class:"token generics"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("obj"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\nobj "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 使对象只被软引用关联")]),a._v("\n")])])]),e("div",{staticClass:"anchor",attrs:{id:"弱引用"}},[a._v("弱引用")]),e("p",[a._v("被弱引用关联的对象一定会被回收，它只能存活到下一次垃圾回收发生之前。")]),a._v(" "),e("p",[a._v("使用 WeakReference 类来实现弱引用。")]),a._v(" "),e("div",{staticClass:"language-java extra-class"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" obj "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("WeakReference")]),e("span",{pre:!0,attrs:{class:"token generics"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" wf "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("WeakReference")]),e("span",{pre:!0,attrs:{class:"token generics"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("obj"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\nobj "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),e("div",{staticClass:"anchor",attrs:{id:"虚引用"}},[a._v("虚引用")]),e("p",[a._v("又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。")]),a._v(" "),e("p",[a._v("为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。")]),a._v(" "),e("p",[a._v("使用 PhantomReference 来实现虚引用。")]),a._v(" "),e("div",{staticClass:"language-java extra-class"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),a._v(" obj "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("PhantomReference")]),e("span",{pre:!0,attrs:{class:"token generics"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" pf "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("PhantomReference")]),e("span",{pre:!0,attrs:{class:"token generics"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("obj"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\nobj "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])])]),e("h2",{attrs:{id:"_4-2-垃圾回收算法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-垃圾回收算法"}},[a._v("#")]),a._v(" 4.2 垃圾回收算法")]),a._v(" "),e("h3",{attrs:{id:"标记-清除"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#标记-清除"}},[a._v("#")]),a._v(" 标记-清除")]),a._v(" "),e("p",[e("img",{attrs:{src:s(730),alt:"image-20230128172944421"}})]),a._v(" "),e("p",[a._v("将存活的对象进行标记，然后清理掉未被标记的对象。")]),a._v(" "),e("p",[e("strong",[a._v("优点")]),a._v("：实现简单，不需要对象进行移动。")]),a._v(" "),e("p",[e("strong",[a._v("缺点")]),a._v("：")]),a._v(" "),e("ul",[e("li",[a._v("执行效率不稳定。如果 Java 堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低。")]),a._v(" "),e("li",[a._v("内存空间的碎片化问题。标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发一次垃圾收集动作。")])]),a._v(" "),e("h3",{attrs:{id:"标记-整理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#标记-整理"}},[a._v("#")]),a._v(" 标记-整理")]),a._v(" "),e("p",[e("img",{attrs:{src:s(731),alt:"image-20230128173217208"}})]),a._v(" "),e("p",[a._v("将存活的对象进行标记，将存活的对象向一端移动，然后直接清理掉端边界以外的内存。")]),a._v(" "),e("p",[a._v("根据老年代的特点提出的一种垃圾回收算法。")]),a._v(" "),e("p",[e("strong",[a._v("优点")]),a._v("：解决了标记-清除算法存在的内存碎片问题。")]),a._v(" "),e("p",[e("strong",[a._v("缺点")]),a._v("：需要进行局部对象移动，一定程度上降低了效率。")]),a._v(" "),e("h3",{attrs:{id:"标记-复制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#标记-复制"}},[a._v("#")]),a._v(" 标记-复制")]),a._v(" "),e("p",[e("img",{attrs:{src:s(732),alt:"image-20230128173637121"}})]),a._v(" "),e("p",[a._v("将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。")]),a._v(" "),e("p",[e("strong",[a._v("主要缺点是只使用了内存的一半。")])]),a._v(" "),e("p",[a._v("现在的商业虚拟机都采用这种收集算法来回收新生代，但是并不是将新生代划分为大小相等的两块，而是分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中一块 Survivor 空间。在回收时，将 Eden 空间和 Survivor 空间中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 空间和使用过的那一块 Survivor 空间。")]),a._v(" "),e("p",[a._v("HotSpot 虚拟机的 Eden 空间和 Survivor 空间的大小比例默认为 8:1，保证了内存利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保（Handle Promotion），即借用老年代的空间存储放不下的对象。")]),a._v(" "),e("h3",{attrs:{id:"分代收集"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分代收集"}},[a._v("#")]),a._v(" 分代收集")]),a._v(" "),e("p",[a._v("当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。")]),a._v(" "),e("p",[a._v("新生代中，每次收集都会有大量对象死去，所以可以选择 “标记-复制” 算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择 “标记-清除” 或 “标记-整理” 算法进行垃圾收集。")]),a._v(" "),e("div",{staticClass:"subtitle"},[e("p",[a._v("分代收集理论")])]),e("p",[a._v("当前商业虚拟机的垃圾收集器，大多数都遵循了 “分代收集”（GenerationalCollection）的理论进行设计，分代收集实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：")]),a._v(" "),e("ul",[e("li",[a._v("弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。")]),a._v(" "),e("li",[a._v("强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。")])]),a._v(" "),e("p",[a._v("这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将 Java 堆划分出不同的区域，然后将回收对象依据其年龄（即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。")]),a._v(" "),e("p",[a._v("显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间；如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。")]),a._v(" "),e("h2",{attrs:{id:"_4-3-垃圾收集器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-垃圾收集器"}},[a._v("#")]),a._v(" 4.3 垃圾收集器")]),a._v(" "),e("p",[a._v("如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。")]),a._v(" "),e("h3",{attrs:{id:"serial-收集器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#serial-收集器"}},[a._v("#")]),a._v(" Serial 收集器")]),a._v(" "),e("p",[a._v("Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。看名字就知道这个收集器是一个单线程收集器了。它的 "),e("strong",[a._v("“单线程”")]),a._v(" 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是 "),e("strong",[a._v("它在进行垃圾收集工作时必须暂停其他所有的工作线程（“Stop The World”），直到它收集结束。")])]),a._v(" "),e("p",[a._v("新生代采用 "),e("strong",[a._v("标记-复制")]),a._v(" 算法，老年代采用 "),e("strong",[a._v("标记-整理")]),a._v(" 算法。")]),a._v(" "),e("p",[e("img",{attrs:{src:s(733),alt:"image-20230128180906800"}})]),a._v(" "),e("p",[a._v("虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。")]),a._v(" "),e("p",[a._v("Serial 收集器有优于其他垃圾收集器的地方："),e("strong",[a._v("简单而高效（与其他收集器的单线程相比）")]),a._v("。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择。")]),a._v(" "),e("h3",{attrs:{id:"parnew-收集器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#parnew-收集器"}},[a._v("#")]),a._v(" ParNew 收集器")]),a._v(" "),e("p",[a._v("ParNew 收集器其实就是 "),e("strong",[a._v("Serial 收集器的多线程版本")]),a._v("，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。")]),a._v(" "),e("p",[a._v("新生代采用 "),e("strong",[a._v("标记-复制")]),a._v(" 算法，老年代采用 "),e("strong",[a._v("标记-整理")]),a._v(" 算法。")]),a._v(" "),e("p",[e("img",{attrs:{src:s(734),alt:"image-20230128181217618"}})]),a._v(" "),e("p",[a._v("ParNew 收集器是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器）配合工作。")]),a._v(" "),e("h3",{attrs:{id:"parallel-scavenge-收集器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#parallel-scavenge-收集器"}},[a._v("#")]),a._v(" Parallel Scavenge 收集器")]),a._v(" "),e("p",[a._v("Parallel Scavenge 与 ParNew 一样是多线程收集器。")]),a._v(" "),e("p",[e("strong",[a._v("Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。")]),a._v(" CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。")]),a._v(" "),e("blockquote",[e("p",[a._v("吞吐量是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。")])]),a._v(" "),e("p",[a._v("新生代采用 "),e("strong",[a._v("标记-复制")]),a._v(" 算法，老年代采用 "),e("strong",[a._v("标记-整理")]),a._v(" 算法。")]),a._v(" "),e("p",[e("img",{attrs:{src:s(735),alt:"image-20230128182434898"}})]),a._v(" "),e("p",[a._v("停顿时间短适合需要与用户交互的程序，良好的响应速度能提升用户体验。高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。")]),a._v(" "),e("p",[e("strong",[a._v("缩短停顿时间是以牺牲吞吐量和新生代空间为代价的")]),a._v("：新生代空间变小，停顿时间变短，但垃圾回收变得频繁，导致吞吐量下降。")]),a._v(" "),e("p",[a._v("JDK1.8 默认使用的是 Parallel Scavenge 和 Parallel Old。")]),a._v(" "),e("h3",{attrs:{id:"serial-old-收集器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#serial-old-收集器"}},[a._v("#")]),a._v(" Serial Old 收集器")]),a._v(" "),e("p",[a._v("Serial 收集器的 "),e("strong",[a._v("老年代版本")]),a._v("，同样是一个单线程收集器。主要有两大用途：")]),a._v(" "),e("ul",[e("li",[a._v("在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用。")]),a._v(" "),e("li",[a._v("作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用。")])]),a._v(" "),e("h3",{attrs:{id:"parallel-old-收集器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#parallel-old-收集器"}},[a._v("#")]),a._v(" Parallel Old 收集器")]),a._v(" "),e("p",[a._v("Parallel Scavenge 收集器的 "),e("strong",[a._v("老年代版本")]),a._v("。使用多线程和 “标记-整理” 算法。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。")]),a._v(" "),e("h3",{attrs:{id:"cms-收集器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cms-收集器"}},[a._v("#")]),a._v(" CMS 收集器")]),a._v(" "),e("p",[a._v("CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，实现了垃圾收集线程与用户线程（基本上）的同时工作。")]),a._v(" "),e("p",[e("strong",[a._v("CMS 收集器是老年代收集器。")])]),a._v(" "),e("p",[a._v("从名字中的 Mark Sweep 两个词可以看出，CMS 收集器是基于 "),e("strong",[a._v("“标记-清除”")]),a._v(" 算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：")]),a._v(" "),e("ul",[e("li",[e("strong",[a._v("初始标记：")]),a._v(" 暂停所有的其他线程，并记录下直接与 GC Roots 相连的对象，速度很快 ；")]),a._v(" "),e("li",[e("strong",[a._v("并发标记：")]),a._v(" 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。并发标记阶段结束时，闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，GC 线程无法保证可达性分析的实时性。因此要跟踪记录这些发生引用更新的地方。")]),a._v(" "),e("li",[e("strong",[a._v("重新标记：")]),a._v(" 修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，但远比并发标记阶段时间短。")]),a._v(" "),e("li",[e("strong",[a._v("并发清除：")]),a._v(" 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。")])]),a._v(" "),e("p",[e("img",{attrs:{src:s(736),alt:"image-20230128191258792"}})]),a._v(" "),e("p",[e("strong",[a._v("优点")]),a._v("：并发收集、低停顿。")]),a._v(" "),e("p",[e("strong",[a._v("缺点")]),a._v("：")]),a._v(" "),e("ul",[e("li",[a._v("吞吐量低。低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。")]),a._v(" "),e("li",[a._v("无法处理浮动垃圾，可能出现 Concurrent Mode Failure。")])]),a._v(" "),e("blockquote",[e("p",[a._v("浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。")])]),a._v(" "),e("ul",[e("li",[a._v("“标记-清除” 算法导致的空间碎片，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC。")])]),a._v(" "),e("h3",{attrs:{id:"g1-收集器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#g1-收集器"}},[a._v("#")]),a._v(" G1 收集器")]),a._v(" "),e("p",[a._v("G1 （Garbage-First） 是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征。")]),a._v(" "),e("p",[e("strong",[a._v("G1 是整堆收集器。")])]),a._v(" "),e("p",[a._v("在 JDK1.7 版本正式启用，是 "),e("strong",[a._v("JDK 9 以后的默认垃圾收集器，取代了 CMS 收集器")]),a._v("。")]),a._v(" "),e("p",[a._v("开启 G1 收集器："),e("code",[a._v("-XX:+UseG1GC")])]),a._v(" "),e("p",[a._v("设置 GC 的最大暂停时间为 XXms："),e("code",[a._v("-XX:MaxGCPauseMillis=XX")])]),a._v(" "),e("div",{staticClass:"subtitle"},[e("p",[a._v("G1 堆内存分配")])]),e("p",[e("img",{attrs:{src:s(737),alt:"image-20230207234914717"}})]),a._v(" "),e("p",[a._v("G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。")]),a._v(" "),e("p",[a._v("区域 （Region） 的大小，可以通过 "),e("code",[a._v("-XX:G1HeapRegionSize")]),a._v(" 参数指定，大小区间最小 1M 、最大 32M ，总之是 2 的幂次方。默认将堆内存按照 2048 份均分。")]),a._v(" "),e("p",[a._v("每个 Region 被标记了 "),e("strong",[a._v("E、S、O")]),a._v("，这些区域在逻辑上被映射为 "),e("strong",[a._v("Eden、Survivor 和老年代")]),a._v("。")]),a._v(" "),e("p",[a._v("存活的对象从一个区域转移（即复制或移动）到另一个区域。")]),a._v(" "),e("p",[a._v("此外，还有第四种类型，被称为 "),e("strong",[a._v("巨型区域")]),a._v("（Humongous Region）。Humongous 区域主要是为存储超过 50% 标准 Region 大小的对象而设计，它用来专门存放巨型对象。如果一个 H 区装不下一个巨型对象，G1 会寻找连续的 H 分区来存储。为了能找到连续的 H 区，有时候不得不启动 Full GC 。")]),a._v(" "),e("p",[a._v("通过引入 Region 的概念，从而将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收。这种划分方法带来了很大的灵活性，使得可预测的停顿时间模型成为可能。通过记录每个 Region 垃圾回收时间以及回收所获得的空间（这两个值是通过过去回收的经验获得），并维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。")]),a._v(" "),e("div",{staticClass:"subtitle"},[e("p",[a._v("Remembered Set")])]),e("p",[a._v("每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描。")]),a._v(" "),e("div",{staticClass:"subtitle"},[e("p",[a._v("G1 回收流程")])]),e("p",[a._v("如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：")]),a._v(" "),e("ul",[e("li",[e("strong",[a._v("初始标记")]),a._v("：这个阶段是 STW （Stop the World） 的，所有应用线程会被暂停，标记从 GC Root 开始直接可达的对象。")]),a._v(" "),e("li",[e("strong",[a._v("并发标记")]),a._v("：从 GC Roots 开始，对堆中对象进行可达性分析，找出存活对象，耗时较长。")]),a._v(" "),e("li",[e("strong",[a._v("最终标记")]),a._v("：标记在并发标记阶段发生变化的对象，将被回收。")]),a._v(" "),e("li",[e("strong",[a._v("筛选回收")]),a._v("：对各个 Regin 根据回收价值和成本进行排序，根据用户所期待的 GC 停顿时间，指定回收计划，回收一部分 Region 。")])]),a._v(" "),e("div",{staticClass:"subtitle"},[e("p",[a._v("G1 特点")])]),e("p",[a._v("具备如下特点：")]),a._v(" "),e("ul",[e("li",[a._v("空间整合：整体上来看是基于 “标记-整理” 算法实现的收集器，从局部（两个 Region 之间）上来看是基于 “复制” 算法实现的，这意味着运行期间不会产生内存空间碎片。")]),a._v(" "),e("li",[a._v("可预测的停顿：允许使用者指定在一个长度为 M 毫秒的时间片段内，GC 的时间不得超过 N 毫秒。")])]),a._v(" "),e("h2",{attrs:{id:"_4-4-内存分配与回收策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-4-内存分配与回收策略"}},[a._v("#")]),a._v(" 4.4 内存分配与回收策略")]),a._v(" "),e("h3",{attrs:{id:"minor-gc、major-gc、full-gc"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#minor-gc、major-gc、full-gc"}},[a._v("#")]),a._v(" Minor GC、Major GC、Full GC")]),a._v(" "),e("p",[a._v("JVM 进行 GC 时，并非每次都对堆内存（新生代、老年代、方法区）区域一起回收的，大部分时候回收的都是指新生代。")]),a._v(" "),e("p",[a._v("针对 HotSpot VM 的实现，GC 按照回收区域又分为两大类：部分收集、整堆收集")]),a._v(" "),e("p",[e("strong",[a._v("部分收集（Partial GC）")]),a._v("：不是完整收集整个 Java 堆的垃圾收集。其中又分为：")]),a._v(" "),e("ul",[e("li",[a._v("新生代收集（Minor GC / Young GC）：只是新生代的垃圾收集。")]),a._v(" "),e("li",[a._v("老年代收集（Major GC / Old GC）：只是老年代的垃圾收集。很多时候 Major GC 会和 Full GC 混合使用，需要具体分辨是老年代回收还是整堆回收。目前，只有 CMS GC 会有单独收集老年代的行为。")]),a._v(" "),e("li",[a._v("混合收集（Mixed GC）：整个新生代以及部分老年代的垃圾收集。目前只有 G1 GC 会有这种行为。")])]),a._v(" "),e("p",[e("strong",[a._v("整堆收集（Full GC）")]),a._v("：收集整个 Java 堆和方法区的垃圾。")]),a._v(" "),e("h3",{attrs:{id:"内存分配策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存分配策略"}},[a._v("#")]),a._v(" 内存分配策略")]),a._v(" "),e("div",{staticClass:"subtitle"},[e("p",[a._v("对象优先在 Eden 分配")])]),e("p",[a._v("大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。")]),a._v(" "),e("div",{staticClass:"subtitle"},[e("p",[a._v("大对象直接进入老年代")])]),e("p",[a._v("大对象是指需要大量连续内存空间的对象，频繁出现大对象是致命的，会导致在内存还有不少空间的情况下提前触发 GC 以获取足够的连续空间来安置新对象。")]),a._v(" "),e("p",[a._v("如果大对象直接在新生代分配就会导致 Eden 区和两个 Survivor 区之间发生大量的内存复制。因此对于大对象都会直接在老年代进行分配。")]),a._v(" "),e("div",{staticClass:"subtitle"},[e("p",[a._v("长期存活的对象进入老年代")])]),e("p",[a._v("对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄（默认情况下，阈值为15）则移动到老年代中。可通过 "),e("code",[a._v("-XX:MaxTenuringThreshold")]),a._v(" 来定义年龄的阈值。")]),a._v(" "),e("div",{staticClass:"subtitle"},[e("p",[a._v("动态对象年龄判定")])]),e("p",[a._v("虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代。如果在当前的 Survivor 区中，一批对象的总大小超过了该 Survivor 区内存大小的 50%，此时大于等于这批对象年龄的对象可以直接晋升到老年代。")]),a._v(" "),e("div",{staticClass:"subtitle"},[e("p",[a._v("空间分配担保")])]),e("p",[a._v("在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立， Minor GC 可以确认是安全的。如果不成立，虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 设置不允许冒险，那么就要进行一次 Full GC。")])])}),[],!1,null,null,null);t.default=v.exports},729:function(a,t,s){a.exports=s.p+"assets/img/image-20230128153430190.382b6f63.png"},730:function(a,t,s){a.exports=s.p+"assets/img/image-20230128172944421.1c5e8708.png"},731:function(a,t,s){a.exports=s.p+"assets/img/image-20230128173217208.3ca27b17.png"},732:function(a,t,s){a.exports=s.p+"assets/img/image-20230128173637121.e65fe605.png"},733:function(a,t,s){a.exports=s.p+"assets/img/image-20230128180906800.25fb7154.png"},734:function(a,t,s){a.exports=s.p+"assets/img/image-20230128181217618.3913c405.png"},735:function(a,t,s){a.exports=s.p+"assets/img/image-20230128182434898.26a8a9e0.png"},736:function(a,t,s){a.exports=s.p+"assets/img/image-20230128191258792.b9004fcc.png"},737:function(a,t,s){a.exports=s.p+"assets/img/image-20230207234914717.53ba7145.png"}}]);