(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{1026:function(t,a,r){"use strict";r.r(a);var e=r(14),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"spring"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring"}},[t._v("#")]),t._v(" Spring")]),t._v(" "),e("p"),e("div",{staticClass:"table-of-contents"},[e("ul",[e("li",[e("a",{attrs:{href:"#spring-core"}},[t._v("Spring Core")]),e("ul",[e("li",[e("a",{attrs:{href:"#什么是-spring-框架"}},[t._v("什么是 Spring 框架")])]),e("li",[e("a",{attrs:{href:"#spring-中的设计模式"}},[t._v("Spring 中的设计模式")])]),e("li",[e("a",{attrs:{href:"#什么是-ioc"}},[t._v("什么是 IOC")])]),e("li",[e("a",{attrs:{href:"#beanfactory-和-applicationcontext-的区别"}},[t._v("BeanFactory 和 ApplicationContext 的区别")])]),e("li",[e("a",{attrs:{href:"#bean-的作用域"}},[t._v("Bean 的作用域")])]),e("li",[e("a",{attrs:{href:"#bean-的生命周期"}},[t._v("Bean 的生命周期")])]),e("li",[e("a",{attrs:{href:"#如何解决循环依赖问题"}},[t._v("如何解决循环依赖问题")])]),e("li",[e("a",{attrs:{href:"#component-和-bean-的区别"}},[t._v("@Component 和 @Bean 的区别")])]),e("li",[e("a",{attrs:{href:"#autowired-和-resource-的区别"}},[t._v("@Autowired 和 @Resource 的区别")])])])]),e("li",[e("a",{attrs:{href:"#spring-aop"}},[t._v("Spring AOP")]),e("ul",[e("li",[e("a",{attrs:{href:"#什么是-aop"}},[t._v("什么是 AOP")])]),e("li",[e("a",{attrs:{href:"#aop-通知的类型"}},[t._v("AOP 通知的类型")])]),e("li",[e("a",{attrs:{href:"#aop-的实现方式"}},[t._v("AOP 的实现方式")])])])]),e("li",[e("a",{attrs:{href:"#spring-dao"}},[t._v("Spring DAO")]),e("ul",[e("li",[e("a",{attrs:{href:"#spring-事务的管理方式"}},[t._v("Spring 事务的管理方式")])]),e("li",[e("a",{attrs:{href:"#spring-事务的隔离级别"}},[t._v("Spring 事务的隔离级别")])]),e("li",[e("a",{attrs:{href:"#spring-事务的传播行为"}},[t._v("Spring 事务的传播行为")])])])]),e("li",[e("a",{attrs:{href:"#spring-mvc"}},[t._v("Spring MVC")]),e("ul",[e("li",[e("a",{attrs:{href:"#什么是-springmvc"}},[t._v("什么是 SpringMVC")])]),e("li",[e("a",{attrs:{href:"#springmvc-请求处理流程"}},[t._v("SpringMVC 请求处理流程")])])])]),e("li",[e("a",{attrs:{href:"#springboot"}},[t._v("SpringBoot")]),e("ul",[e("li",[e("a",{attrs:{href:"#过滤器和拦截器的区别"}},[t._v("过滤器和拦截器的区别")])]),e("li",[e("a",{attrs:{href:"#自动配置原理"}},[t._v("自动配置原理")])])])])])]),e("p"),t._v(" "),e("h2",{attrs:{id:"spring-core"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-core"}},[t._v("#")]),t._v(" Spring Core")]),t._v(" "),e("h3",{attrs:{id:"什么是-spring-框架"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是-spring-框架"}},[t._v("#")]),t._v(" 什么是 Spring 框架")]),t._v(" "),e("p",[t._v("Spring 是一个开源的 Java 应用程序开发框架，可以帮助开发者更快地构建企业级应用程序、更加灵活地组织和管理应用程序中的对象和组件。")]),t._v(" "),e("p",[t._v("Spring 框架的 "),e("strong",[t._v("核心思想是依赖注入（DI）和面向切面编程（AOP）")]),t._v("。依赖注入（DI）可以帮助我们更好地组织和管理应用程序中的对象，使得应用程序更加松耦合，易于扩展和维护。面向切面编程（AOP）可以帮助我们更好地管理应用程序中的横切关注点，使得应用程序更加模块化和可维护。")]),t._v(" "),e("p",[t._v("除了核心容器以外，Spring 框架还提供了很多其他的组件和框架，比如 "),e("strong",[t._v("Spring MVC")]),t._v(" 可以帮助我们更加轻松地开发 Web 应用程序，"),e("strong",[t._v("Spring JDBC")]),t._v(" 可以帮助我们更加轻松地访问和操作数据库，"),e("strong",[t._v("Spring ORM")]),t._v(" 可以帮助我们更加轻松地使用 ORM 框架等等。")]),t._v(" "),e("h3",{attrs:{id:"spring-中的设计模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-中的设计模式"}},[t._v("#")]),t._v(" Spring 中的设计模式")]),t._v(" "),e("div",{staticClass:"tag-group"},[e("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("美团到店")])],1),e("p",[e("strong",[t._v("模式1")]),t._v("："),e("RouterLink",{attrs:{to:"/design-pattern/rb9rsc/#_2-1-单例-singleton"}},[e("strong",[t._v("单例模式")])]),t._v(" 确保一个类 "),e("strong",[t._v("只有一个实例")]),t._v("，并提供一个 "),e("strong",[t._v("全局访问点")]),t._v(" 以供其他对象使用。")],1),t._v(" "),e("ul",[e("li",[t._v("Bean 的默认作用域：定义一个 Bean 时，默认情况下会将其作用域设置为单例（Singleton）。这意味着 Spring 容器只会创建一个该 Bean 的实例，并在需要时重用它。这样可以确保在每个 IOC 容器中只有一个实例，避免了重复创建和销毁的开销。")]),t._v(" "),e("li",[t._v("应用程序上下文：Spring 应用程序上下文（ApplicationContext）本身就是一个单例对象。它在应用程序启动时创建，并且在整个应用程序的生命周期中保持活动状态。通过应用程序上下文，可以方便地访问和管理各个 Bean 实例。")]),t._v(" "),e("li",[t._v("配置管理：Spring 框架提供了一种方便的方式来管理配置信息，例如数据库连接信息、日志配置等。这些配置信息通常作为单例对象存在，可以通过 Spring 的依赖注入来访问和使用。")])]),t._v(" "),e("p",[e("strong",[t._v("模式2")]),t._v("："),e("RouterLink",{attrs:{to:"/design-pattern/rb9rsc/#_2-2-工厂方法-factory-method"}},[e("strong",[t._v("工厂方法模式")])]),t._v(" 定义了一个创建对象的接口，但是由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。")],1),t._v(" "),e("ul",[e("li",[t._v("Bean 工厂（BeanFactory）：在 Spring 中，Bean 工厂是一种用于创建和管理对象的机制。通过配置文件或注解，Spring 容器可以根据需要动态地创建和初始化对象，并将其提供给应用程序使用。Bean 工厂负责对象的实例化和依赖注入，实现了工厂方法模式。")]),t._v(" "),e("li",[t._v("ApplicationContext 接口：ApplicationContext 是 Spring 框架中的核心接口之一，它扩展了 BeanFactory 接口，并提供了更多的功能。ApplicationContext 接口是一个应用程序级别的工厂，可以根据配置信息创建和管理对象。")])]),t._v(" "),e("p",[e("strong",[t._v("模式3")]),t._v("："),e("RouterLink",{attrs:{to:"/design-pattern/srpftk/#_3-1-适配器-adapter"}},[e("strong",[t._v("适配器模式")])]),t._v(" 允许将一个类的接口转换为客户端期望的另一个接口。")],1),t._v(" "),e("ul",[e("li",[t._v("MVC 框架中的处理器适配器（Handler Adapter）：Spring MVC 框架中，处理器适配器用于将处理器（Controller）适配到处理器执行链中。不同类型的处理器具有不同的接口，而处理器适配器负责将不同类型的处理器转换为统一的处理器接口，以便于 Spring MVC 框架能够正确调用处理器并进行处理。")]),t._v(" "),e("li",[t._v("AOP 中的通知适配器（Advice Adapter）：Spring 的 AOP 功能通过通知（Advice）来实现横切关注点的插入。不同类型的通知（如前置通知、后置通知、异常通知等）具有不同的接口，而通知适配器负责将不同类型的通知转换为统一的通知接口，以便于 AOP 框架能够正确调用通知并执行相应的操作。")]),t._v(" "),e("li",[t._v("数据库访问中的适配器：Spring 的 JDBC 模块中，使用了适配器模式来适配不同的数据库驱动程序。Spring 提供了多种数据库驱动程序的适配器，使得开发人员可以使用统一的 API（如 JdbcTemplate）来进行数据库访问，而不必关心具体的数据库驱动程序。")])]),t._v(" "),e("p",[e("strong",[t._v("模式4")]),t._v("："),e("RouterLink",{attrs:{to:"/design-pattern/srpftk/#_3-5-代理-proxy"}},[e("strong",[t._v("代理模式")])]),t._v(" 通过创建一个代理对象来控制对其他对象的访问。代理对象充当原始对象的中间人，客户端与代理对象进行交互，并由代理对象将请求传递给原始对象，以实现间接访问和控制。")],1),t._v(" "),e("ul",[e("li",[t._v("AOP（面向切面编程）：Spring 的 AOP 功能使用了代理模式。通过定义切面和切点，Spring 能够在应用程序的关键位置插入横切关注点（如日志记录、事务管理等）。在 AOP 中，代理对象在调用目标对象的方法之前或之后执行额外的逻辑。")])]),t._v(" "),e("p",[t._v("将请求的发送者和接收者解耦，并允许多个对象都有机会处理该请求。责任链模式形成一个链式结构，每个处理者都有机会处理请求，直到请求被处理或者到达链的末尾。")]),t._v(" "),e("p",[e("strong",[t._v("模式5")]),t._v("："),e("RouterLink",{attrs:{to:"/design-pattern/rk905n/#_4-1-策略-strategy"}},[e("strong",[t._v("策略模式")])]),t._v(" 定义了一系列可互换的算法或策略，并使得这些算法或策略可以独立于客户端而变化。")],1),t._v(" "),e("ul",[e("li",[t._v("Bean 的加载策略：Spring 的核心容器使用策略模式来定义 Bean 的加载策略。通过配置文件或注解，可以选择不同的加载策略来实例化和管理 Bean。例如，可以使用基于 XML 的配置策略、基于注解的配置策略或基于 Java 代码的配置策略。")]),t._v(" "),e("li",[t._v("事务管理中的事务策略：Spring 的事务管理功能允许开发人员根据需求选择不同的事务策略。可以通过配置文件或编程方式指定事务策略。")])]),t._v(" "),e("p",[e("strong",[t._v("模式6")]),t._v("："),e("RouterLink",{attrs:{to:"/design-pattern/rk905n/#_4-2-模板方法-template-method"}},[e("strong",[t._v("模板方法模式")])]),t._v(" 定义了一个算法的框架，将具体的实现步骤延迟到子类中。模板方法通过将算法的骨架固定下来，但允许子类在特定步骤上进行自定义实现，以满足不同的需求。")],1),t._v(" "),e("ul",[e("li",[t._v("数据库操作：Spring 中 JdbcTemplate、HibernateTemplate 等以 Template 结尾的对数据库操作的类是典型的模板方法模式的应用。一般情况下，我们使用继承的方式来实现模板模式，但是 Spring 并没有使用这种方式，而是使用回调与模板方法模式配合，既达到了代码复用的效果，又增加了灵活性。")])]),t._v(" "),e("p",[e("strong",[t._v("模式7")]),t._v("："),e("RouterLink",{attrs:{to:"/design-pattern/rk905n/#_4-3-观察者-observer"}},[e("strong",[t._v("观察者模式")])]),t._v(" 定义了一种一对多的依赖关系，使得当一个对象的状态发生变化时，所有依赖于它的对象都会得到通知并自动更新。")],1),t._v(" "),e("ul",[e("li",[t._v("观察者模式的应用主要通过 ApplicationEvent 和 ApplicationListener 来实现：ApplicationEvent 是 Spring 框架中的事件类，它是观察者模式中的被观察者（主题）。ApplicationListener 是用于监听 ApplicationEvent 的接口，它是观察者模式中的观察者。可以通过 ApplicationEventPublisher 接口发布事件，让所有相关的监听器进行响应。")])]),t._v(" "),e("p",[e("strong",[t._v("模式8")]),t._v("："),e("RouterLink",{attrs:{to:"/design-pattern/rk905n/#_4-4-责任链-chain-of-responsibility"}},[e("strong",[t._v("责任链模式")])]),t._v(" 将请求的发送者和接收者解耦，并允许多个对象都有机会处理该请求。责任链模式形成一个链式结构，每个处理者都有机会处理请求，直到请求被处理或者到达链的末尾。")],1),t._v(" "),e("ul",[e("li",[t._v("拦截器链：拦截器（Interceptor）用于对请求进行预处理和后处理。Spring MVC 框架提供了拦截器链的功能，每个拦截器都有机会处理请求，并决定是否继续传递给下一个拦截器。")]),t._v(" "),e("li",[t._v("过滤器链：过滤器（Filter）用于对 HTTP 请求进行处理和过滤。过滤器链由多个过滤器组成，每个过滤器都可以对请求进行处理并传递给下一个过滤器。")]),t._v(" "),e("li",[t._v("异常处理链：异常处理器（Exception Handler）被组织成链式结构，每个处理器有机会处理特定类型的异常。如果一个处理器无法处理，将异常往下传递，直到找到能够处理该异常的处理器或到达链尾。")])]),t._v(" "),e("h3",{attrs:{id:"什么是-ioc"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是-ioc"}},[t._v("#")]),t._v(" 什么是 IOC")]),t._v(" "),e("p",[e("strong",[t._v("控制反转（Inversion of Control，IoC）")]),t._v(" 是一种设计模式，它 "),e("strong",[t._v("将对象之间的依赖关系的管理交给框架来处理")]),t._v("，从而实现对象之间的松耦合和可维护性。")]),t._v(" "),e("ul",[e("li",[t._v("控制 ：指的是对象创建（实例化、管理）的权力")]),t._v(" "),e("li",[t._v("反转 ：控制权交给外部环境（Spring 框架、IoC 容器）")])]),t._v(" "),e("p",[t._v("传统的编程模式中，对象之间的依赖关系是由对象自己来管理的，当对象 A 需要对象 B 的协助完成某个功能时，对象 A 会主动创建对象 B，然后在适当的时候调用对象 B 的方法。这种方式会导致对象之间的依赖关系紧密耦合，使得代码难以维护和扩展。")]),t._v(" "),e("h3",{attrs:{id:"beanfactory-和-applicationcontext-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#beanfactory-和-applicationcontext-的区别"}},[t._v("#")]),t._v(" BeanFactory 和 ApplicationContext 的区别")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("容器层次结构")]),t._v("：BeanFactory 是 IOC 容器最基本的形式，是一个工厂接口，提供了高级的配置机制，允许在运行时通过编程方式来管理 bean 的创建、配置和依赖注入。"),e("strong",[t._v("ApplicationContext 是 BeanFactory 的子接口，提供了更多的功能和特性")]),t._v("。ApplicationContext 在 BeanFactory 基础上添加了更多的企业级特性，如国际化支持、事件发布、资源加载、AOP 等，更适合在实际应用中使用。")]),t._v(" "),e("li",[e("strong",[t._v("加载时机")]),t._v("："),e("strong",[t._v("BeanFactory 是延迟加载的")]),t._v("，在容器启动时不会实例化所有的 bean，只有当需要获取某个 bean 时才会对其进行实例化和初始化。"),e("strong",[t._v("ApplicationContext 在容器启动时就会加载所有的 bean")]),t._v("。这意味着在使用 ApplicationContext 时，启动时间可能会更长，但获取 bean 时的响应速度会更快。")]),t._v(" "),e("li",[e("strong",[t._v("自动装配")]),t._v("：BeanFactory 支持自动装配（autowiring），但其自动装配的功能相对较弱，只支持 byName 和 byType 两种方式。ApplicationContext 在 BeanFactory 的基础上提供了更强大的自动装配功能，包括 byName、byType、constructor 等多种方式，并支持注解驱动的自动装配。")])]),t._v(" "),e("h3",{attrs:{id:"bean-的作用域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bean-的作用域"}},[t._v("#")]),t._v(" Bean 的作用域")]),t._v(" "),e("p",[t._v("Bean 的作用域（Scope）指定了在容器中创建的 Bean 实例的生命周期，不同的作用域决定了 Bean 实例的可见范围和生命周期长度。Spring 框架支持以下五种 Bean 作用域：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("singleton（单例）")]),t._v("：在整个应用中只创建一个 Bean 实例，并在容器启动时就创建，以后每次请求都返回同一个实例。")]),t._v(" "),e("li",[e("strong",[t._v("prototype（原型）")]),t._v("：每次获取 Bean 时都会创建一个新的实例，适用于一些状态不可共享的 Bean。")]),t._v(" "),e("li",[e("strong",[t._v("request（请求）")]),t._v("：在每个 HTTP 请求中创建一个 Bean 实例，该 Bean 实例仅在当前的请求中有效，对于不同的请求，会创建不同的 Bean 实例。")]),t._v(" "),e("li",[e("strong",[t._v("session（会话）")]),t._v("：在每个 HTTP Session 中创建一个 Bean 实例，该 Bean 实例仅在当前 Session 中有效，对于不同的 Session，会创建不同的 Bean 实例。")]),t._v(" "),e("li",[e("strong",[t._v("global-session（全局会话）")]),t._v("：在基于 portlet 的 web 应用中使用，该作用域仅在基于 portlet 的 web 应用中有效，一个 portlet 的多个请求共享一个 Bean 实例。")])]),t._v(" "),e("p",[t._v("其中，单例是默认的作用域，当没有指定作用域时，Spring 会默认将 Bean 作为单例。除了全局会话作用域，其他四种作用域都只适用于 Web 应用。在 Spring 中，可以通过在 Bean 定义中指定 scope 属性来指定 Bean 的作用域，如下所示：")]),t._v(" "),e("div",{staticClass:"language-xml extra-class"},[e("pre",{pre:!0,attrs:{class:"language-xml"}},[e("code",[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token tag"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("bean")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("id")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("exampleBean"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("class")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("com.example.ExampleBean"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),t._v(" "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[t._v("scope")]),e("span",{pre:!0,attrs:{class:"token attr-value"}},[e("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')]),t._v("prototype"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v('"')])]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("/>")])]),t._v("\n")])])]),e("p",[t._v("在注解中，可以使用@Scope注解来指定Bean的作用域，如下所示：")]),t._v(" "),e("div",{staticClass:"language-java extra-class"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Component")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Scope")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"prototype"')]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ExampleBean")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("需要注意的是，在单例作用域中，如果 Bean 有状态（stateful），则需要考虑线程安全问题，否则可能会导致多线程并发访问出现问题。因此，对于有状态的 Bean，建议使用原型作用域。")]),t._v(" "),e("h3",{attrs:{id:"bean-的生命周期"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bean-的生命周期"}},[t._v("#")]),t._v(" Bean 的生命周期")]),t._v(" "),e("div",{staticClass:"tag-group"},[e("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("快手商业化")])],1),e("p",[e("img",{attrs:{src:r(452),alt:"image-20230311182754331.drawio"}})]),t._v(" "),e("h3",{attrs:{id:"如何解决循环依赖问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何解决循环依赖问题"}},[t._v("#")]),t._v(" 如何解决循环依赖问题")]),t._v(" "),e("div",{staticClass:"tag-group"},[e("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("快手")])],1),e("p",[e("img",{attrs:{src:r(453),alt:"image-20230312015337928"}})]),t._v(" "),e("h3",{attrs:{id:"component-和-bean-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#component-和-bean-的区别"}},[t._v("#")]),t._v(" @Component 和 @Bean 的区别")]),t._v(" "),e("p",[t._v("@Component 及其派生注解（@Controller、@Service、@Repository 等）是用于在类上添加，表示将该类作为组件扫描到 Spring 容器中。而 @Bean 注解通常是在配置类的方法上使用，用于手动创建并注册一个特定的 bean。")]),t._v(" "),e("p",[t._v("@Component 等注解通过组件扫描的方式，Spring 容器会自动发现这些被注解标记的类并将其创建为 bean。而 @Bean 注解是手动在配置类（@Configuration）中定义方法，在方法内部通过编程逻辑来创建一个 bean 实例，然后将其注册到容器中。")]),t._v(" "),e("h3",{attrs:{id:"autowired-和-resource-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#autowired-和-resource-的区别"}},[t._v("#")]),t._v(" @Autowired 和 @Resource 的区别")]),t._v(" "),e("div",{staticClass:"tag-group"},[e("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("字节")])],1),e("p",[t._v("@Autowired 是 Spring 框架提供的注解；@Resource 是 Java EE 规范提供的注解。")]),t._v(" "),e("p",[t._v("@Autowired 优先通过类型（byType）来匹配依赖。如果存在多个匹配的 bean 类型，Spring 会抛出异常或需要额外的配置（通过 @Qualifier 注解显式指定名称）来解决歧义。")]),t._v(" "),e("p",[t._v("@Resource 优先通过名称（byName）来匹配依赖。@Resource 有两个比较重要的属性：name、type。如果仅指定 name 属性则注入方式为 byName，如果仅指定 type 属性则注入方式为 byType，如果同时指定 name 和 type 属性则注入方式为 byType + byName（同时满足）。")]),t._v(" "),e("h2",{attrs:{id:"spring-aop"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-aop"}},[t._v("#")]),t._v(" Spring AOP")]),t._v(" "),e("h3",{attrs:{id:"什么是-aop"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是-aop"}},[t._v("#")]),t._v(" 什么是 AOP")]),t._v(" "),e("p",[e("strong",[t._v("面向切面编程（Aspect-Oriented Programming, AOP）")]),t._v(" 是一种编程思想，它通过将应用程序分解成多个切面，来实现对应用程序进行横向切割的目的，从而实现代码的复用和系统的解耦。")]),t._v(" "),e("p",[t._v("AOP 的核心思想是 "),e("strong",[t._v("将与业务逻辑无关的代码（如日志、事务、异常处理）从业务逻辑代码中分离出来")]),t._v("，形成独立的模块，以便于复用和维护。")]),t._v(" "),e("p",[t._v("AOP 的一些概念如下：")]),t._v(" "),e("ul",[e("li",[t._v("切面（Aspect）：模块化的横切关注点，它通过对某个点进行拦截，来实现对目标对象的增强。")]),t._v(" "),e("li",[t._v("通知（Advice）：通知是切面在连接点上执行的操作，例如在方法调用前、方法调用后、方法返回时或方法抛出异常时执行的操作。")]),t._v(" "),e("li",[t._v("连接点（Join Point）：在应用程序执行过程中能够插入切面的点，例如方法调用或异常处理等。")]),t._v(" "),e("li",[t._v("切入点（Pointcut）：一组连接点的集合，它定义了在哪些连接点处应用切面。")]),t._v(" "),e("li",[t._v("织入（Weaving）：织入是将切面应用到目标对象并创建新的代理对象的过程。织入可以在编译时、类加载时或运行时进行。")])]),t._v(" "),e("p",[t._v("通过 AOP 的概念，我们可以将应用程序按照不同的横向关注点进行切割，并将与业务逻辑无关的代码分离出来，从而提高应用程序的可维护性和可扩展性。常见的 AOP 框架有 Spring AOP 和 AspectJ。")]),t._v(" "),e("h3",{attrs:{id:"aop-通知的类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aop-通知的类型"}},[t._v("#")]),t._v(" AOP 通知的类型")]),t._v(" "),e("p",[t._v("在 AOP（Aspect-Oriented Programming）中，通知（Advice）是在切面（Aspect）中定义的一些方法，用于在连接点（Join Point）处执行特定的操作。通知可以分为以下几种类型：")]),t._v(" "),e("ul",[e("li",[t._v("前置通知（Before Advice）：在连接点之前执行的通知，例如在方法调用前记录日志或开启事务等。")]),t._v(" "),e("li",[t._v("后置通知（After Advice）：在连接点之后执行的通知，例如在方法调用后记录日志或提交事务等。")]),t._v(" "),e("li",[t._v("返回通知（After Returning Advice）：在方法返回结果之后执行的通知，例如在方法调用后记录返回结果或关闭资源等。")]),t._v(" "),e("li",[t._v("异常通知（After Throwing Advice）：在方法抛出异常时执行的通知，例如在方法调用抛出异常时记录异常信息或回滚事务等。")]),t._v(" "),e("li",[t._v("环绕通知（Around Advice）：在方法调用之前和之后都可以执行的通知，它可以自由控制方法调用前后的逻辑，例如在方法调用前记录日志或在方法调用后提交事务等。")])]),t._v(" "),e("p",[t._v("以上通知类型都是用于在连接点处执行特定的操作，并通过切面将这些通知应用到目标对象中。")]),t._v(" "),e("h3",{attrs:{id:"aop-的实现方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#aop-的实现方式"}},[t._v("#")]),t._v(" AOP 的实现方式")]),t._v(" "),e("p",[e("strong",[t._v("基于静态代理的 AOP 实现")]),t._v("：为每一个目标对象编写一个对应的切面类，并在切面类中实现通知方法。在使用目标对象时，需要将目标对象和切面类进行组合，生成一个新的代理对象，该代理对象拦截目标对象的方法调用，并在方法调用前后执行通知。")]),t._v(" "),e("p",[e("strong",[t._v("基于动态代理的 AOP 实现")]),t._v("：定义一个切面类和切面方法，然后使用 JDK 动态代理或者 CGLIB 动态代理生成一个代理对象。在代理对象中，所有方法调用都会被拦截，并在方法调用前后执行通知。")]),t._v(" "),e("p",[t._v("在使用 JDK 动态代理时，需要实现 InvocationHandler 接口，并重写 invoke 方法。在 invoke 方法中，需要对目标对象进行方法调用，并在方法调用前后执行通知。使用 Proxy 类的 newProxyInstance 方法，将目标对象和 InvocationHandler 对象进行组合，生成代理对象。")]),t._v(" "),e("p",[t._v("在使用 CGLIB 动态代理时，需要使用 Enhancer 类和 MethodInterceptor 接口。Enhancer 类用于生成代理对象，MethodInterceptor 接口用于在代理对象的方法调用前后执行通知。在使用 Enhancer 类时，需要设置目标对象和 MethodInterceptor 对象，并调用 create 方法生成代理对象。")]),t._v(" "),e("h2",{attrs:{id:"spring-dao"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-dao"}},[t._v("#")]),t._v(" Spring DAO")]),t._v(" "),e("h3",{attrs:{id:"spring-事务的管理方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-事务的管理方式"}},[t._v("#")]),t._v(" Spring 事务的管理方式")]),t._v(" "),e("p",[e("strong",[t._v("编程式事务管理")]),t._v("：在代码中显式地编写事务管理代码来实现事务管理。Spring 提供 TransactionTemplate 和 TransactionManager 两个核心类来支持编程式事务管理。")]),t._v(" "),e("p",[t._v("在使用 TransactionTemplate 时，我们需要先获取一个 TransactionTemplate 实例，然后使用 execute() 方法执行需要事务管理的代码块。")]),t._v(" "),e("p",[e("strong",[t._v("声明式事务管理")]),t._v("：在 Spring 配置文件中声明事务管理器和事务属性来实现事务管理。Spring 使用 AOP 技术将事务管理器和事务属性织入到目标方法中，从而实现事务管理。")]),t._v(" "),e("p",[t._v("在使用声明式事务管理时，我们需要先配置一个事务管理器和一些事务属性，例如事务的传播行为、隔离级别、超时时间等，然后在需要事务管理的方法上添加 @Transactional 注解即可。")]),t._v(" "),e("h3",{attrs:{id:"spring-事务的隔离级别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-事务的隔离级别"}},[t._v("#")]),t._v(" Spring 事务的隔离级别")]),t._v(" "),e("p",[t._v("在 Spring 事务中，隔离级别用来描述并发事务之间的关系，它规定了一个事务对于数据的读取能够具有的隔离程度。Spring 框架中提供了五个隔离级别：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("默认隔离级别（ISOLATION_DEFAULT）")]),t._v("：由底层的数据库驱动决定隔离级别，通常为数据库的默认隔离级别。")]),t._v(" "),e("li",[e("strong",[t._v("读未提交（ISOLATION_READ_UNCOMMITTED）")]),t._v("：该隔离级别表示一个事务可以读取另一个事务修改但未提交的数据。该级别可能产生脏读、不可重复读和幻读的问题。")]),t._v(" "),e("li",[e("strong",[t._v("读已提交（ISOLATION_READ_COMMITTED）")]),t._v("：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以避免脏读问题，但不可重复读和幻读问题仍然可能发生。")]),t._v(" "),e("li",[e("strong",[t._v("可重复读（ISOLATION_REPEATABLE_READ）")]),t._v("：该隔离级别表示一个事务在执行过程中多次读取同一数据集时，其结果是一致的。该级别可以避免脏读和不可重复读问题，但仍然可能发生幻读问题。")]),t._v(" "),e("li",[e("strong",[t._v("可串行化（ISOLATION_SERIALIZABLE）")]),t._v("：该隔离级别表示一个事务在执行过程中对于数据的修改会进行排队，即串行化执行，从而避免了脏读、不可重复读和幻读问题，但也降低了并发性能。")])]),t._v(" "),e("p",[t._v("不同的隔离级别在解决并发事务问题时采用了不同的策略，为了保证应用程序数据的一致性和正确性，在选择隔离级别时需要根据具体的业务场景和需求进行选择。")]),t._v(" "),e("h3",{attrs:{id:"spring-事务的传播行为"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-事务的传播行为"}},[t._v("#")]),t._v(" Spring 事务的传播行为")]),t._v(" "),e("p",[t._v("在 Spring 事务中，事务的传播行为指的是在一个事务方法调用另一个事务方法时，另一个事务方法如何处理事务的行为。Spring 事务支持以下七种传播行为：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("REQUIRED")]),t._v("（默认值）：如果当前存在事务，则在该事务中执行；否则，创建一个新的事务并在其中执行方法。")]),t._v(" "),e("li",[e("strong",[t._v("SUPPORTS")]),t._v("：支持当前事务，如果当前没有事务，就以非事务方式执行。")]),t._v(" "),e("li",[e("strong",[t._v("MANDATORY")]),t._v("：强制执行当前事务，如果当前没有事务，则抛出异常。")]),t._v(" "),e("li",[e("strong",[t._v("REQUIRES_NEW")]),t._v("：创建新的事务，并在新事务中执行方法，如果当前存在事务，则暂停当前事务。")]),t._v(" "),e("li",[e("strong",[t._v("NOT_SUPPORTED")]),t._v("：以非事务方式执行方法，如果当前存在事务，则暂停当前事务。")]),t._v(" "),e("li",[e("strong",[t._v("NEVER")]),t._v("：以非事务方式执行，如果当前存在事务，则抛出异常。")]),t._v(" "),e("li",[e("strong",[t._v("NESTED")]),t._v("：如果当前存在事务，则在嵌套事务中执行；否则，创建一个新的事务并在其中执行方法。")])]),t._v(" "),e("p",[t._v("嵌套事务是当前事务的子事务，并与当前事务共享一部分数据源连接。如果嵌套事务失败，则仅回滚嵌套事务，而不会回滚当前事务。如果当前事务失败，则嵌套事务和当前事务都将被回滚。")]),t._v(" "),e("p",[t._v("这些传播行为可以使用 @Transactional 注解中的 propagation 属性来指定。")]),t._v(" "),e("h2",{attrs:{id:"spring-mvc"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#spring-mvc"}},[t._v("#")]),t._v(" Spring MVC")]),t._v(" "),e("h3",{attrs:{id:"什么是-springmvc"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是-springmvc"}},[t._v("#")]),t._v(" 什么是 SpringMVC")]),t._v(" "),e("p",[t._v("Spring MVC 是基于 MVC（Model-View-Controller）设计模式实现的一种 Web 应用程序开发框架。它是 Spring Framework 的一个重要组成部分，提供了一个灵活、松耦合、可扩展、高效的 Web 开发框架。M 代表模型（Model），即数据模型；V 代表视图（View），即用户界面；C 代表控制器（Controller）。")]),t._v(" "),e("h3",{attrs:{id:"springmvc-请求处理流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#springmvc-请求处理流程"}},[t._v("#")]),t._v(" SpringMVC 请求处理流程")]),t._v(" "),e("div",{staticClass:"tag-group"},[e("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("阿里飞猪")])],1),e("p",[e("img",{attrs:{src:r(646),alt:"image-20230704203108152.drawio"}})]),t._v(" "),e("ul",[e("li",[t._v("客户端发送请求，请求被 "),e("strong",[t._v("前端控制器 DispatcherServlet")]),t._v(" 截获。")]),t._v(" "),e("li",[t._v("DispatcherServlet 查询 "),e("strong",[t._v("处理器映射 HandlerMapping")]),t._v("，根据请求 URI 找到对应的处理器 Controller。")]),t._v(" "),e("li",[t._v("HandlerAdapter 将请求发送给 "),e("strong",[t._v("处理器 Controller")]),t._v(" 进行处理，Controller 根据请求参数处理业务逻辑，调用业务逻辑层的 Service。")]),t._v(" "),e("li",[t._v("Service 处理业务逻辑，返回数据给 Controller。")]),t._v(" "),e("li",[t._v("Controller 将数据封装为 "),e("strong",[t._v("ModelAndView 对象")]),t._v("，其中 Model 表示数据模型，View 表示视图名称。")]),t._v(" "),e("li",[t._v("DispatcherServlet 查询 "),e("strong",[t._v("视图解析器 ViewResolver")]),t._v("，根据视图名称找到对应的 "),e("strong",[t._v("视图 View")]),t._v("。")]),t._v(" "),e("li",[t._v("View 渲染模型数据，将视图返回给 DispatcherServlet。")]),t._v(" "),e("li",[t._v("DispatcherServlet 将视图发送给客户端，完成请求响应。")])]),t._v(" "),e("h2",{attrs:{id:"springboot"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#springboot"}},[t._v("#")]),t._v(" SpringBoot")]),t._v(" "),e("h3",{attrs:{id:"过滤器和拦截器的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#过滤器和拦截器的区别"}},[t._v("#")]),t._v(" 过滤器和拦截器的区别")]),t._v(" "),e("div",{staticClass:"tag-group"},[e("el-tag",{attrs:{type:"primary",effect:"plain",size:"medium"}},[t._v("快手本地生活")])],1),e("ul",[e("li",[e("strong",[t._v("出身不同")]),t._v("：过滤器来自于 Servlet，而拦截器来自于 Spring 框架。")]),t._v(" "),e("li",[e("strong",[t._v("触发时机不同")]),t._v("：请求进入容器 → 进入过滤器 → 进入 Servlet → 进入拦截器 → 执行控制器。")]),t._v(" "),e("li",[e("strong",[t._v("实现不同")]),t._v("：过滤器是基于方法回调实现的， 而拦截器是基于动态代理（底层是反射）实现的。")]),t._v(" "),e("li",[e("strong",[t._v("支持的项目类型不同")]),t._v("：过滤器依赖 Servlet 容器，只支持 Web 项目；拦截器是 Spring 中的组件，因此拦截器既支持 Web 项目中，还支持 Application 或 Swing 程序。")]),t._v(" "),e("li",[e("strong",[t._v("使用场景不同")]),t._v("：过滤器通常用来实现通用功能，比如敏感词过滤、字符集编码设置、响应数据压缩等。拦截器更接近业务系统，通常用来实现项目中的业务判断的，比如登录判断、权限判断、日志记录等。")])]),t._v(" "),e("h3",{attrs:{id:"自动配置原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#自动配置原理"}},[t._v("#")]),t._v(" 自动配置原理")]),t._v(" "),e("p",[t._v("https://blog.csdn.net/weixin_42556307/article/details/108405009")])])}),[],!1,null,null,null);a.default=n.exports},452:function(t,a,r){t.exports=r.p+"assets/img/image-20230311182754331.drawio.11823663.png"},453:function(t,a,r){t.exports=r.p+"assets/img/image-20230312015337928.56ac0c54.png"},646:function(t,a,r){t.exports=r.p+"assets/img/image-20230704203108152.drawio.654a3230.png"}}]);