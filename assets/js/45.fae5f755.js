(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{1059:function(a,v,s){"use strict";s.r(v);var _=s(14),t=Object(_.a)({},(function(){var a=this,v=a.$createElement,_=a._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[_("h1",{attrs:{id:"第2章-类加载机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第2章-类加载机制"}},[a._v("#")]),a._v(" 第2章 类加载机制")]),a._v(" "),_("h2",{attrs:{id:"_2-1-类的生命周期"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-类的生命周期"}},[a._v("#")]),a._v(" 2.1 类的生命周期")]),a._v(" "),_("p",[a._v("类的完整生命周期如下：")]),a._v(" "),_("p",[_("img",{attrs:{src:s(738),alt:"image-20230127172503474"}})]),a._v(" "),_("p",[a._v("JVM 加载 Class 文件主要三步："),_("strong",[a._v("加载 → 连接 → 初始化")]),a._v("。")]),a._v(" "),_("p",[a._v("连接过程又可分为三步："),_("strong",[a._v("验证 → 准备 → 解析")]),a._v("。")]),a._v(" "),_("h3",{attrs:{id:"加载"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#加载"}},[a._v("#")]),a._v(" 加载")]),a._v(" "),_("p",[a._v("加载是类加载过程的第一个阶段。在加载阶段，虚拟机需要完成以下三件事情：")]),a._v(" "),_("ul",[_("li",[a._v("通过一个 "),_("strong",[a._v("类的全限定名")]),a._v(" 来获取其定义的 "),_("strong",[a._v("二进制字节流")]),a._v("。")]),a._v(" "),_("li",[a._v("将这个字节流所代表的 "),_("strong",[a._v("静态存储结构")]),a._v(" 转化为 "),_("strong",[a._v("方法区")]),a._v(" 的 "),_("strong",[a._v("运行时数据结构")]),a._v("。")]),a._v(" "),_("li",[a._v("在 Java "),_("strong",[a._v("堆")]),a._v(" 中生成一个代表这个类的 "),_("strong",[a._v("java.lang.Class 对象")]),a._v("，作为对方法区中这些数据的访问入口。")])]),a._v(" "),_("p",[_("img",{attrs:{src:s(739),alt:"image-20230127172052943"}})]),a._v(" "),_("p",[a._v("加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在 Java 堆中同时创建一个 java.lang.Class 类的对象，这样便可以通过该对象访问方法区中的这些数据。")]),a._v(" "),_("h3",{attrs:{id:"连接"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#连接"}},[a._v("#")]),a._v(" 连接")]),a._v(" "),_("div",{staticClass:"subtitle"},[_("p",[a._v("验证：确保被加载的类的正确性")])]),_("p",[a._v("验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成 4 个阶段的检验动作：")]),a._v(" "),_("ul",[_("li",[a._v("文件格式验证：验证字节流是否符合 Class 文件格式的规范；例如：是否以 0xCAFEBABE 开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。")]),a._v(" "),_("li",[a._v("元数据验证：对字节码描述的信息进行语义分析（注意：对比 javac 编译阶段的语义分析），以保证其描述的信息符合 Java 语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object 之外。")]),a._v(" "),_("li",[a._v("字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。")]),a._v(" "),_("li",[a._v("符号引用验证：确保解析动作能正确执行。")])]),a._v(" "),_("div",{staticClass:"subtitle"},[_("p",[a._v("准备：为类的静态变量分配内存，并将其初始化为默认值")])]),_("p",[a._v("准备阶段是正式为类变量（static）分配内存并设置类变量初始值的阶段，这些内存将在方法区中分配。对于该阶段，需要注意：")]),a._v(" "),_("ul",[_("li",[a._v("这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。")]),a._v(" "),_("li",[a._v("这里设置的初始值通常情况下是数据类型默认的零值（如 0、0L、null、false 等），而不是被在 Java 代码中被显式地赋予的值。因为这时候尚未开始执行任何 Java 方法，而 put static 指令是在程序编译后，存放于类构造器 <clinit>() 方法之中的。")])]),a._v(" "),_("p",[a._v("还需要注意：")]),a._v(" "),_("ul",[_("li",[a._v("对于基本数据类型的类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值。而对于局部变量，在使用前必须显式地为其赋值，否则编译时不通过。")]),a._v(" "),_("li",[a._v("对于同时被 static 和 final 修饰的常量，必须在声明时显式地为其赋值，否则编译时不通过；而只被 final 修饰的常量，必须在声明时或类初始化时显式地为其赋值。")]),a._v(" "),_("li",[a._v("如果类字段的字段属性表中存在 ConstantValue 属性，即同时被 static 和 final 修饰，那么在准备阶段变量 value 就会被初始化为 ConstValue 属性所指定的值。")]),a._v(" "),_("li",[a._v("对于引用数据类型来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即 null。")]),a._v(" "),_("li",[a._v("如果数组初始化时没有对数组中的元素赋值，其中的元素将根据对应的数据类型而被赋予默认的零值。")])]),a._v(" "),_("div",{staticClass:"subtitle"},[_("p",[a._v("解析：把类中的符号引用转换为直接引用")])]),_("p",[a._v("解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行。")]),a._v(" "),_("p",[a._v("符号引用是 "),_("strong",[a._v("一组符号")]),a._v(" 来描述目标，可以是任何字面量。例如 CONSTANT_Class_info、CONSTANT_Field_info、CONSTANT_Method_info 等。")]),a._v(" "),_("p",[a._v("直接引用是 "),_("strong",[a._v("直接指向目标的指针、相对偏移量或一个间接定位到目标")]),a._v(" 的句柄。")]),a._v(" "),_("h3",{attrs:{id:"初始化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#初始化"}},[a._v("#")]),a._v(" 初始化")]),a._v(" "),_("p",[a._v("初始化是为类的静态变量赋予正确的初始值。JVM 负责对类进行初始化，主要对类变量进行初始化。")]),a._v(" "),_("p",[a._v("在 Java 中对类变量进行初始值设定有两种方式：")]),a._v(" "),_("ul",[_("li",[a._v("声明类变量时指定初始值")]),a._v(" "),_("li",[a._v("使用静态代码块为类变量指定初始值")])]),a._v(" "),_("p",[a._v("JVM 初始化步骤：")]),a._v(" "),_("ul",[_("li",[a._v("假如这个类还没有被加载和连接，则程序先加载并连接该类")]),a._v(" "),_("li",[a._v("假如该类的直接父类还没有被初始化，则先初始化其直接父类")]),a._v(" "),_("li",[a._v("假如类中有初始化语句，则系统依次执行这些初始化语句")])]),a._v(" "),_("p",[a._v("类初始化时机：只有当对类的主动使用时才会导致类的初始化。包括以下六种：")]),a._v(" "),_("ul",[_("li",[a._v("创建类的实例")]),a._v(" "),_("li",[a._v("访问某个类或接口的静态变量，或者对该静态变量赋值")]),a._v(" "),_("li",[a._v("调用类的静态方法")]),a._v(" "),_("li",[a._v("反射（如 "),_("code",[a._v('Class.forName("com.pdai.jvm.Test")')]),a._v("）")]),a._v(" "),_("li",[a._v("初始化某个类的子类，则其父类也会被初始化")]),a._v(" "),_("li",[a._v("Java 虚拟机启动时被标明为启动类的类，直接使用 java.exe 命令来运行某个主类")])]),a._v(" "),_("h3",{attrs:{id:"使用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#使用"}},[a._v("#")]),a._v(" 使用")]),a._v(" "),_("p",[a._v("对象的实例化过程如下：")]),a._v(" "),_("p",[_("img",{attrs:{src:s(740),alt:"image-20230128224444177"}})]),a._v(" "),_("h3",{attrs:{id:"卸载"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#卸载"}},[a._v("#")]),a._v(" 卸载")]),a._v(" "),_("p",[a._v("卸载类即该类的 Class 对象被 GC。")]),a._v(" "),_("p",[a._v("卸载类需要满足 3 个要求：")]),a._v(" "),_("ul",[_("li",[a._v("该类的所有的实例对象都已被 GC，即堆不存在该类的实例对象。")]),a._v(" "),_("li",[a._v("该类没有在其他任何地方被引用")]),a._v(" "),_("li",[a._v("该类的类加载器的实例已被 GC")])]),a._v(" "),_("h2",{attrs:{id:"_2-2-类加载机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-类加载机制"}},[a._v("#")]),a._v(" 2.2 类加载机制")]),a._v(" "),_("h3",{attrs:{id:"类加载器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类加载器"}},[a._v("#")]),a._v(" 类加载器")]),a._v(" "),_("p",[a._v("Java 虚拟机设计者有意把类加载阶段中的 “"),_("strong",[a._v("通过一个类的全限定名来获取描述该类的二进制字节流")]),a._v("” 这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为 “类加载器”（Class Loader）。")]),a._v(" "),_("p",[_("strong",[a._v("对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在 Java 虚拟机中的唯一性")]),a._v("，每一个类加载器，都拥有一个独立的类名称空间。通俗理解：比较两个类是否 “相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个 Java 虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。")]),a._v(" "),_("h3",{attrs:{id:"类加载器的层次"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类加载器的层次"}},[a._v("#")]),a._v(" 类加载器的层次")]),a._v(" "),_("p",[_("img",{attrs:{src:s(741),alt:"image-20230127235100152"}})]),a._v(" "),_("p",[a._v("站在 Java 开发人员的角度来看，类加载器可以大致划分为以下三类 ：")]),a._v(" "),_("p",[_("strong",[a._v("启动类加载器（Bootstrap ClassLoader）")]),a._v("：负责加载存放在 "),_("code",[a._v("JDK\\jre\\lib")]),a._v("（JDK 代表 JDK 的安装目录，下同）下，或被 "),_("code",[a._v("-Xbootclasspath")]),a._v(" 参数指定的路径中的，并且能被虚拟机识别的类库（如 rt.jar，"),_("code",[a._v("java.*")]),a._v(" 开头的类均被 Bootstrap ClassLoader 加载）。启动类加载器是无法被 Java 程序直接引用的。")]),a._v(" "),_("p",[_("strong",[a._v("扩展类加载器（Extension ClassLoader）")]),a._v("：该加载器由 sun.misc.Launcher$ExtClassLoader 实现，它负责加载 "),_("code",[a._v("JDK\\jre\\lib\\ext")]),a._v(" 目录中，或由 "),_("code",[a._v("java.ext.dirs")]),a._v(" 系统变量指定的路径中的类库（如 "),_("code",[a._v("javax.*")]),a._v(" 开头的类），开发者可以直接使用扩展类加载器。")]),a._v(" "),_("p",[_("strong",[a._v("应用程序类加载器（Application ClassLoader）")]),a._v("：该类加载器由 sun.misc.Launcher$AppClassLoader 来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。")]),a._v(" "),_("p",[a._v("应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。")]),a._v(" "),_("h3",{attrs:{id:"类的加载"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类的加载"}},[a._v("#")]),a._v(" 类的加载")]),a._v(" "),_("p",[a._v("类加载有三种方式：")]),a._v(" "),_("ul",[_("li",[a._v("命令行启动应用时候由 JVM 初始化加载")]),a._v(" "),_("li",[a._v("通过 Class.forName() 方法动态加载")]),a._v(" "),_("li",[a._v("通过 ClassLoader.loadClass() 方法动态加载")])]),a._v(" "),_("p",[a._v("Class.forName() 和 ClassLoader.loadClass() 的区别：")]),a._v(" "),_("ul",[_("li",[a._v("Class.forName()：将类的 .class 文件加载到 JVM 中之外，还会对类进行解释，执行类中的 static 块；")]),a._v(" "),_("li",[a._v("ClassLoader.loadClass()：只将 .class 文件加载到 JVM 中，不会执行 static 块中的内容，只有在 newInstance 才会去执行 static 块。")]),a._v(" "),_("li",[a._v("Class.forName(name, initialize, loader)：带参函数可以控制是否加载 static 块。")])]),a._v(" "),_("h3",{attrs:{id:"jvm-类加载机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm-类加载机制"}},[a._v("#")]),a._v(" JVM 类加载机制")]),a._v(" "),_("div",{staticClass:"subtitle"},[_("p",[a._v("全盘负责")])]),_("p",[a._v("当一个类加载器负责加载某个 Class 时，该 Class 依赖和引用的其他 Class 也将由该类加载器负责载入，除非显式使用另外一个类加载器来载入。")]),a._v(" "),_("div",{staticClass:"subtitle"},[_("p",[a._v("父类委托")])]),_("p",[a._v("先让父类加载器试图加载该类，在父类加载器无法加载该类时才尝试从自己的类路径中加载。")]),a._v(" "),_("div",{staticClass:"subtitle"},[_("p",[a._v("缓存机制")])]),_("p",[a._v("保证加载过的 Class 都会被缓存，当程序中需要使用某个 Class 时，类加载器先从缓存区寻找该 Class，只有缓存区不存在时，系统才会读取该类对应的二进制数据，并将其转换成 Class 对象，存入缓存区。这就是为什么修改了 Class 后，必须重启 JVM，程序的修改才会生效。")]),a._v(" "),_("div",{staticClass:"subtitle"},[_("p",[a._v("双亲委派机制")])]),_("p",[a._v("如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法加载时，子加载器才会尝试自己去加载该类。")]),a._v(" "),_("p",[a._v("使用双亲委派模型来组织类加载器之间的关系，"),_("strong",[a._v("一个显而易见的好处就是 Java 中的类随着它的类加载器一起具备了一种带有优先级的层次关系")]),a._v("。例如类 java.lang.Object，存放在 rt.jar 之中，无论哪个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此 Object 类 "),_("strong",[a._v("在程序的各种类加载器环境中都能够保证是同一个类")]),a._v("。反之，如果没有使用双亲委派模型，都由各个类加载器自行去加载，如果用户自己也编写了一个名为 java.lang.Object 的类，并放在程序的 ClassPath 中，那系统中就会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无从保证，应用程序将会变得一片混乱。")])])}),[],!1,null,null,null);v.default=t.exports},738:function(a,v,s){a.exports=s.p+"assets/img/image-20230127172503474.b1c424a2.png"},739:function(a,v,s){a.exports=s.p+"assets/img/image-20230127172052943.fa2f37af.png"},740:function(a,v,s){a.exports=s.p+"assets/img/image-20230128224444177.1978784f.png"},741:function(a,v,s){a.exports=s.p+"assets/img/image-20230127235100152.4f5f2d79.png"}}]);