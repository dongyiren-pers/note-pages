(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{1116:function(t,s,a){"use strict";a.r(s);var e=a(14),n=Object(e.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"第1章-redis-数据结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#第1章-redis-数据结构"}},[t._v("#")]),t._v(" 第1章 Redis 数据结构")]),t._v(" "),e("p",[t._v("具体的分为 5 种基本类型和 3 种特殊类型。")]),t._v(" "),e("h2",{attrs:{id:"_1-1-基本类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-基本类型"}},[t._v("#")]),t._v(" 1.1 基本类型")]),t._v(" "),e("p",[e("img",{attrs:{src:a(933),alt:"image-20230203232917827"}})]),t._v(" "),e("style",[t._v("\n                        .table-column-x-x-container-xj12dhcu table th:nth-of-type(1) {\n                            width: 20%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-xj12dhcu table th:nth-of-type(2) {\n                            width: 30%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-xj12dhcu table th:nth-of-type(3) {\n                            width: 50%;\n                            word-wrap: break-word;\n                        }\n                    ")]),e("div",{staticClass:"table-column-x-x-container-xj12dhcu"},[e("table",[e("thead",[e("tr",[e("th",[t._v("结构类型")]),t._v(" "),e("th",[t._v("结构存储的值")]),t._v(" "),e("th",[t._v("结构的读写能力")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("String 字符串")]),t._v(" "),e("td",[t._v("字符串、整数或浮点数")]),t._v(" "),e("td",[t._v("对整个字符串或字符串的一部分进行操作；"),e("br"),t._v("对整数或浮点数进行自增或自减操作。")])]),t._v(" "),e("tr",[e("td",[t._v("List 列表")]),t._v(" "),e("td",[t._v("一个链表，链表上的每个节点都包含一个字符串")]),t._v(" "),e("td",[t._v("对链表的两端进行 push 和 pop 操作，读取单个或多个元素；根据值查找或删除元素。")])]),t._v(" "),e("tr",[e("td",[t._v("Set 集合")]),t._v(" "),e("td",[t._v("存储字符串的无序集合")]),t._v(" "),e("td",[t._v("方法有判断元素是否存在、添加、获取、删除，以及计算交集、并集、差集等。")])]),t._v(" "),e("tr",[e("td",[t._v("ZSet 有序集合")]),t._v(" "),e("td",[t._v("存储字符串与浮点数键值对")]),t._v(" "),e("td",[t._v("字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定。"),e("br"),t._v("方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素。")])]),t._v(" "),e("tr",[e("td",[t._v("Hash 散列")]),t._v(" "),e("td",[t._v("存储键值对的无序散列表")]),t._v(" "),e("td",[t._v("方法有添加、获取、删除单个元素。")])])])])]),e("h3",{attrs:{id:"string-字符串"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#string-字符串"}},[t._v("#")]),t._v(" String 字符串")]),t._v(" "),e("div",{staticClass:"subtitle"},[e("p",[t._v("图例")])]),e("div",{staticStyle:{"text-align":"center"}},[e("img",{staticStyle:{zoom:"50%"},attrs:{src:a(934),alt:"image-20230203233215389"}})]),e("div",{staticClass:"subtitle"},[e("p",[t._v("命令")])]),e("style",[t._v("\n                        .table-column-x-x-container-s14pzgnb table th:nth-of-type(1) {\n                            width: 20%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-s14pzgnb table th:nth-of-type(2) {\n                            width: 50%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-s14pzgnb table th:nth-of-type(3) {\n                            width: 30%;\n                            word-wrap: break-word;\n                        }\n                    ")]),e("div",{staticClass:"table-column-x-x-container-s14pzgnb"},[e("table",[e("thead",[e("tr",[e("th",[t._v("命令")]),t._v(" "),e("th",[t._v("简述")]),t._v(" "),e("th",[t._v("使用")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("GET")]),t._v(" "),e("td",[t._v("获取存储在给定键中的值")]),t._v(" "),e("td",[t._v("GET key")])]),t._v(" "),e("tr",[e("td",[t._v("SET")]),t._v(" "),e("td",[t._v("设置存储在给定键中的值")]),t._v(" "),e("td",[t._v("SET key value")])]),t._v(" "),e("tr",[e("td",[t._v("DEL")]),t._v(" "),e("td",[t._v("删除存储在给定键中的值")]),t._v(" "),e("td",[t._v("DEL key")])]),t._v(" "),e("tr",[e("td",[t._v("INCR")]),t._v(" "),e("td",[t._v("将键存储的值加1")]),t._v(" "),e("td",[t._v("INCR key")])]),t._v(" "),e("tr",[e("td",[t._v("DECR")]),t._v(" "),e("td",[t._v("将键存储的值减1")]),t._v(" "),e("td",[t._v("DECR key")])]),t._v(" "),e("tr",[e("td",[t._v("INCRBY")]),t._v(" "),e("td",[t._v("将键存储的值加上整数")]),t._v(" "),e("td",[t._v("INCRBY key amount")])]),t._v(" "),e("tr",[e("td",[t._v("DECRBY")]),t._v(" "),e("td",[t._v("将键存储的值减去整数")]),t._v(" "),e("td",[t._v("DECRBY key amount")])])])])]),e("div",{staticClass:"subtitle"},[e("p",[t._v("场景")])]),e("ul",[e("li",[e("strong",[t._v("缓存功能")]),t._v("：字符串最经典的使用场景，Redis 作为缓存层，MySQL 作为储存层，绝大部分请求数据都是 Redis 中获取，Redis 具有支撑高并发特性，因此缓存通常能起到加速读写和降低后端压力的作用。")]),t._v(" "),e("li",[e("strong",[t._v("库存控制")]),t._v("：利用 INCR、DECR 等原子操作命令进行库存控制，常见用于分布式锁时进行库存预扣。")]),t._v(" "),e("li",[e("strong",[t._v("简单的计数器")]),t._v("：利用 INCR、DECR 等原子操作命令可以实现正计数和倒计时操作，在并发下可以保证线程安全。如网站的点赞数或者视频播放数等计数的实现。")]),t._v(" "),e("li",[e("strong",[t._v("接口限流")]),t._v("：利用 SET 结合 EXPIRE 过期时间限制某个用户在某段时间访问接口的次数。")]),t._v(" "),e("li",[e("strong",[t._v("共享 Session")]),t._v("：出于负载均衡考虑，分布式服务会将用户信息的访问均衡到不同服务器上，可以使用 Redis 将用户 session 集中管理。")])]),t._v(" "),e("div",{staticClass:"subtitle"},[e("p",[t._v("编码：Int、Embstr、Raw")])]),e("p",[t._v("Redis 的 String 类型可以有三种不同的编码方式：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("Int 编码")]),t._v("：当字符串 "),e("strong",[t._v("可以被解释为整数")]),t._v(" 时，Redis 使用 int 编码。在 int 编码下，字符串被转换为一个整数，并使用固定的 "),e("strong",[t._v("8 字节")]),t._v("（long）存储。")]),t._v(" "),e("li",[e("strong",[t._v("Embstr 编码")]),t._v("：当字符串的长度小于等于某一阈值时，Redis 会使用 embstr 编码。在 embstr 编码下，"),e("strong",[t._v("SDS 结构体会被嵌入到 Redis 对象（redisObject）中")]),t._v("，避免了额外的内存分配，提高了效率。")]),t._v(" "),e("li",[e("strong",[t._v("Raw 编码")]),t._v("：当字符串长度大于某一阈值，或者字符串虽然长度小于等于 39 字节但超出了 embstr 的限制条件时，Redis 会使用 raw 编码。在 raw 编码下，Redis 使用额外的内存空间存储 SDS 的结构信息。Redis 对象中的指针直接指向 SDS。")])]),t._v(" "),e("h3",{attrs:{id:"list-列表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#list-列表"}},[t._v("#")]),t._v(" List 列表")]),t._v(" "),e("div",{staticClass:"subtitle"},[e("p",[t._v("图例")])]),e("div",{staticStyle:{"text-align":"center"}},[e("img",{staticStyle:{zoom:"50%"},attrs:{src:a(935),alt:"image-20230204002934022"}})]),e("div",{staticClass:"subtitle"},[e("p",[t._v("命令")])]),e("style",[t._v("\n                        .table-column-x-x-container-lsn1mtoo table th:nth-of-type(1) {\n                            width: 20%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-lsn1mtoo table th:nth-of-type(2) {\n                            width: 50%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-lsn1mtoo table th:nth-of-type(3) {\n                            width: 30%;\n                            word-wrap: break-word;\n                        }\n                    ")]),e("div",{staticClass:"table-column-x-x-container-lsn1mtoo"},[e("table",[e("thead",[e("tr",[e("th",[t._v("命令")]),t._v(" "),e("th",[t._v("简述")]),t._v(" "),e("th",[t._v("使用")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("RPUSH")]),t._v(" "),e("td",[t._v("将给定值推入到列表右端")]),t._v(" "),e("td",[t._v("RPUSH key value")])]),t._v(" "),e("tr",[e("td",[t._v("LPUSH")]),t._v(" "),e("td",[t._v("将给定值推入到列表左端")]),t._v(" "),e("td",[t._v("LPUSH key value")])]),t._v(" "),e("tr",[e("td",[t._v("RPOP")]),t._v(" "),e("td",[t._v("从列表的右端弹出一个值，并返回被弹出的值")]),t._v(" "),e("td",[t._v("RPOP key")])]),t._v(" "),e("tr",[e("td",[t._v("LPOP")]),t._v(" "),e("td",[t._v("从列表的左端弹出一个值，并返回被弹出的值")]),t._v(" "),e("td",[t._v("LPOP key")])]),t._v(" "),e("tr",[e("td",[t._v("LINDEX")]),t._v(" "),e("td",[t._v("通过索引获取列表中的元素。"),e("br"),t._v("负数下标表示倒数，以 -1 表示列表的最后一个元素， -X 表示列表的倒数第 X 个元素。")]),t._v(" "),e("td",[t._v("LINDEX key index")])]),t._v(" "),e("tr",[e("td",[t._v("LRANGE")]),t._v(" "),e("td",[t._v("获取列表在给定范围上的所有值")]),t._v(" "),e("td",[t._v("LRANGE key 0 -1")])])])])]),e("div",{staticClass:"subtitle"},[e("p",[t._v("场景")])]),e("ul",[e("li",[e("strong",[t._v("评论列表")]),t._v("：朋友圈评论，按顺序显示评论的朋友。")]),t._v(" "),e("li",[e("strong",[t._v("关注列表")]),t._v("：显示有哪些关注人。")]),t._v(" "),e("li",[e("strong",[t._v("文章列表")]),t._v("：显示文章列表，如果要按照日期等顺序显示，则需要先排好序之后再放入 Redis 中。")]),t._v(" "),e("li",[e("strong",[t._v("消息队列")]),t._v("：Redis 的 LPUSH + BRPOP 命令组合即可实现阻塞队列，生产者客户端是用 LPUSH 从列表左侧插入元素，多个消费者客户端使用 BRPOP 命令阻塞地 “抢” 列表尾部的元素，多个客户端保证了消费的负载均衡和高可用性。")]),t._v(" "),e("li",[e("strong",[t._v("排行榜")]),t._v("：适用于定时计算的排行榜。List 类型的 LRANGE 命令可以分页查看队列中的数据。可将每隔一段时间计算一次的排行榜存储在 List 类型中。")])]),t._v(" "),e("div",{staticClass:"subtitle"},[e("p",[t._v("编码：ZipList、LinkedList、QuickList")])]),e("p",[t._v("Redis 的 List 类型可以有三种不同的编码方式：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("ZipList 编码")]),t._v("：当 List 中的所有元素都是小整数值时，且 List 中元素数量少于 512 个时，Redis 会使用 ZipList 编码。在 ZipList 编码下，List 的底层实现是一个 "),e("strong",[t._v("压缩列表")]),t._v("，它将所有元素连续地存储在一起，节省了指针等额外空间，从而减少了内存占用。")]),t._v(" "),e("li",[e("strong",[t._v("LinkedList 编码")]),t._v("：当 List 中的元素数量超过 512 个时，Redis 会使用 LinkedList 编码。在 LinkedList 编码下，List 的底层实现是一个 "),e("strong",[t._v("双向链表")]),t._v("，每个节点包含一个指向前一个节点和后一个节点的指针，以及一个指向元素的指针。相比于 ZipList 编码，LinkedList 编码可以支持更多的元素，并且可以支持更复杂的操作，如在 List 的任意位置进行插入、删除等操作。")]),t._v(" "),e("li",[e("strong",[t._v("QuickList 编码")]),t._v("：当 List 的元素数量非常多时，Redis 会使用 QuickList 编码。QuickList "),e("strong",[t._v("将一个 List 拆分为多个 ZipList")]),t._v("，每个 ZipList 最多包含 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("msup",[e("mn",[t._v("2")]),e("mn",[t._v("16")])],1),e("mo",[t._v("−")]),e("mn",[t._v("1")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("2^{16} - 1")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.897438em","vertical-align":"-0.08333em"}}),e("span",{staticClass:"mord"},[e("span",{staticClass:"mord"},[t._v("2")]),e("span",{staticClass:"msupsub"},[e("span",{staticClass:"vlist-t"},[e("span",{staticClass:"vlist-r"},[e("span",{staticClass:"vlist",staticStyle:{height:"0.8141079999999999em"}},[e("span",{staticStyle:{top:"-3.063em","margin-right":"0.05em"}},[e("span",{staticClass:"pstrut",staticStyle:{height:"2.7em"}}),e("span",{staticClass:"sizing reset-size6 size3 mtight"},[e("span",{staticClass:"mord mtight"},[e("span",{staticClass:"mord mtight"},[t._v("1")]),e("span",{staticClass:"mord mtight"},[t._v("6")])])])])])])])])]),e("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}}),e("span",{staticClass:"mbin"},[t._v("−")]),e("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.2222222222222222em"}})]),e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.64444em","vertical-align":"0em"}}),e("span",{staticClass:"mord"},[t._v("1")])])])])]),t._v(" 个元素，然后 "),e("strong",[t._v("将这些 ZipList 组成一个双向链表")]),t._v("。QuickList 可以提高 List 在插入、删除、访问等操作时的效率，并且可以支持非常大的 List。")],1)]),t._v(" "),e("h3",{attrs:{id:"set-集合"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#set-集合"}},[t._v("#")]),t._v(" Set 集合")]),t._v(" "),e("p",[t._v("Redis 的 Set 是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。")]),t._v(" "),e("div",{staticClass:"subtitle"},[e("p",[t._v("图例")])]),e("div",{staticStyle:{"text-align":"center"}},[e("img",{staticStyle:{zoom:"50%"},attrs:{src:a(936),alt:"image-20230204003847215"}})]),e("div",{staticClass:"subtitle"},[e("p",[t._v("命令")])]),e("style",[t._v("\n                        .table-column-x-x-container-0jydna8o table th:nth-of-type(1) {\n                            width: 20%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-0jydna8o table th:nth-of-type(2) {\n                            width: 50%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-0jydna8o table th:nth-of-type(3) {\n                            width: 30%;\n                            word-wrap: break-word;\n                        }\n                    ")]),e("div",{staticClass:"table-column-x-x-container-0jydna8o"},[e("table",[e("thead",[e("tr",[e("th",[t._v("命令")]),t._v(" "),e("th",[t._v("简述")]),t._v(" "),e("th",[t._v("使用")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("SADD")]),t._v(" "),e("td",[t._v("向集合添加一个或多个成员")]),t._v(" "),e("td",[t._v("SADD key member")])]),t._v(" "),e("tr",[e("td",[t._v("SREM")]),t._v(" "),e("td",[t._v("移除集合中指定的成员")]),t._v(" "),e("td",[t._v("SREM key member")])]),t._v(" "),e("tr",[e("td",[t._v("SCARD")]),t._v(" "),e("td",[t._v("获取集合的成员数")]),t._v(" "),e("td",[t._v("SCARD key")])]),t._v(" "),e("tr",[e("td",[t._v("SMEMBERS")]),t._v(" "),e("td",[t._v("返回集合中的所有成员")]),t._v(" "),e("td",[t._v("SMEMBERS key")])]),t._v(" "),e("tr",[e("td",[t._v("SISMEMBER")]),t._v(" "),e("td",[t._v("判断 member 元素是否是集合 key 的成员")]),t._v(" "),e("td",[t._v("SISMEMBER key member")])])])])]),e("div",{staticClass:"subtitle"},[e("p",[t._v("场景")])]),e("ul",[e("li",[e("strong",[t._v("共同关注/共同喜好/共同好友")]),t._v("：利用集合的求交集运算，完成共同关注功能。")]),t._v(" "),e("li",[e("strong",[t._v("随机数")]),t._v("：这里可以使用 SPOP/SRANDMEMBER 命令来获取随机数，可以做一个抽奖功能等。")]),t._v(" "),e("li",[e("strong",[t._v("社交需求")]),t._v("：SADD/SINTER 命令可以添加有多少个朋友的共同好友等操作，类似可能认识的人。")])]),t._v(" "),e("div",{staticClass:"subtitle"},[e("p",[t._v("编码：IntSet、HashTable")])]),e("ul",[e("li",[e("strong",[t._v("IntSet")]),t._v("：是一种紧凑和高效的编码方式，它可以存储 "),e("strong",[t._v("整数类型")]),t._v(" 的元素。在 IntSet 中，所有元素都按照 "),e("strong",[t._v("从小到大的顺序")]),t._v(" 排列，并且可以选择存储 int16_t、int32_t 或 int64_t 类型的元素。")]),t._v(" "),e("li",[e("strong",[t._v("HashTable")]),t._v("：是一种键值对存储结构，它可以存储 "),e("strong",[t._v("任意类型")]),t._v(" 的数据。每个元素都是一个键值对，其中键是元素的值，值为 NULL。")])]),t._v(" "),e("p",[t._v("在实际使用中，Redis 会根据具体情况自动选择使用哪种编码方式。当 Set 中只包含整数类型的元素时，Redis 会选择使用 IntSet 编码方式，否则会选择使用 HashTable 编码方式。")]),t._v(" "),e("h3",{attrs:{id:"zset-有序集合"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#zset-有序集合"}},[t._v("#")]),t._v(" ZSet 有序集合")]),t._v(" "),e("div",{staticClass:"subtitle"},[e("p",[t._v("图例")])]),e("div",{staticStyle:{"text-align":"center"}},[e("img",{staticStyle:{zoom:"50%"},attrs:{src:a(937),alt:"image-20230204004748813"}})]),e("div",{staticClass:"subtitle"},[e("p",[t._v("命令")])]),e("style",[t._v("\n                        .table-column-x-x-container-6mkz9qik table th:nth-of-type(1) {\n                            width: 20%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-6mkz9qik table th:nth-of-type(2) {\n                            width: 50%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-6mkz9qik table th:nth-of-type(3) {\n                            width: 30%;\n                            word-wrap: break-word;\n                        }\n                    ")]),e("div",{staticClass:"table-column-x-x-container-6mkz9qik"},[e("table",[e("thead",[e("tr",[e("th",[t._v("命令")]),t._v(" "),e("th",[t._v("简述")]),t._v(" "),e("th",[t._v("使用")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("ZADD")]),t._v(" "),e("td",[t._v("将一个带有给定分值的成员添加到有序集合里面")]),t._v(" "),e("td",[t._v("ZADD zset-key 178 member")])]),t._v(" "),e("tr",[e("td",[t._v("ZRANGE")]),t._v(" "),e("td",[t._v("根据元素在有序集合中所处的位置，从有序集合中获取多个元素")]),t._v(" "),e("td",[t._v("ZRANGE zset-key 0 -1 withccores")])]),t._v(" "),e("tr",[e("td",[t._v("ZREM")]),t._v(" "),e("td",[t._v("如果给定元素成员存在于有序集合中，那么就移除这个元素")]),t._v(" "),e("td",[t._v("ZREM zset-key member")])])])])]),e("div",{staticClass:"subtitle"},[e("p",[t._v("场景")])]),e("ul",[e("li",[e("strong",[t._v("排行榜")]),t._v("：按照 Score 得分获取排行前 100 等比较方便。")]),t._v(" "),e("li",[e("strong",[t._v("有序列表")]),t._v("：最新事件列表、或者文章列表，按照时间作为得分进行排序，取数据时候可以进行分页。")])]),t._v(" "),e("div",{staticClass:"subtitle"},[e("p",[t._v("编码：ZipList、SkipList")])]),e("ul",[e("li",[e("strong",[t._v("ZipList")]),t._v("：数据量较小时，采用 "),e("strong",[t._v("ZipList")]),t._v(" 作为其编码，按 Score 有序。")]),t._v(" "),e("li",[e("strong",[t._v("SkipList")]),t._v("：当键或值长度过大（64 字节）或个数过多（128）时，转为 "),e("strong",[t._v("SkipList + HashTable")]),t._v(" 编码。")])]),t._v(" "),e("h3",{attrs:{id:"hash-散列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hash-散列"}},[t._v("#")]),t._v(" Hash 散列")]),t._v(" "),e("div",{staticClass:"subtitle"},[e("p",[t._v("图例")])]),e("div",{staticStyle:{"text-align":"center"}},[e("img",{staticStyle:{zoom:"50%"},attrs:{src:a(938),alt:"image-20230204004157353"}})]),e("div",{staticClass:"subtitle"},[e("p",[t._v("命令")])]),e("style",[t._v("\n                        .table-column-x-x-container-p57y3737 table th:nth-of-type(1) {\n                            width: 20%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-p57y3737 table th:nth-of-type(2) {\n                            width: 50%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-p57y3737 table th:nth-of-type(3) {\n                            width: 30%;\n                            word-wrap: break-word;\n                        }\n                    ")]),e("div",{staticClass:"table-column-x-x-container-p57y3737"},[e("table",[e("thead",[e("tr",[e("th",[t._v("命令")]),t._v(" "),e("th",[t._v("简述")]),t._v(" "),e("th",[t._v("使用")])])]),t._v(" "),e("tbody",[e("tr",[e("td",[t._v("HSET")]),t._v(" "),e("td",[t._v("添加键值对")]),t._v(" "),e("td",[t._v("HSET hash-key key value")])]),t._v(" "),e("tr",[e("td",[t._v("HGET")]),t._v(" "),e("td",[t._v("获取指定散列键的值")]),t._v(" "),e("td",[t._v("HGET hash-key key")])]),t._v(" "),e("tr",[e("td",[t._v("HGETALL")]),t._v(" "),e("td",[t._v("获取散列中包含的所有键值对")]),t._v(" "),e("td",[t._v("HGETALL hash-key")])]),t._v(" "),e("tr",[e("td",[t._v("HDEL")]),t._v(" "),e("td",[t._v("如果给定键存在于散列中，那么就移除这个键")]),t._v(" "),e("td",[t._v("HDEL hash-key key")])])])])]),e("div",{staticClass:"subtitle"},[e("p",[t._v("场景")])]),e("ul",[e("li",[e("strong",[t._v("电商购物车")]),t._v("：添加购物车、浏览购物车商品、更改购物车商品数量、删除商品、清空商品均可实现。hash-key 为 userId，key 为商品 Id，value 为商品购买数量。")]),t._v(" "),e("li",[e("strong",[t._v("用户资料")]),t._v("：hash-key 为 userId，key 为其余字段（比如用户名），value 为对应字段值")])]),t._v(" "),e("div",{staticClass:"subtitle"},[e("p",[t._v("编码：ZipList、HashTable")])]),e("ul",[e("li",[e("strong",[t._v("ZipList")]),t._v("：数据量较小时，采用 "),e("strong",[t._v("ZipList")]),t._v(" 作为其编码。每个键值对都会被编码为一个连续的字节数组，可以使用简单的指针算术运算来访问它们。")]),t._v(" "),e("li",[e("strong",[t._v("HashTable")]),t._v("：当键或值长度过大（64）或个数过多（512）时，转为 "),e("strong",[t._v("HashTable")]),t._v(" 编码。每个键值对都会被存储在 hashtable 中的一个桶中，每个桶包括一个键和一个值。")])]),t._v(" "),e("h2",{attrs:{id:"_1-2-底层结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-底层结构"}},[t._v("#")]),t._v(" 1.2 底层结构")]),t._v(" "),e("p",[t._v("Redis 有一个顶层的数据结构 "),e("strong",[t._v("RedisObject")]),t._v("，RedisObject 底层对应着具体对象类型和其编码方式。")]),t._v(" "),e("p",[t._v("之所以有 RedisObject 对象，是因为每种不同的数据类型有不同的编码方式和结构，Redis 必须让每个键都带有类型信息，使得程序可以检查键的类型，还需要根据数据类型的不同编码进行 "),e("strong",[t._v("多态")]),t._v(" 处理。")]),t._v(" "),e("blockquote",[e("p",[t._v("例如：SADD 命令只能用于 Set，LPUSH 命令只能用于 List，而 DEL、TTL 又能用于所有键，要正确实现这些命令，就需要为不同类型的键设置不同的处理方式；另外，同一种数据类型可能由不同的数据结构实现，比如 List，底层可能是压缩列表或者双向链表，因此还需要知道数据类型的编码方式。")])]),t._v(" "),e("div",{staticClass:"language-cpp extra-class"},[e("pre",{pre:!0,attrs:{class:"language-cpp"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("typedef")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("redisObject")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 类型，例如 String、List")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("unsigned")]),t._v(" type"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 编码方式，例如 SDS、压缩列表")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("unsigned")]),t._v(" encoding"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("4")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// LRU - 24 位, 记录最后一次访问时间（相对于lru_clock）; 或者 LFU（最少使用的数据：8 位频率，16 位访问时间）")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("unsigned")]),t._v(" lru"),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v("LRU_BITS"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// LRU_BITS: 24")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 引用计数，新创建对象时值为 1，当对该对象进行共享时值 +1，使用完一个对象后值 -1，等于 0 时被GC回收")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" refcount"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 指向底层数据结构实例，具体的实例，由 type 和 encoding 决定")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v("ptr"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" robj"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),e("p",[e("strong",[t._v("当执行一个处理数据类型命令的时候，Redis 执行以下步骤：")])]),t._v(" "),e("ul",[e("li",[t._v("根据给定的 key，在数据库字典中查找和它相对应的 redisObject，如果没找到，就返回 NULL；")]),t._v(" "),e("li",[t._v("检查 redisObject 的 type 属性和执行命令所需的类型是否相符，如果不相符，返回类型错误；")]),t._v(" "),e("li",[t._v("根据 redisObject 的 encoding 属性所指定的编码，选择合适的操作函数来处理底层的数据结构；")]),t._v(" "),e("li",[t._v("返回数据结构的操作结果作为命令的返回值。")])]),t._v(" "),e("p",[t._v("Redis 本身还会预分配一些值对象，比如响应结果 OK、ERROR，还有包括 0 在内，所有小于 REDIS_SHARED_INTEGERS（默认值是10k，[0 - 9999]）的所有整数，共享对象只能被字典或双向链表这类带有指针的数据结果使用。")]),t._v(" "),e("p",[e("img",{attrs:{src:a(449),alt:"image-20230717153319313.drawio"}})]),t._v(" "),e("h3",{attrs:{id:"sds-简单动态字符串"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sds-简单动态字符串"}},[t._v("#")]),t._v(" SDS 简单动态字符串")]),t._v(" "),e("p",[t._v("Redis 的 String 类型底层有两种保存形式，当保存的是 64 位有符号整数时，String 类型会保存为一个 8 字节的 Long 类型整数；当保存的数据包含字符时，String 类型就会用简单动态字符串 SDS。")]),t._v(" "),e("p",[t._v("简单动态字符串 SDS 由三个部分组成：")]),t._v(" "),e("ul",[e("li",[t._v('buf：字节数组，保存实际数据，结束标志位是 "/0"；')]),t._v(" "),e("li",[t._v('len：表示 buf 已用长度，占 4 字节；SDS 不使用 "/0" 来判断字符串是否结束，而是通过 len 来判断；len 同时能防止缓冲区溢出；')]),t._v(" "),e("li",[t._v("alloc：表示 buf 的实际分配长度，一般大于 len；")])]),t._v(" "),e("p",[t._v("len 和 alloc 两个属性，对于修改字符串 SDS 实现了空间预分配和惰性空间释放两种策略：")]),t._v(" "),e("ul",[e("li",[t._v("空间预分配：当字符串进行扩展时，扩展的内存会比实际需要的多，减少连续字符串增长带来的内存频繁分配。")]),t._v(" "),e("li",[t._v("惰性空间释放：当字符串进行缩短时，不会使用内存重新分配的方式来回收多余字节，而只是用 alloc 记录这些字节的数量，等待后续使用。")])]),t._v(" "),e("p",[t._v("RedisObject 包含了 8 个字节的元数据和一个 8 字节指针，指针指向具体的数据类型的实际数据所在。")]),t._v(" "),e("p",[t._v("对于 String 类型的 RedisObject：")]),t._v(" "),e("ul",[e("li",[t._v("当保存的是 Long 类型整数时，RedisObject 中的指针直接就是整数数据，不用额外的指针指向整数；")]),t._v(" "),e("li",[t._v("当保存的是字符串，且字符串对象的长度小于等于某一阈值时，RedisObject 中元数据、指针和 SDS 是一块连续的内存区域（EmbStr 编码），避免内存碎片；")]),t._v(" "),e("li",[t._v("当保存的是字符串，且字符串对象的长度超过某一阈值时，RedisObject 会给 SDS 分配独立的空间，并用指针指向SDS（Raw 编码）。")])]),t._v(" "),e("p",[e("img",{attrs:{src:a(939),alt:"image-20230717165422479"}})]),t._v(" "),e("p",[t._v("当使用 String 类型时，且 value 的类型是 String 时，如果 value 的长度太小，可能会出现元数据的大小比数据本身的大小还大，造成额外的内存开销，如果能替换成 Long 类型，实际存储的大小会大大降低。")]),t._v(" "),e("h3",{attrs:{id:"ziplist-压缩列表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ziplist-压缩列表"}},[t._v("#")]),t._v(" ZipList 压缩列表")]),t._v(" "),e("p",[e("img",{attrs:{src:a(940),alt:"image-20221127003328637"}})]),t._v(" "),e("p",[t._v("本质上是一个数组，数组中每一个元素保存一个数据。")]),t._v(" "),e("div",{staticClass:"subtitle"},[e("p",[t._v("结构")])]),e("p",[t._v("表头有三个字段：")]),t._v(" "),e("ul",[e("li",[e("strong",[t._v("zlbytes")]),t._v("：记录整个压缩列表占用的内存字节数，可算出列表长度；")]),t._v(" "),e("li",[e("strong",[t._v("zltail")]),t._v("：记录最后一个 entry 的偏移量，可算出尾节点到列表起始地址的字节数，快速完成 pop 操作；")]),t._v(" "),e("li",[e("strong",[t._v("zllen")]),t._v("：记录列表中的 entry 个数，只占用 2 bytes，如果压缩列表中 entry 的数目小于 65535 （"),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("msup",[e("mn",[t._v("2")]),e("mn",[t._v("16")])],1)],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("2^{16}")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"0.8141079999999999em","vertical-align":"0em"}}),e("span",{staticClass:"mord"},[e("span",{staticClass:"mord"},[t._v("2")]),e("span",{staticClass:"msupsub"},[e("span",{staticClass:"vlist-t"},[e("span",{staticClass:"vlist-r"},[e("span",{staticClass:"vlist",staticStyle:{height:"0.8141079999999999em"}},[e("span",{staticStyle:{top:"-3.063em","margin-right":"0.05em"}},[e("span",{staticClass:"pstrut",staticStyle:{height:"2.7em"}}),e("span",{staticClass:"sizing reset-size6 size3 mtight"},[e("span",{staticClass:"mord mtight"},[e("span",{staticClass:"mord mtight"},[t._v("1")]),e("span",{staticClass:"mord mtight"},[t._v("6")])])])])])])])])])])])])]),t._v("），该字段存储的就是实际的 entry 数，如果超过或等于该值，则实际数量要遍历 entry 才能得到；")],1)]),t._v(" "),e("p",[t._v("每个节点元素 entry 有四个字段：")]),t._v(" "),e("ul",[e("li",[t._v("previous_entry_length：记录前一个节点的长度；")]),t._v(" "),e("li",[t._v("encoding：记录 content 的数据类型和长度；")]),t._v(" "),e("li",[t._v("content：保存元素的值；")]),t._v(" "),e("li",[t._v("len：表示自身长度。")])]),t._v(" "),e("p",[t._v("表尾有一字段："),e("strong",[t._v("zlend")]),t._v(" 终止字符，用于标记列表末端。")]),t._v(" "),e("div",{staticClass:"subtitle"},[e("p",[t._v("优势")])]),e("p",[t._v("数据类型 List、ZSet、Hash 都有使用到压缩列表。")]),t._v(" "),e("p",[t._v("压缩列表可以存储字符串或整数，存储整数时采用整数的二进制而不是字符串形式存储，能在 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("O")]),e("mo",{attrs:{stretchy:"false"}},[t._v("(")]),e("mn",[t._v("1")]),e("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(1)")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),e("span",{staticClass:"mopen"},[t._v("(")]),e("span",{staticClass:"mord"},[t._v("1")]),e("span",{staticClass:"mclose"},[t._v(")")])])])])]),t._v(" 时间复杂度下完成 list 两端的 push 和 pop 操作。每次操作都需要重新分配压缩列表的内存，因此实际复杂度跟其内存使用量有关。")],1),t._v(" "),e("p",[t._v("压缩列表的优势在于存储结构，普通数组要求数组的每个元素的大小相同，但是当我们需要在每个元素中存储大小不同的字符串时，就会浪费存储空间，压缩列表就是会把每个元素多余的空间进行压缩，让每个元素紧密相连，再为每个元素增加一个长度，用于计算下一个元素在内存中的位置。")]),t._v(" "),e("p",[t._v("另外，在内存的地址查找时，在查找第一个和最后一个的时候有优势，可以利用表头的三个字段查到，是 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("O")]),e("mo",{attrs:{stretchy:"false"}},[t._v("(")]),e("mn",[t._v("1")]),e("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(1)")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),e("span",{staticClass:"mopen"},[t._v("(")]),e("span",{staticClass:"mord"},[t._v("1")]),e("span",{staticClass:"mclose"},[t._v(")")])])])])]),t._v("，但是因为存储紧凑的缘故，查找其他元素只能遍历，是 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("O")]),e("mo",{attrs:{stretchy:"false"}},[t._v("(")]),e("mi",[t._v("n")]),e("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(n)")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),e("span",{staticClass:"mopen"},[t._v("(")]),e("span",{staticClass:"mord mathdefault"},[t._v("n")]),e("span",{staticClass:"mclose"},[t._v(")")])])])])]),t._v("。")],1),t._v(" "),e("p",[t._v("压缩列表数据结构紧凑，节省空间，避免内存碎片，提升内存利用率。线性顺序存储，对 CPU 高速缓存支持友好。对于查找的时间复杂度的优势提升不大。由于压缩列表结构紧凑，新增、更新和删除操作可能会引发连锁更新，此时最坏为"),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("O")]),e("mo",{attrs:{stretchy:"false"}},[t._v("(")]),e("msup",[e("mi",[t._v("n")]),e("mn",[t._v("2")])],1),e("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(n^2)")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"1.064108em","vertical-align":"-0.25em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),e("span",{staticClass:"mopen"},[t._v("(")]),e("span",{staticClass:"mord"},[e("span",{staticClass:"mord mathdefault"},[t._v("n")]),e("span",{staticClass:"msupsub"},[e("span",{staticClass:"vlist-t"},[e("span",{staticClass:"vlist-r"},[e("span",{staticClass:"vlist",staticStyle:{height:"0.8141079999999999em"}},[e("span",{staticStyle:{top:"-3.063em","margin-right":"0.05em"}},[e("span",{staticClass:"pstrut",staticStyle:{height:"2.7em"}}),e("span",{staticClass:"sizing reset-size6 size3 mtight"},[e("span",{staticClass:"mord mtight"},[t._v("2")])])])])])])])]),e("span",{staticClass:"mclose"},[t._v(")")])])])])]),t._v("，但触发概率相对较低，利大于弊。")],1),t._v(" "),e("h3",{attrs:{id:"quicklist-快表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#quicklist-快表"}},[t._v("#")]),t._v(" QuickList 快表")]),t._v(" "),e("p",[t._v("3.2 版本后才添加，之前的版本是双向链表，"),e("strong",[t._v("本质上是一个链表，只是每个节点都是一个压缩列表。")])]),t._v(" "),e("p",[e("img",{attrs:{src:a(941),alt:"image-20230222112448251"}})]),t._v(" "),e("h3",{attrs:{id:"skiplist-跳表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#skiplist-跳表"}},[t._v("#")]),t._v(" SkipList 跳表")]),t._v(" "),e("p",[t._v("本质是为链表增加索引，建立多层索引，查找时从顶层的索引开始逐步往下层找，最终定位到元素，适用于范围查询的场景。查找的时间复杂度为 "),e("eq",[e("span",{staticClass:"katex"},[e("span",{staticClass:"katex-mathml"},[e("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[e("semantics",[e("mrow",[e("mi",[t._v("O")]),e("mo",{attrs:{stretchy:"false"}},[t._v("(")]),e("mi",[t._v("log")]),e("mo",[t._v("⁡")]),e("mi",[t._v("N")]),e("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),e("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(\\log{N})")])],1)],1)],1),e("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[e("span",{staticClass:"base"},[e("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),e("span",{staticClass:"mopen"},[t._v("(")]),e("span",{staticClass:"mop"},[t._v("lo"),e("span",{staticStyle:{"margin-right":"0.01389em"}},[t._v("g")])]),e("span",{staticClass:"mspace",staticStyle:{"margin-right":"0.16666666666666666em"}}),e("span",{staticClass:"mord"},[e("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.10903em"}},[t._v("N")])]),e("span",{staticClass:"mclose"},[t._v(")")])])])])]),t._v("。")],1),t._v(" "),e("p",[t._v("跳跃表的性能堪比红黑树，而且实现起来比红黑树简单很多。理解跳跃表之之前先来看看下面这个链表。")]),t._v(" "),e("p",[e("img",{attrs:{src:a(942),alt:"image-20230217212051593"}})]),t._v(" "),e("p",[t._v("假如要查找值为 13 的节点，对于上面的单向链表，需要从前往后遍历节点，要进行 10 次查找，性能是非常差的。如果我把这个链表像这样处理一下呢？")]),t._v(" "),e("p",[e("img",{attrs:{src:a(943),alt:"image-20230217212426068"}})]),t._v(" "),e("p",[t._v("把第一层链表中的元素，每隔 2 个元素就向上提取一个元素，形成第二层的链表，如果我查找元素的时候先从最上面的层级找 13 ，当找到 18 的时候大于 13，就退回 10，往下一层找，然后就找到 13 了。")]),t._v(" "),e("p",[t._v("如果再往上抽取一层呢？")]),t._v(" "),e("p",[e("img",{attrs:{src:a(944),alt:"image-20230217212538996"}})]),t._v(" "),e("p",[t._v("其实这种数据结构就是 “跳跃表” 的存储结构了。")]),t._v(" "),e("div",{staticClass:"subtitle"},[e("p",[t._v("ZSet 底层实现")])]),e("p",[t._v("Set 底层使用到了 ZipList 压缩列表和 “跳跃表” 两种存储结构，在 Redis 配置文件中有如下两个配置：")]),t._v(" "),e("ul",[e("li",[t._v("zset-max-ziplist-entries 128：ZSet 采用压缩列表时，元素个数最大值。默认值为 128。")]),t._v(" "),e("li",[t._v("zset-max-ziplist-value 64：ZSet 采用压缩列表时，每个元素的字符串长度最大值。默认值为 64。")])]),t._v(" "),e("h3",{attrs:{id:"dict-哈希表"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dict-哈希表"}},[t._v("#")]),t._v(" Dict 哈希表")]),t._v(" "),e("p",[e("strong",[t._v("Redis 的哈希表使用拉链法解决哈希冲突。")])]),t._v(" "),e("div",{staticClass:"anchor",attrs:{id:"rehash-触发条件"}},[t._v("rehash 触发条件")]),e("p",[t._v("当 Redis 生成 RDB 和 AOF 重写时，哈希表不会进行 rehash。")]),t._v(" "),e("p",[t._v("装载因子：哈希表中所有 entry 的个数除以哈希表的哈希桶个数。")]),t._v(" "),e("ul",[e("li",[t._v("当装载因子 >= 1，且哈希表被允许 rehash，即此时没有进行 RDB 和 AOF 重写")]),t._v(" "),e("li",[t._v("当装载因子 >= 5，因为此时数据量已远远大于哈希桶的个数了，此时会立马进行 rehash")])]),t._v(" "),e("div",{staticClass:"anchor",attrs:{id:"rehash-过程"}},[t._v("rehash 过程")]),e("ul",[e("li",[t._v("默认使用哈希表 1，此时哈希表 2 还没有被分配空间；")]),t._v(" "),e("li",[t._v("当数据增多至需要 rehash 时，为哈希表 2 分配空间，大小会比哈希表 1 大，比如 "),e("strong",[t._v("大两倍")]),t._v("；")]),t._v(" "),e("li",[t._v("把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；")]),t._v(" "),e("li",[t._v("释放哈希表 1 的空间，此时哈希表 1 的空间被回收，原来的哈希表 2 变成哈希表 1。")])]),t._v(" "),e("div",{staticClass:"anchor",attrs:{id:"渐进式-rehash"}},[t._v("渐进式 rehash")]),e("p",[t._v("解决大量数据在哈希表 1 和 2 之间拷贝，会导致 Redis 线程阻塞的问题（因为单线程)。")]),t._v(" "),e("ul",[e("li",[t._v("拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺便将该索引位置上的所有 entries 拷贝到哈希表 2 中；")]),t._v(" "),e("li",[t._v("等待处理下一个请求时，再顺带拷贝哈希表 1 中该索引下一个索引位置的 entries 到哈希表2中；")])]),t._v(" "),e("blockquote",[e("p",[t._v("通过这两种方式，将一次性的大量拷贝分散到每次请求和等待间隙中。")])]),t._v(" "),e("ul",[e("li",[t._v("此外 Redis 本身也有一个 "),e("strong",[t._v("定时任务")]),t._v(" 在执行 rehash，发生在空闲时间")])]),t._v(" "),e("p",[t._v("渐进式 rehash 过程中，如果有新的键值对存进来，Redis 会把该键值对放到哈希表 2 中，确保哈希表 1 里的键值对只会减少；如果是有查询进来，则会先查询哈希表 1，再查询哈希表 2。")]),t._v(" "),e("div",{staticClass:"anchor",attrs:{id:"hash-底层的两种实现"}},[t._v("Hash 底层的两种实现")]),e("p",[t._v("对于 Hash 数据类型，底层有 "),e("strong",[t._v("压缩列表")]),t._v(" 和 "),e("strong",[t._v("哈希表")]),t._v(" 两种实现，当底层使用压缩列表时，存储的时候是以 key、value 的顺序存储的，新增的键值对保存在表尾；使用压缩列表时，底层无法利用 index 查找，只能遍历查找。")]),t._v(" "),e("p",[t._v("当 Hash 集合中写入的元素个数超过了 hash-max-ziplist-entries，或者写入的单个元素大小超过了 hash-max-ziplist-value，Redis 就会自动把 Hash 类型的实现结构由压缩列表转为哈希表，且之后不可逆。")]),t._v(" "),e("h2",{attrs:{id:"_1-3-特殊类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-特殊类型"}},[t._v("#")]),t._v(" 1.3 特殊类型")]),t._v(" "),e("h3",{attrs:{id:"hyperloglog-基数统计"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hyperloglog-基数统计"}},[t._v("#")]),t._v(" HyperLogLog 基数统计")]),t._v(" "),e("p",[t._v("Redis 实现的 HyperLogLog 数据结构可以帮助我们在使用 "),e("strong",[t._v("极少内存")]),t._v(" 估计大规模数据集的基数，从而在某些场景下避免存储大量的实际元素数据。")]),t._v(" "),e("p",[t._v("以下是一个使用 HyperLogLog 的示例：")]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 添加元素到HyperLogLog")]),t._v("\nPFADD hll_set "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"element1"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"element2"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"element3"')]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("integer"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 估计基数")]),t._v("\nPFCOUNT hll_set\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("integer"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 合并两个HyperLogLog")]),t._v("\nPFADD hll_set2 "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"element3"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"element4"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"element5"')]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("integer"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n\nPFMERGE merged_hll hll_set hll_set2\nOK\n\nPFCOUNT merged_hll\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("integer"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v("\n")])])]),e("p",[t._v("虽然 HyperLogLog 在节省内存方面非常高效，但它是一种概率性数据结构，估计结果可能会 "),e("strong",[t._v("存在一定的误差")]),t._v("。因此，在一些对精确基数计数要求较高的情况下，可能需要考虑其他方法或数据结构。")]),t._v(" "),e("h3",{attrs:{id:"bitmap-位图"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bitmap-位图"}},[t._v("#")]),t._v(" Bitmap 位图")]),t._v(" "),e("p",[t._v("在 Redis 中，Bitmap（位图）是一种特殊的数据结构，用于存储和操作位级别的数据。它是由一系列位（0 或 1）组成的序列，每个位可以表示某种状态、标记或计数。Redis 使用 "),e("strong",[t._v("字符串")]),t._v(" 类型来实现位图，其中每个字符表示一个位。")]),t._v(" "),e("div",{staticClass:"anchor",attrs:{id:"场景"}},[t._v("场景")]),e("ul",[e("li",[e("strong",[t._v("统计计数（Counting）：")]),t._v(" 你可以使用 Bitmap 来进行统计操作，如用户的签到情况。每个位可以表示一天，被设置为 1 表示用户在该天签到，0 表示未签到。通过位操作，你可以快速计算用户的签到总数、连续签到的天数等信息。")]),t._v(" "),e("li",[e("strong",[t._v("布隆过滤器（Bloom Filter）：")]),t._v(" 布隆过滤器是一种用于快速判断元素是否可能存在于集合中的数据结构。Redis 中的 Bitmap 可以用来实现布隆过滤器，其中每个位表示某个元素的存在与否，尽管会存在一定的误判率。")]),t._v(" "),e("li",[e("strong",[t._v("在线状态跟踪：")]),t._v(" Bitmap 也可以用于跟踪在线用户。每个用户可以使用一个位来表示其在线状态，可以定期更新该位，从而快速了解哪些用户当前在线。")]),t._v(" "),e("li",[e("strong",[t._v("位操作：")]),t._v(" Redis 提供了许多位操作命令，如设置位、清除位、计算交集、并集等，可以用于在 Bitmap 上执行各种位级别的操作。")])]),t._v(" "),e("div",{staticClass:"anchor",attrs:{id:"示例"}},[t._v("示例")]),e("p",[t._v("以下是一个使用 Bitmap 的示例：")]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 假设用户ID为 123，签到日期为 2023-08-01 到 2023-08-10")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 用户ID")]),t._v("\nSET user:123 "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Alice"')]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 设置用户123在2023-08-01到2023-08-10期间的签到情况")]),t._v("\nSETBIT user:123:sign_in "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 2023-08-01 签到")]),t._v("\nSETBIT user:123:sign_in "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 2023-08-04 签到")]),t._v("\nSETBIT user:123:sign_in "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 2023-08-06 签到")]),t._v("\nSETBIT user:123:sign_in "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("8")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 2023-08-09 签到")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 获取用户123在2023-08-01到2023-08-10期间的签到情况")]),t._v("\nGETBIT user:123:sign_in "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 1")]),t._v("\nGETBIT user:123:sign_in "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 0")]),t._v("\nGETBIT user:123:sign_in "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 0")]),t._v("\nGETBIT user:123:sign_in "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 1")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# ...")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 计算用户123的总签到次数")]),t._v("\nBITCOUNT user:123:sign_in  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 4")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 计算用户123的连续签到天数")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 使用 Lua 脚本来计算")]),t._v("\nEVAL "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v("\"return redis.call('BITOP', 'AND', 'temp', KEYS[1], KEYS[2]);\n      local count = 0;\n      for i=0, redis.call('BITCOUNT', 'temp')-1, 1 do\n          if redis.call('GETBIT', 'temp', i) == 1 then\n              count = count + 1;\n          else\n              break;\n          end;\n      end;\n      return count;\"")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),t._v(" user:123:sign_in user:123:sign_in\n")])])]),e("p",[t._v("以下是一个使用布隆过滤器的示例：")]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 假设布隆过滤器使用的位数组长度为 1000，哈希函数数量为 3")]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 添加用户访问记录到布隆过滤器")]),t._v("\nBF.ADD user:history  "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"page1"')]),t._v("\nBF.ADD user:history  "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"page3"')]),t._v("\nBF.ADD user:history  "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"page5"')]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 检查某个页面是否已经被访问过")]),t._v("\nBF.EXISTS user:history "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"page1"')]),t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 返回 1 (可能已经访问过)")]),t._v("\nBF.EXISTS user:history "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"page2"')]),t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 返回 0 (一定未访问过)")]),t._v("\nBF.EXISTS user:history "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"page3"')]),t._v("  "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 返回 1 (可能已经访问过)")]),t._v("\n")])])]),e("h3",{attrs:{id:"geo-地理位置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#geo-地理位置"}},[t._v("#")]),t._v(" Geo 地理位置")]),t._v(" "),e("p",[t._v("Geo 允许我们在 Redis 中存储和查询带有地理位置信息的数据，比如经纬度坐标。使得 Redis 可以用于构建地理位置相关的应用，比如地图、位置服务等。")]),t._v(" "),e("div",{staticClass:"anchor",attrs:{id:"示例"}},[t._v("示例")]),e("p",[t._v("以下是一个使用 Geo 的示例：")]),t._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 添加地理位置信息，使用经纬度坐标和成员名称")]),t._v("\nGEOADD locations "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("13.361389")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("38.115556")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Palermo"')]),t._v("\nGEOADD locations "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("15.087269")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("37.502669")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Catania"')]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 计算两个地理位置之间的距离，单位可以是米、千米等")]),t._v("\nGEODIST locations "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Palermo"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Catania"')]),t._v(" km\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 获取指定范围内的地理位置成员，例如获取距离某个地点 10 千米内的成员")]),t._v("\nGEORADIUS locations "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("15")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("37")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("10")]),t._v(" km\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 获取成员的经纬度坐标")]),t._v("\nGEOPOS locations "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Palermo"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Catania"')]),t._v("\n\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 根据距离排序获取成员")]),t._v("\nGEORADIUSBYMEMBER locations "),e("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Catania"')]),t._v(" "),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),t._v(" km\n")])])])])}),[],!1,null,null,null);s.default=n.exports},449:function(t,s,a){t.exports=a.p+"assets/img/image-20230717153319313.drawio.7bf015b9.png"},933:function(t,s,a){t.exports=a.p+"assets/img/image-20230203232917827.d836d155.png"},934:function(t,s,a){t.exports=a.p+"assets/img/image-20230203233215389.ead972db.png"},935:function(t,s,a){t.exports=a.p+"assets/img/image-20230204002934022.4ea30416.png"},936:function(t,s,a){t.exports=a.p+"assets/img/image-20230204003847215.854e5e1a.png"},937:function(t,s,a){t.exports=a.p+"assets/img/image-20230204004748813.389cdefe.png"},938:function(t,s,a){t.exports=a.p+"assets/img/image-20230204004157353.72addb16.png"},939:function(t,s,a){t.exports=a.p+"assets/img/image-20230717165422479.08a24764.jpg"},940:function(t,s,a){t.exports=a.p+"assets/img/image-20221127003328637.9c82acb1.png"},941:function(t,s,a){t.exports=a.p+"assets/img/image-20230222112448251.782480b6.png"},942:function(t,s,a){t.exports=a.p+"assets/img/image-20230217212051593.3beecd4e.png"},943:function(t,s,a){t.exports=a.p+"assets/img/image-20230217212426068.296fbc69.png"},944:function(t,s,a){t.exports=a.p+"assets/img/image-20230217212538996.fc594ef4.png"}}]);