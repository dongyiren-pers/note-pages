(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{1042:function(t,a,s){"use strict";s.r(a);var n=s(14),r=Object(n.a)({},(function(){var t=this,a=t.$createElement,n=t._self._c||a;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"第6章-synchronized-与-volatile"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#第6章-synchronized-与-volatile"}},[t._v("#")]),t._v(" 第6章 synchronized 与 volatile")]),t._v(" "),n("h2",{attrs:{id:"_6-1-关键字-synchronized"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-关键字-synchronized"}},[t._v("#")]),t._v(" 6.1 关键字 synchronized")]),t._v(" "),n("p",[t._v("synchronized 是 Java 并发模块非常重要的关键字，它是 Java 内建的一种同步机制，代表了某种内在锁定的概念，当一个线程对某个共享资源加锁后，其他想要获取共享资源的线程必须进行等待，synchronized 具有互斥和排他的语义。")]),t._v(" "),n("p",[t._v("synchronized 是一种独占的关键字，但是它这种独占的语义更多的是为了增加线程安全性，通过独占某个资源以达到互斥、排他的目的。")]),t._v(" "),n("h3",{attrs:{id:"如何使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如何使用"}},[t._v("#")]),t._v(" 如何使用")]),t._v(" "),n("h4",{attrs:{id:"修饰实例方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#修饰实例方法"}},[t._v("#")]),t._v(" 修饰实例方法")]),t._v(" "),n("p",[t._v("给当前对象实例加锁，进入同步代码前要获得 "),n("strong",[t._v("当前对象实例的锁")]),t._v(" 。")]),t._v(" "),n("div",{staticClass:"language-java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("method")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("h4",{attrs:{id:"修饰静态方法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#修饰静态方法"}},[t._v("#")]),t._v(" 修饰静态方法")]),t._v(" "),n("p",[t._v("给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 "),n("strong",[t._v("当前 Class 的锁")]),t._v("。")]),t._v(" "),n("p",[t._v("因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。")]),t._v(" "),n("div",{staticClass:"language-java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("method")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("h4",{attrs:{id:"修饰代码块-锁指定对象-类"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#修饰代码块-锁指定对象-类"}},[t._v("#")]),t._v(" 修饰代码块（锁指定对象 / 类）")]),t._v(" "),n("p",[t._v("对括号里指定的对象 / 类加锁：")]),t._v(" "),n("ul",[n("li",[n("code",[t._v("synchronized(object)")]),t._v(" 表示进入同步代码库前要获得 "),n("strong",[t._v("给定对象的锁")]),t._v("。")]),t._v(" "),n("li",[n("code",[t._v("synchronized(类.class)")]),t._v(" 表示进入同步代码前要获得 "),n("strong",[t._v("给定 Class 的锁")]),t._v("。")])]),t._v(" "),n("div",{staticClass:"language-java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("h3",{attrs:{id:"并发性质"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#并发性质"}},[t._v("#")]),t._v(" 并发性质")]),t._v(" "),n("h4",{attrs:{id:"保证可见性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#保证可见性"}},[t._v("#")]),t._v(" 保证可见性")]),t._v(" "),n("p",[t._v("被 synchronized 修饰的代码，会在开始执行的时候调用字节码指令 monitorenter 加锁，执行完成后，会调用字节码指令 monitorexit 解锁。")]),t._v(" "),n("p",[t._v("为了保证可见性，有一条规则是这样的：“对一个监视器锁的解锁，happens-before 于随后对这个监视器锁的加锁”，"),n("strong",[t._v("在对一个变量解锁之前，必须先把该变量同步回主存中")]),t._v("，此外，后续线程 "),n("strong",[t._v("在对这个变量加锁之后，必须先从主存中读取该变量")]),t._v("，从而保证了可见性。")]),t._v(" "),n("h4",{attrs:{id:"不禁止重排序"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#不禁止重排序"}},[t._v("#")]),t._v(" 不禁止重排序")]),t._v(" "),n("p",[t._v("由于处理器优化和指令重排等，CPU 有可能对代码进行乱序执行。需要注意的是，synchronized 是无法禁止指令重排和处理器优化的。如果要禁止重排序，则需要使用到 volatile。")]),t._v(" "),n("h4",{attrs:{id:"保证原子性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#保证原子性"}},[t._v("#")]),t._v(" 保证原子性")]),t._v(" "),n("p",[t._v("同一时间只有一个线程执行临界区代码，这个操作不能被其它线程打断，因此天然就具有原子性。")]),t._v(" "),n("h3",{attrs:{id:"实现原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实现原理"}},[t._v("#")]),t._v(" 实现原理")]),t._v(" "),n("h4",{attrs:{id:"同步语句块的实现原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#同步语句块的实现原理"}},[t._v("#")]),t._v(" 同步语句块的实现原理")]),t._v(" "),n("div",{staticClass:"language-java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SynchronizedDemo")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("method")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"synchronized 代码块"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("通过 JDK 自带的 "),n("code",[t._v("javap")]),t._v(" 命令查看 "),n("code",[t._v("SynchronizedDemo")]),t._v(" 类的相关字节码信息：首先切换到类的对应目录执行 "),n("code",[t._v("javac SynchronizedDemo.java")]),t._v(" 命令生成编译后的 .class 文件，然后执行 "),n("code",[t._v("javap -c -s -v -l SynchronizedDemo.class")]),t._v("。")]),t._v(" "),n("p",[n("img",{attrs:{src:s(676),alt:"image-20230122213546969"}})]),t._v(" "),n("p",[t._v("我们可以看出："),n("strong",[n("code",[t._v("synchronized")]),t._v(" 同步语句块的实现使用的是 "),n("code",[t._v("monitorenter")]),t._v(" 和 "),n("code",[t._v("monitorexit")]),t._v(" 指令，其中 "),n("code",[t._v("monitorenter")]),t._v(" 指令指向同步代码块的开始位置，"),n("code",[t._v("monitorexit")]),t._v(" 指令则指明同步代码块的结束位置。")])]),t._v(" "),n("p",[t._v("当执行 "),n("code",[t._v("monitorenter")]),t._v(" 指令时，线程试图获取锁（即 "),n("strong",[t._v("对象监视器 "),n("code",[t._v("monitor")])]),t._v("）的持有权。")]),t._v(" "),n("blockquote",[n("p",[t._v("在 Java 虚拟机（HotSpot）中，Monitor 是基于 C++ 实现的，由 ObjectMonitor 实现的。每个对象中都内置了一个 ObjectMonitor 对象。另外，wait/notify 等方法同样依赖于 monitor 对象，这就是为什么只有在同步的块或者方法中才能调用 wait/notify 等方法，否则会抛出 java.lang.IllegalMonitorStateException 的异常的原因。")])]),t._v(" "),n("p",[t._v("在执行 "),n("code",[t._v("monitorenter")]),t._v(" 时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器加 1。")]),t._v(" "),n("p",[t._v("对象锁的的拥有者线程才可以执行 "),n("code",[t._v("monitorexit")]),t._v(" 指令来释放锁。在执行 "),n("code",[t._v("monitorexit")]),t._v(" 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。")]),t._v(" "),n("p",[t._v("如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。")]),t._v(" "),n("h4",{attrs:{id:"同步方法的实现原理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#同步方法的实现原理"}},[t._v("#")]),t._v(" 同步方法的实现原理")]),t._v(" "),n("div",{staticClass:"language-java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("SynchronizedDemo2")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("method")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"synchronized 方法"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[n("img",{attrs:{src:s(677),alt:"image-20230122220418888"}})]),t._v(" "),n("p",[n("code",[t._v("synchronized")]),t._v(" 修饰的方法并没有 "),n("code",[t._v("monitorenter")]),t._v(" 指令和 "),n("code",[t._v("monitorexit")]),t._v(" 指令，取而代之的是 "),n("code",[t._v("ACC_SYNCHRONIZED")]),t._v(" 标识，该标识指明了该方法是一个同步方法。JVM 通过该 "),n("code",[t._v("ACC_SYNCHRONIZED")]),t._v(" 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。")]),t._v(" "),n("p",[t._v("如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 Class 的锁。")]),t._v(" "),n("h2",{attrs:{id:"_6-2-对象内存布局与锁升级"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-对象内存布局与锁升级"}},[t._v("#")]),t._v(" 6.2 对象内存布局与锁升级")]),t._v(" "),n("h3",{attrs:{id:"对象内存布局"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#对象内存布局"}},[t._v("#")]),t._v(" 对象内存布局")]),t._v(" "),n("p",[t._v("对象在实例化之后，是被存放在堆内存中的。这里的对象由三部分组成：")]),t._v(" "),n("ul",[n("li",[n("strong",[t._v("对象头")]),t._v("：普通对象的对象头包含 "),n("strong",[t._v("MarkWord")]),t._v(" 和类型指针。而数组对象的对象头还多包含了数组长度。")]),t._v(" "),n("li",[n("strong",[t._v("成员变量")]),t._v("：存储的是对象的真正的有效数据，即各个成员变量属性字段的值，如果拥有父类，还会包含父类的成员变量。")]),t._v(" "),n("li",[n("strong",[t._v("对齐填充")]),t._v("：具体对齐填充的规则与 JVM 有关。在 Hotspot 中，对象的大小要求向 8 Byte 对齐，当对象长度不足 8 字节的整数倍时，需要再对象中进行填充操作。")])]),t._v(" "),n("h4",{attrs:{id:"markword"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#markword"}},[t._v("#")]),t._v(" MarkWord")]),t._v(" "),n("p",[t._v("在对象头中，MarkWord 一共有 64 个 bit，用于存储对象自身的运行时数据，标记对象处于一下状态中的某一种：")]),t._v(" "),n("p",[n("img",{attrs:{src:s(678),alt:"image-20230810113339755.drawio"}})]),t._v(" "),n("ul",[n("li",[n("strong",[t._v("hashcode")]),t._v("：代表对象的内存地址值，只有当 hashcode 被使用到的时候，才会填充入该对象的 MarkWord 内，在此之前值为 0。")]),t._v(" "),n("li",[n("strong",[t._v("分代年龄")]),t._v("：代表对象的分代情况，用于 GC 的分代垃圾清理。")]),t._v(" "),n("li",[n("strong",[t._v("线程指针")]),t._v("：指向拥有偏向锁的线程")]),t._v(" "),n("li",[n("strong",[t._v("epoch")]),t._v("： 偏向锁的时间戳，用于偏向锁的 "),n("strong",[t._v("重偏向")]),t._v(" 与 "),n("strong",[t._v("批量撤销")]),t._v("。")])]),t._v(" "),n("blockquote",[n("p",[t._v("Integer 包装类比 int 基本类型内存占得更多：Integer 实例作为一个对象，对象头（64bit）加上存的整形数据（32bit）以及其他部分，远远超过 int 所需的内存（32 bit）。")])]),t._v(" "),n("h3",{attrs:{id:"锁升级"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#锁升级"}},[t._v("#")]),t._v(" 锁升级")]),t._v(" "),n("p",[t._v("JDK 6 之前，通过 synchronized 关键字加锁时，无差别地使用重量级锁，重量级锁会使 CPU 在用户态和内核态之间频繁切换，有很大的系统消耗。后来随着 synchronized 的不断优化，提出了 "),n("strong",[t._v("锁升级")]),t._v(" 的概念，在 MarkWord 中，通过锁的标志位来表示当前对象的锁状态。")]),t._v(" "),n("p",[t._v("synchronized 不断优化中，引入了偏向锁、轻量级锁、重量级锁的概念，在不同的情况逐步进行锁膨胀。过程如下图：")]),t._v(" "),n("p",[n("img",{attrs:{src:s(679),alt:"image-20230810120517337.drawio"}})]),t._v(" "),n("h3",{attrs:{id:"偏向锁"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#偏向锁"}},[t._v("#")]),t._v(" 偏向锁")]),t._v(" "),n("p",[n("strong",[t._v("有的对象可能大多使用的场合都只在一个线程中运行，只有少数情况会遇到多线程的竞争")]),t._v("。此时，不需要直接设置竞争机制，或者直接使用消耗资源的锁。我们可以通过偏向锁，"),n("strong",[t._v("只在 MarkWord 上加一个线程 ID 标记")]),t._v(" 的低消耗的方式，来标志对象正在被使用。当遇到争抢的时候，再依情况进行锁升级。例如 StringBuffer 中很多方法都被 synchronized 修饰，但是它的使用场景经常只在一个线程中执行。")]),t._v(" "),n("h4",{attrs:{id:"虚拟机开启偏向锁"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#虚拟机开启偏向锁"}},[t._v("#")]),t._v(" 虚拟机开启偏向锁")]),t._v(" "),n("p",[t._v("Hotspot JVM 中，偏向锁默认是开启的，而且是从程序开始计时起，延迟 4s 开启。")]),t._v(" "),n("p",[t._v("JVM 参数可以开启或者关闭偏向锁：")]),t._v(" "),n("div",{staticClass:"language-java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 开启：")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("XX"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UseBiasedLocking")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 关闭：")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("XX"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UseBiasedLocking")]),t._v("\n")])])]),n("p",[t._v("默认偏向锁在程序启动 4s 后开启。在 JVM 还没开启偏向锁的时候，如果执行 synchronized 代码，将会直接升级为轻量级锁。")]),t._v(" "),n("blockquote",[n("p",[t._v("JVM 启动过程中会有很多线程争抢，所以默认启动时不打开偏向锁，而是等待 4s 过后才打开偏向锁。")])]),t._v(" "),n("p",[t._v("修改偏向锁延迟时间的 JVM 操作为：")]),t._v(" "),n("div",{staticClass:"language-java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("XX"),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BiasedLockingStartupDelay")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),t._v("\n")])])]),n("p",[t._v("开启偏向锁后，Java 对象被创建后将会是 "),n("strong",[t._v("匿名偏向态")]),t._v("（可偏向态），未开启偏向锁，Java 对象被创建后将会是 "),n("strong",[t._v("普通对象")]),t._v("（无锁态）。")]),t._v(" "),n("h4",{attrs:{id:"普通对象与匿名偏向与偏向锁态"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#普通对象与匿名偏向与偏向锁态"}},[t._v("#")]),t._v(" 普通对象与匿名偏向与偏向锁态")]),t._v(" "),n("p",[t._v("普通对象的 MarkWord 格式为：")]),t._v(" "),n("p",[n("img",{attrs:{src:s(680),alt:"image-20230810140315956.drawio"}})]),t._v(" "),n("p",[t._v("没有开启偏向锁时，当对象首次创建的时候，hashcode、分代年龄均以 0 作为初始值。其中 hashcode 只有被使用的时候，才会被赋予值，例如该对象调用了 hashcode() 方法。")]),t._v(" "),n("p",[t._v("偏向锁态的 MarkWord 格式为：")]),t._v(" "),n("p",[n("img",{attrs:{src:s(681),alt:"image-20230810140444106.drawio"}})]),t._v(" "),n("p",[t._v("开启偏向锁后，对象实例化后，还没有线程对它上锁，"),n("strong",[t._v("线程ID")]),t._v(" 为初始值 0，即还没偏向任何一个线程。这个状态被称为 "),n("strong",[t._v("匿名偏向")]),t._v("。")]),t._v(" "),n("p",[t._v("此后，第一个对该对象上锁的线程，将会把 "),n("strong",[t._v("线程ID")]),t._v(" 记录到 MarkWord中。此时 MarkWord 的偏向锁位被置为 1，且锁标志位为 01。 此时这个对象就可以理解为偏向该线程，为 "),n("strong",[t._v("偏向锁态")]),t._v("。")]),t._v(" "),n("h4",{attrs:{id:"偏向锁的加锁过程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#偏向锁的加锁过程"}},[t._v("#")]),t._v(" 偏向锁的加锁过程")]),t._v(" "),n("p",[t._v("当 JVM 的偏向锁开启后，就可以对实例进行偏向锁的加锁。")]),t._v(" "),n("p",[t._v("不需要特别的加锁语法，我们只需要使用 synchronized 修饰，虚拟机就会根据是否开启偏向锁等条件，自动帮助你实现加锁。如：")]),t._v(" "),n("div",{staticClass:"language-java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("test")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//do something...")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("假设 Thread-0 想要对 Object 对象上锁：")]),t._v(" "),n("p",[n("strong",[t._v("1. 加锁成功情况")])]),t._v(" "),n("p",[n("strong",[t._v("a. 首次加锁")])]),t._v(" "),n("ul",[n("li",[t._v("判断锁对象是否是 "),n("strong",[t._v("匿名偏向状态")]),t._v("。")]),t._v(" "),n("li",[t._v("如果是，Thread-0 使用 CAS（Compare and Swap）尝试将线程 ID 赋值给 Object 的 MarkWord。由于 Object 的 线程 ID 还未被使用，赋值成功。")]),t._v(" "),n("li",[t._v("如果线程 ID 已被占用，而且不是不是 Thread-0 的线程 ID，说明该锁已经偏向别的线程，加锁失败。")]),t._v(" "),n("li",[t._v("此时 Thread-0 线程首次给 Object 对象加了锁，Object 对象的 MarkWord 中的线程 ID 就会指向 Thread-0。")])]),t._v(" "),n("blockquote",[n("p",[t._v("需要注意的是这里所说的 "),n("strong",[t._v("线程ID")]),t._v(" 是操作系统赋予的唯一标识，并不是 Java 中 Thread.getId() 获取到的ID。")])]),t._v(" "),n("p",[n("img",{attrs:{src:s(682),alt:""}})]),t._v(" "),n("p",[n("strong",[t._v("b. 再次加锁（锁重入）")])]),t._v(" "),n("p",[t._v("synchronized 修饰的是可重入锁，如果在同一线程中，偏向锁对象是允许锁的重入的。不过偏向锁的重入很简单，"),n("strong",[t._v("只需要判断锁对象的 线程ID 是否是当前线程即可。")])]),t._v(" "),n("p",[t._v("Thread-0 对 Object 首次加锁成功后，后续只需要判断线程 ID 是否还是自己即可，不需要重新 CAS 将线程 ID 更新到 Object 的 MarkWord 中。")]),t._v(" "),n("blockquote",[n("p",[t._v("偏向锁的重入没有计数器，只要线程 ID 还是自己，就认为可重入，即认为可以进入临界区。（同一线程中为顺序执行，不会有线程冲突）")])]),t._v(" "),n("p",[n("strong",[t._v("2. 加锁失败的情况")])]),t._v(" "),n("p",[t._v("假设 Object 锁对象 已经被 Thread-0 占用，此时线程 Thread-1 来竞争锁对象，流程将如下：")]),t._v(" "),n("ul",[n("li",[t._v("判断是否为偏向锁；")]),t._v(" "),n("li",[t._v("判断偏向锁指向的 Thread-0 是否还存在；")]),t._v(" "),n("li",[t._v("如果线程 Thread-0 还存活，则暂停 Thread-0 ；")]),t._v(" "),n("li",[t._v("将锁标志位设置为 00 （变为轻量级锁态）；【撤销偏向锁，并锁膨胀】")]),t._v(" "),n("li",[t._v("从 Thread-0 栈帧中的 Lock Record 与 Object 对象的 MarkWord 做更新（细节见轻量级锁的加锁）；")]),t._v(" "),n("li",[t._v("继续执行 Thread-0 的代码；")]),t._v(" "),n("li",[t._v("线程 Thread-1 自旋来争取锁对象；")])]),t._v(" "),n("p",[t._v("如果在第二步发现 Thread-0 已经不存在了，将会尝试进行 Object 偏向锁的重偏向。如果无法重偏向，将会进行锁升级，上述流程将会变为如下：")]),t._v(" "),n("ul",[n("li",[t._v("判断是否为偏向锁；")]),t._v(" "),n("li",[t._v("判断偏向锁指向的 Thread-0 是否还存在;")]),t._v(" "),n("li",[t._v("线程 Thread -0 不存在，且暂时无法进行重偏向；")]),t._v(" "),n("li",[t._v("将锁标志位设置为 00（变为轻量级锁态）；【撤销偏向锁，并锁膨胀】")]),t._v(" "),n("li",[t._v("Thread-1 对 Object 进行轻量级锁的加锁行为。（细节见轻量级锁的加锁）")])]),t._v(" "),n("p",[t._v("如果成功重偏向，将与下述的重偏向一致。")]),t._v(" "),n("h4",{attrs:{id:"偏向锁的解锁"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#偏向锁的解锁"}},[t._v("#")]),t._v(" 偏向锁的解锁")]),t._v(" "),n("div",{staticClass:"anchor",attrs:{id:"重偏向"}},[t._v("重偏向")]),n("p",[t._v("偏向锁没有实际意义上的解锁，离开 synchronized 代码块后，不会对偏向锁对象的 MarkWord 做修改，即偏向锁态的 MarkWord 中的 线程ID 仍然指向已经过时的线程。")]),t._v(" "),n("blockquote",[n("p",[t._v("偏向锁作为最 “轻” 的锁，这样设计的好处是：下次同一线程再次上锁，只需要判断自己是否曾经持有过锁，而不用再通过 CAS 去替换 MarkWord 中的 线程 ID 。如此减少了撤销偏向锁的资源消耗，同时减少了同一线程重入时候的 CAS 消耗。")])]),t._v(" "),n("p",[t._v("如果对象虽然被多个线程访问，但是没有竞争，此时偏向原线程（如上述例子的Thread-0） 的对象就有了重偏向其他线程（如上述例子的 Thread-1） 的机会。")]),t._v(" "),n("p",[n("strong",[t._v("重偏向条件")]),t._v("：JVM 会记录撤销偏向锁的次数，一旦撤销次数超过 "),n("strong",[t._v("20")]),t._v("，后续该类中的对象都可以重新偏向加锁线程（即将线程 ID 指向新的线程）。后续线程对重偏向的对象加锁，仍为偏向锁。")]),t._v(" "),n("p",[t._v("升级为轻量级锁将会增加 CPU 的负担，如果没有竞争，可以通过重新偏向来进行锁复用的优化。")]),t._v(" "),n("div",{staticClass:"anchor",attrs:{id:"批量撤销"}},[t._v("批量撤销")]),n("p",[t._v("JVM 会记录撤销偏向锁的记录，与重偏向不同的是，撤销次数超过 "),n("strong",[t._v("40")]),t._v(" 的时候，整个类的所有对象均变为不可偏向（锁标志位都变为无锁态 001），包括该类中未来新建的对象也是不可偏向。")]),t._v(" "),n("p",[t._v("无锁态的对象认为偏向锁未开启，未来只会升级为轻量级锁，或者重量级锁，而不会再变为偏向锁。")]),t._v(" "),n("blockquote",[n("p",[t._v("开启偏向功能的对象，在初始化之后，MarkWord 锁标志位是 "),n("strong",[t._v("101")]),t._v("，是可偏向状态。")]),t._v(" "),n("p",[t._v("没开启偏向功能的对象，在初始化之后，MarkWord 锁标志位是 "),n("strong",[t._v("001")]),t._v("，是不可偏向状态。")])]),t._v(" "),n("h3",{attrs:{id:"轻量级锁"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#轻量级锁"}},[t._v("#")]),t._v(" 轻量级锁")]),t._v(" "),n("h4",{attrs:{id:"偏向锁-→-轻量级锁"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#偏向锁-→-轻量级锁"}},[t._v("#")]),t._v(" 偏向锁 → 轻量级锁")]),t._v(" "),n("p",[t._v("当只有一个线程访问偏向锁的时候，仅仅把线程 ID 记录到 MarkWord 中，没有额外的系统消耗。但是，当有新的线程也需要对该对象上锁，发现该对象已经被别的线程持有偏向锁（观察到 MarkWord 中有别的线程 ID），此时的竞争升级。")]),t._v(" "),n("p",[t._v("系统将会 "),n("strong",[t._v("撤销偏向锁")]),t._v("，并将锁升级为 "),n("strong",[t._v("轻量级锁（自旋锁）")]),t._v("。")]),t._v(" "),n("p",[t._v("设置轻量级锁，首先需要在当前线程的 "),n("strong",[t._v("栈帧")]),t._v(" 中创建一个 "),n("strong",[t._v("Lock Record")]),t._v("，通过使用 CAS 尝试将 Lock Record 与 Object 的 MarkWord 互换，从而进行锁的争抢。")]),t._v(" "),n("h4",{attrs:{id:"轻量级锁的加锁过程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#轻量级锁的加锁过程"}},[t._v("#")]),t._v(" 轻量级锁的加锁过程")]),t._v(" "),n("p",[n("strong",[t._v("1. 加锁成功的情况")])]),t._v(" "),n("p",[n("strong",[t._v("a. 从无锁态加锁为轻量级锁")])]),t._v(" "),n("p",[t._v("假设 Thread-0 要对 Object 上锁，且为轻量级锁的加锁")]),t._v(" "),n("ul",[n("li",[t._v("【判断锁标志位】判断 MarkWord 是否为无锁态（锁标志位为 001）；")]),t._v(" "),n("li",[t._v("【创建 Lock Record】Thread-0 在自己的线程栈的栈帧中创建一个 Lock Record；")]),t._v(" "),n("li",[t._v("【配置 Lock Record】新建的 Lock Record 中的记录内容为当前 Lock Record 的地址，锁对象的引用（Object reference） 为锁对象的内存地址；")]),t._v(" "),n("li",[t._v("【CAS 交换 LR 与 MarkWord】通过 CAS 尝试交换 Lock Record 的内容与锁对象的 MarkWord。")])]),t._v(" "),n("p",[t._v("如下图：")]),t._v(" "),n("p",[n("img",{attrs:{src:s(683),alt:""}})]),t._v(" "),n("ul",[n("li",[t._v("交换成功即上锁成功，上锁后的情况如下图：")])]),t._v(" "),n("p",[n("img",{attrs:{src:s(684),alt:""}})]),t._v(" "),n("p",[n("strong",[t._v("b. 从偏向锁升级为轻量级锁（锁对象不在重偏向状态）")])]),t._v(" "),n("p",[t._v("假设 Thread-1 要对 Object 上锁，Object 当前状态为偏向锁态（MarkWord 锁标志位为 "),n("strong",[t._v("101")]),t._v("）")]),t._v(" "),n("ul",[n("li",[t._v("【判断锁标志位】将 MarkWord 中的锁标志位更改为 00；")]),t._v(" "),n("li",[t._v("【找到原线程】如果持有偏向锁的线程还在运行；")]),t._v(" "),n("li",[t._v("【添加 Lock Record】在自己和持有锁的线程的栈帧中添加 Lock Record；")]),t._v(" "),n("li",[t._v("【CAS 交换 LR 与 MarkWord】 持有锁的线程通过 CAS 尝试交换 Lock Record 与 锁对象的 MarkWord；")]),t._v(" "),n("li",[t._v("【CAS 交换 LR 与 MarkWord】如果没有持有锁的线程 ，则自己通过 CAS 尝试交换 Lock Record 与 锁对象的 MarkWord；")]),t._v(" "),n("li",[t._v("交换成功即上锁成功。")])]),t._v(" "),n("blockquote",[n("p",[t._v("如果锁对象在 重偏向状态，第二个线程将会对偏向锁态的对象 进行重偏向 到自己线程 ID 的行为，而不会升级为轻量级锁。")])]),t._v(" "),n("p",[n("strong",[t._v("c. 锁的重入")])]),t._v(" "),n("p",[t._v("假设 Thread-0 已经持有 Object 的轻量级锁，此时在本线程内又要对其上锁，即锁重入，流程如下：")]),t._v(" "),n("ul",[n("li",[t._v("【判断锁标志位】判断 MarkWord 的锁标志位。")]),t._v(" "),n("li",[t._v("【判断是否重入】如果是轻量级锁态，通过 MarkWord 的 ptr_to_lock_record 判断是否本线程持有锁；")]),t._v(" "),n("li",[t._v("【非重入则锁膨胀】如果不是锁重入的情况，说明竞争冲突，膨胀为重量级锁；（见重量级锁的加锁）")]),t._v(" "),n("li",[t._v("【是重入则加空 Lock Record】如果是锁重入，将在自己的栈帧中加一个 Lock Record，与初次上锁不同的是，记录内容为空（null），锁对象的引用仍然也指向 Object 锁对象。")])]),t._v(" "),n("p",[t._v("需要注意的是，轻量级锁的重入无需计数器，在解锁过程中，遇到 LockRecord 的记录为空，说明是重入的锁，遇到记录不为空，才算真正解锁。")]),t._v(" "),n("p",[t._v("锁重入的流程图如下：")]),t._v(" "),n("p",[n("img",{attrs:{src:s(685),alt:"请添加图片描述"}})]),t._v(" "),n("p",[n("strong",[t._v("2. 加锁失败的情况")])]),t._v(" "),n("p",[t._v("如果遇到锁对象的 MarkWord 的 "),n("strong",[t._v("锁标志位为 00")]),t._v("，说明该锁对象正在被一个线程持有，且为轻量级锁态。")]),t._v(" "),n("p",[t._v("如果持有锁的线程不是自己，则加锁失败，进入锁升级流程（见重量级锁）。示意图如下：")]),t._v(" "),n("p",[n("img",{attrs:{src:s(686),alt:""}})]),t._v(" "),n("p",[t._v("当自旋到一定轮数，或者自旋线程数到达一定数量，该锁对象将会升级为重量级锁态，具体见后面探讨的重量级锁。")]),t._v(" "),n("h4",{attrs:{id:"轻量级锁的解锁过程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#轻量级锁的解锁过程"}},[t._v("#")]),t._v(" 轻量级锁的解锁过程")]),t._v(" "),n("p",[t._v("退出栈帧的时候，如果 "),n("strong",[t._v("Lock Record 的记录为 null")]),t._v("，说明是重入锁，仅仅是弹出栈帧。")]),t._v(" "),n("p",[t._v("如果 "),n("strong",[t._v("Lock Record 的记录有值")]),t._v("，说明本次解锁是真正解锁（解除的不是重入的锁）。")]),t._v(" "),n("p",[t._v("解锁的过程为：")]),t._v(" "),n("ul",[n("li",[t._v("【判断锁标志位】如果 MarkWord 的锁标志位为 "),n("strong",[t._v("00")]),t._v("（如果锁标志位为 "),n("strong",[t._v("10")]),t._v("，说明在持有过程中，该锁对象升级为了重量级锁）")]),t._v(" "),n("li",[t._v("【如果锁对象是重量级锁】如果  MarkWord 的锁标志位为 "),n("strong",[t._v("10")]),t._v("，根据 MarkWord 的 ptr_to_monitor 找到 ObjectMonitor ，并将 owner 置为 null，同时唤醒 EntryList，由操作系统调度唤醒等待队列中的线程；")]),t._v(" "),n("li",[t._v("【如果锁对象仍然是轻量级锁】如果 MarkWord 的锁标志位为 "),n("strong",[t._v("00")]),t._v(" ，通过 CAS 尝试 将 Lock Record 的 record 的值与 Object 锁对象的 MarkWord 交换；")]),t._v(" "),n("li",[t._v("【解锁结果】交换完成后锁对象的 MarkWord 的锁标志位变为 "),n("strong",[t._v("001")]),t._v("（上锁前为无锁态），或 "),n("strong",[t._v("101")]),t._v("（上锁前为偏向锁态）；")]),t._v(" "),n("li",[t._v("【退出栈帧，并删除 Lock Record】删除线程栈中对应的 Lock Record。")])]),t._v(" "),n("blockquote",[n("p",[t._v("偏向锁在撤销的时候会消耗系统资源，在争抢激烈的时候，效率没有轻量级锁高。")])]),t._v(" "),n("h3",{attrs:{id:"重量级锁"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#重量级锁"}},[t._v("#")]),t._v(" 重量级锁")]),t._v(" "),n("h4",{attrs:{id:"轻量级锁-→-重量级锁"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#轻量级锁-→-重量级锁"}},[t._v("#")]),t._v(" 轻量级锁 → 重量级锁")]),t._v(" "),n("p",[t._v("重量级锁 "),n("strong",[t._v("需要内核态的参与")]),t._v("，JVM 向操作系统申请 "),n("strong",[t._v("ObjectMonitor")]),t._v("，这是一个 C++ 对象，需要内核态才能访问。锁对象的 MarkWord 指向 ObjectMonitor 的地址。")]),t._v(" "),n("p",[t._v("ObjectMonitor 的主要结构如下图：")]),t._v(" "),n("p",[n("img",{attrs:{src:s(687),alt:""}})]),t._v(" "),n("ul",[n("li",[n("strong",[t._v("Owner")]),t._v("：指向持有该 ObjectMonitor 的线程。")]),t._v(" "),n("li",[n("strong",[t._v("EntryList")]),t._v("：等待队列，队列中的线程都为 "),n("strong",[t._v("BLOCKED")]),t._v(" 状态（Java 的六种线程状态之一），等待锁。")]),t._v(" "),n("li",[n("strong",[t._v("WaitSet")]),t._v("：存放处于 "),n("strong",[t._v("WAITING")]),t._v(" 状态（Java 的六种线程状态之一）的线程。")]),t._v(" "),n("li",[n("strong",[t._v("Recursions")]),t._v("：持有该 ObjectMonitor 的线程的重入次数。")])]),t._v(" "),n("p",[t._v("重量级锁有等待队列，没有争抢到锁的线程经过自适应自旋后，进入等待队列，变为 "),n("strong",[t._v("BLOCKED")]),t._v(" 状态，等待被唤醒。再次启动去争取锁的过程将比较耗时。")]),t._v(" "),n("h4",{attrs:{id:"重量级锁的加锁过程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#重量级锁的加锁过程"}},[t._v("#")]),t._v(" 重量级锁的加锁过程")]),t._v(" "),n("p",[t._v("当线程 "),n("strong",[t._v("获取轻量级锁失败")]),t._v(" 或 "),n("strong",[t._v("遇到 wait() 或 notify() 方法")]),t._v("，将进入重量级锁升级状态。")]),t._v(" "),n("p",[t._v("重量级加锁流程如下：")]),t._v(" "),n("ul",[n("li",[t._v("【申请 ObjectMonitor】让操作系统为 Obj 申请 ObjectMonitor 锁；")]),t._v(" "),n("li",[t._v("【配置 ObjectMonitor 的 owner】如果 Obj 原先是轻量级锁，让 ObjectMonitor 的 owner 指向持有轻量级锁的线程（通过轻量级锁对象 MarkWord 的 ptr_to_lock_record）；")]),t._v(" "),n("li",[t._v("【配置 ObjectMonitor 的 owner】如果 Obj 原先是偏向锁，让 ObjectMonitor 的 owner 指向持有偏向锁的线程（通过偏向锁对象 MarkWord 的 线程 ID）；")]),t._v(" "),n("li",[t._v("【配置 ObjectMonitor 的 owner】如果 Obj 原先是无锁态，让 ObjectMonitor 的 owner 标空；")]),t._v(" "),n("li",[t._v("【更新 Obj 锁标志位】并将 MarkWord 锁标志位改为 "),n("strong",[t._v("10")]),t._v(" （重量级锁态）；")]),t._v(" "),n("li",[t._v("【将 Obj 与 Monitor 关联起来】让 Obj 的 MarkWord 指向 ObjectMonitor 地址;")]),t._v(" "),n("li",[t._v("【线程自适应自旋】线程进行自适应自旋，如果在最大自旋次数内争抢成功，使得 ObjectMonitor 的 owner 指向自己，则加锁成功。")]),t._v(" "),n("li",[t._v("【进入等待队列】如果在最大自选次数内没有争抢成功，则进入 ObjectMonitor 的 EntryList 等待队列中等待，并进入 BLOCKED 状态（Java 线程的六个状态之一）。")])]),t._v(" "),n("p",[t._v("第二步，从轻量级锁升级为重量级的图示如下：")]),t._v(" "),n("p",[n("img",{attrs:{src:s(688),alt:""}})]),t._v(" "),n("p",[t._v("第三步，从偏向锁升级为重量级锁的图示如下：")]),t._v(" "),n("p",[n("img",{attrs:{src:s(689),alt:"请添加图片描述"}})]),t._v(" "),n("blockquote",[n("p",[t._v("自适应自旋：根据情况，增加或减少最大次数的自旋。")]),t._v(" "),n("p",[t._v("JDK6 之后使用了自适应自旋，如果线程通过自旋获得重量级锁，则下一次再有线程进行自适应自旋来争取该 ObjectMonitor ，可以提高几次的最大自旋次数。")]),t._v(" "),n("p",[t._v("如果线程在最大次数自旋内没有获得重量级锁（没有争抢到 ObjectMonitor 的owner），则下次再有线程通过自适应自旋来争取该 ObjectMonitor，则减少最大自旋，甚至不进行自旋，直接进入 EntryList 而进入 "),n("strong",[t._v("BLOCKED")]),t._v(" 状态。")])]),t._v(" "),n("h4",{attrs:{id:"重量级锁的解锁过程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#重量级锁的解锁过程"}},[t._v("#")]),t._v(" 重量级锁的解锁过程")]),t._v(" "),n("ul",[n("li",[t._v("将 recursion 重入次数减 1。")]),t._v(" "),n("li",[t._v("如果 recursion 为 0，表示本次是真正的解锁，将 owner 置空，并唤醒 EntryList 中的线程。")])]),t._v(" "),n("blockquote",[n("p",[t._v("唤醒：只是将线程变为就绪态，可以被 CPU 分配时间片，并不代表立即运行。")])]),t._v(" "),n("p",[t._v("线程自旋占 CPU 资源，重度竞争的时候，自旋的时间很长，或者自旋的线程很多，CPU 花了更多时间在线程切换上。重量级锁通过内核态，将没有争抢到锁的线程阻塞，排队等待，减轻了系统资源的消耗。")]),t._v(" "),n("h2",{attrs:{id:"_6-3-关键字-volatile"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-关键字-volatile"}},[t._v("#")]),t._v(" 6.3 关键字 volatile")]),t._v(" "),n("h3",{attrs:{id:"如何使用-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如何使用-2"}},[t._v("#")]),t._v(" 如何使用")]),t._v(" "),n("div",{staticClass:"language-java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" a"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),n("h3",{attrs:{id:"并发性质-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#并发性质-2"}},[t._v("#")]),t._v(" 并发性质")]),t._v(" "),n("h4",{attrs:{id:"保证可见性-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#保证可见性-2"}},[t._v("#")]),t._v(" 保证可见性")]),t._v(" "),n("p",[t._v("可见性问题主要指一个线程修改了共享变量值，而另一个线程却看不到。")]),t._v(" "),n("p",[t._v("引起可见性问题的主要原因是每个线程拥有自己的一个高速缓存区——线程工作内存。volatile 关键字能有效的解决这个问题。看看下面的例子：")]),t._v(" "),n("div",{staticClass:"language-java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TestVolatile")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" stop "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" args"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Thread-A")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('"Thread A"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[t._v("@Override")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("run")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!")]),t._v("stop"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n                "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("currentThread")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('" stopped"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("start")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Thread-main")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("TimeUnit")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("SECONDS"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("sleep")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Thread")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("currentThread")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[t._v('" after 1 seconds"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("catch")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("InterruptedException")]),t._v(" e"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            e"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("printStackTrace")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        stop "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("执行输出如下：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("Thread[main,5,main] after 1 seconds\n")])])]),n("p",[t._v("可以看到 Thread-main 休眠 1 秒之后，设置 stop = ture，但是 Thread A 根本没停下来，这就是可见性问题。如果通过在 stop 变量前面加上 volatile 关键字则会真正 stop：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("Thread[main,5,main] after 1 seconds\nThread[Thread A,5,main] stopped\n\nProcess finished with exit code 0\n")])])]),n("h4",{attrs:{id:"禁止重排序"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#禁止重排序"}},[t._v("#")]),t._v(" 禁止重排序")]),t._v(" "),n("p",[t._v("我们从一个最经典的例子来分析重排序问题。大家应该都很熟悉单例模式的实现，而在并发环境下的单例实现方式，我们通常可以采用 "),n("strong",[t._v("双重检查加锁（DCL）")]),t._v(" 的方式来实现。其源码如下：")]),t._v(" "),n("div",{staticClass:"language-java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),t._v(" singleton"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 构造函数私有，禁止外部实例化")]),t._v("\n    \n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("getInstance")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("singleton "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("singleton"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("singleton "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                    singleton "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Singleton")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n                "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" singleton"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("现在我们分析一下为什么要在变量 singleton 之前加上volatile关键字。要理解这个问题，先要了解对象的构造过程，实例化一个对象其实可以分为三个步骤：")]),t._v(" "),n("ul",[n("li",[t._v("分配内存空间。")]),t._v(" "),n("li",[t._v("初始化对象。")]),t._v(" "),n("li",[t._v("将内存空间的地址赋值给对应的引用。")])]),t._v(" "),n("p",[t._v("但是由于操作系统可以对指令进行重排序，所以上面的过程可能会变成如下过程：")]),t._v(" "),n("ul",[n("li",[t._v("分配内存空间。")]),t._v(" "),n("li",[t._v("将内存空间的地址赋值给对应的引用。")]),t._v(" "),n("li",[t._v("初始化对象")])]),t._v(" "),n("p",[t._v("多线程环境下就可能将一个未初始化的对象引用暴露出来，从而导致不可预料的结果。因此，为了防止这个过程的重排序，我们需要将变量设置为 volatile 类型的变量。")]),t._v(" "),n("h4",{attrs:{id:"不保证原子性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#不保证原子性"}},[t._v("#")]),t._v(" 不保证原子性")]),t._v(" "),n("p",[t._v("volatile 不能保证完全的原子性，只能保证单次的读 / 写操作具有原子性。")]),t._v(" "),n("h3",{attrs:{id:"实现原理-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#实现原理-2"}},[t._v("#")]),t._v(" 实现原理")]),t._v(" "),n("h4",{attrs:{id:"保证可见性的实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#保证可见性的实现"}},[t._v("#")]),t._v(" 保证可见性的实现")]),t._v(" "),n("p",[t._v("写一段简单的 Java 代码，声明一个 volatile 变量，并赋值。")]),t._v(" "),n("div",{staticClass:"language-java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Test")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" a"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("update")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        a "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("main")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" args"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Test")]),t._v(" test "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Test")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        test"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("update")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("通过 hsdis 和 jitwatch 工具可以得到编译后的汇编代码：")]),t._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("......\n  0x0000000002951563: and    $0xffffffffffffff87,%rdi\n  0x0000000002951567: je     0x00000000029515f8\n  0x000000000295156d: test   $0x7,%rdi\n  0x0000000002951574: jne    0x00000000029515bd\n  0x0000000002951576: test   $0x300,%rdi\n  0x000000000295157d: jne    0x000000000295159c\n  0x000000000295157f: and    $0x37f,%rax\n  0x0000000002951586: mov    %rax,%rdi\n  0x0000000002951589: or     %r15,%rdi\n  0x000000000295158c: lock\t cmpxchg %rdi,(%rdx) \n  0x0000000002951591: jne    0x0000000002951a15\n  0x0000000002951597: jmpq   0x00000000029515f8\n  0x000000000295159c: mov    0x8(%rdx),%edi\n  0x000000000295159f: shl    $0x3,%rdi\n  0x00000000029515a3: mov    0xa8(%rdi),%rdi\n  0x00000000029515aa: or     %r15,%rdi\n......\n")])])]),n("p",[t._v("volatile 修饰的共享变量进行写操作时会加上 lock 前缀指令。lock 前缀指令会引发两件事情：")]),t._v(" "),n("ul",[n("li",[t._v("将当前处理器缓存行的数据写回到系统内存。")]),t._v(" "),n("li",[t._v("当前处理器的缓存回写到内存会导致其他处理器的缓存失效。")])]),t._v(" "),n("p",[t._v("volatile 变量通过这样的机制就使得每个线程都能获得该变量的最新值。")]),t._v(" "),n("div",{staticClass:"anchor",attrs:{id:"缓存一致性协议"}},[t._v("缓存一致性协议")]),n("p",[t._v("IA-32 CPU 和 Intel 64 CPU 使用 "),n("strong",[t._v("缓存一致性协议（MESI）")]),t._v(" 去维护内部缓存和其他处理器缓存的一致性，避免在总线加 lock 锁。CPU 使用嗅探技术保证它的内部缓存、系统内存和其他处理器的缓存的数据在总线上保持一致。具体解决思路为："),n("strong",[t._v("当 CPU 写数据时，如果发现操作的变量是共享变量，即在其他 CPU 中存在该变量的副本，那么会发出信号通知其他 CPU 将该变量的缓存行设置为无效状态。当其他 CPU 使用这个变量时，首先会去嗅探是否有对该变量更改的信号，当发现这个变量的缓存行已经无效时，会重新从内存中读取这个变量。")])]),t._v(" "),n("p",[t._v("MESI 代表四种缓存状态："),n("strong",[t._v("M")]),t._v("odified（修改）、"),n("strong",[t._v("E")]),t._v("xclusive（独占）、"),n("strong",[t._v("S")]),t._v("hared（共享）和 "),n("strong",[t._v("I")]),t._v("nvalid（无效）。这些状态代表了缓存中数据的不同情况和处理器对数据的访问权限。")]),t._v(" "),n("style",[t._v("\n                        .table-column-x-x-container-1rq8vy3e table th:nth-of-type(1) {\n                            width: 30%;\n                            word-wrap: break-word;\n                        }\n                    \n                        .table-column-x-x-container-1rq8vy3e table th:nth-of-type(2) {\n                            width: 70%;\n                            word-wrap: break-word;\n                        }\n                    ")]),n("div",{staticClass:"table-column-x-x-container-1rq8vy3e"},[n("table",[n("thead",[n("tr",[n("th",[t._v("状态")]),t._v(" "),n("th",[t._v("描述")])])]),t._v(" "),n("tbody",[n("tr",[n("td",[n("strong",[t._v("M")]),t._v("odified（修改）")]),t._v(" "),n("td",[t._v("表示缓存中的数据已被修改，并且该数据是唯一有效的副本。其他缓存中的该数据副本无效。")])]),t._v(" "),n("tr",[n("td",[n("strong",[t._v("E")]),t._v("xclusive（独占）")]),t._v(" "),n("td",[t._v("表示缓存中的数据是有效的，但没有被修改。其他缓存中没有该数据的副本。")])]),t._v(" "),n("tr",[n("td",[n("strong",[t._v("S")]),t._v("hared（共享）")]),t._v(" "),n("td",[t._v("表示缓存中的数据是有效的，且可以在其他缓存中共享。多个缓存可以拥有相同的数据副本。")])]),t._v(" "),n("tr",[n("td",[n("strong",[t._v("I")]),t._v("nvalid（无效）")]),t._v(" "),n("td",[t._v("表示缓存中的数据无效，可能是因为其他处理器修改了数据，或者本处理器修改了数据但还没有通知其他处理器。")])])])])]),n("p",[n("img",{attrs:{src:s(690),alt:"image-20230829150054376"}})]),t._v(" "),n("h4",{attrs:{id:"禁止重排序的实现"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#禁止重排序的实现"}},[t._v("#")]),t._v(" 禁止重排序的实现")]),t._v(" "),n("p",[t._v("happens-before 规则中有一条 volatile 变量规则："),n("strong",[t._v("对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。")])]),t._v(" "),n("p",[t._v("假设线程 A 执行 writer 方法，线程 B 执行 reader 方法：")]),t._v(" "),n("div",{staticClass:"language-java extra-class"},[n("pre",{pre:!0,attrs:{class:"language-java"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("VolatileExample")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" a "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("volatile")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" flag "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("writer")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        a "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("              "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 1 线程 A 修改共享变量")]),t._v("\n        flag "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("        "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 2 线程 A 写 volatile 变量")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" \n\n    "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[t._v("reader")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("flag"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("         "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 3 线程 B 读同一个 volatile 变量")]),t._v("\n            "),n("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),n("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" a"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("      "),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 4 线程 B 读共享变量")]),t._v("\n           \t"),n("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// ...")]),t._v("\n        "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),n("p",[t._v("根据 happens-before 规则，上面过程会建立 3 类 happens-before 关系。")]),t._v(" "),n("ul",[n("li",[t._v("根据程序次序规则：1 happens-before 2 且 3 happens-before 4。")]),t._v(" "),n("li",[t._v("根据 volatile 规则：2 happens-before 3。")]),t._v(" "),n("li",[t._v("根据 happens-before 的传递性规则：1 happens-before 4。")])]),t._v(" "),n("p",[n("img",{attrs:{src:s(691),alt:"img"}})]),t._v(" "),n("p",[t._v("当线程 A 将 volatile 变量 flag 更改为 true 后，线程 B 能够迅速感知。")]),t._v(" "),n("div",{staticClass:"anchor",attrs:{id:"内存屏障"}},[t._v("内存屏障")]),n("p",[t._v("为了性能优化，JMM 在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。JMM 提供了 "),n("strong",[t._v("内存屏障（Memory Barrier）")]),t._v(" 阻止这种重排序。")]),t._v(" "),n("p",[t._v("内存屏障，又称内存栅栏，是一个 CPU 指令。在程序运行时，为了提高执行性能，编译器和处理器会对指令进行重排序，JMM 为了保证在不同的编译器和 CPU 上有相同的结果，通过插入特定类型的内存屏障来禁止特定类型的编译器重排序和处理器重排序，"),n("strong",[t._v("插入一条内存屏障会告诉编译器和 CPU：任何指令都不能和这条 Memory Barrier 指令重排序。")])]),t._v(" "),n("p",[t._v("Java 编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。")]),t._v(" "),n("p",[t._v("JMM 针对编译器制定 volatile 重排序规则表。")]),t._v(" "),n("table",[n("thead",[n("tr",[n("th",{staticStyle:{"text-align":"center"}},[t._v("第一个操作 \\ 第二个操作")]),t._v(" "),n("th",{staticStyle:{"text-align":"center"}},[t._v("普通读 / 写")]),t._v(" "),n("th",{staticStyle:{"text-align":"center"}},[t._v("volatile 读")]),t._v(" "),n("th",{staticStyle:{"text-align":"center"}},[t._v("volatile 写")])])]),t._v(" "),n("tbody",[n("tr",[n("td",{staticStyle:{"text-align":"center"}},[t._v("普通读 / 写")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}}),t._v(" "),n("td",{staticStyle:{"text-align":"center"}}),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("NO")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"center"}},[t._v("volatile 读")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("NO")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("NO")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("NO")])]),t._v(" "),n("tr",[n("td",{staticStyle:{"text-align":"center"}},[t._v("volatile 写")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}}),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("NO")]),t._v(" "),n("td",{staticStyle:{"text-align":"center"}},[t._v("NO")])])])]),t._v(" "),n("p",[t._v('" NO " 表示禁止重排序。')]),t._v(" "),n("p",[t._v("编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，JMM 采取了保守的策略。")]),t._v(" "),n("p",[t._v("volatile 写是在前面和后面分别插入内存屏障，而 volatile 读操作是在后面插入两个内存屏障：")]),t._v(" "),n("ul",[n("li",[t._v("在每个 volatile 写操作的前面插入一个 StoreStore 屏障，后面插入一个 StoreLoad 屏障。")]),t._v(" "),n("li",[t._v("在每个 volatile 读操作的后面插入一个 LoadLoad 屏障和一个 LoadStore 屏障。")])])])}),[],!1,null,null,null);a.default=r.exports},676:function(t,a,s){t.exports=s.p+"assets/img/image-20230122213546969.0b4d7385.png"},677:function(t,a,s){t.exports=s.p+"assets/img/image-20230122220418888.8efd14d1.png"},678:function(t,a,s){t.exports=s.p+"assets/img/image-20230810113339755.drawio.f93fe618.png"},679:function(t,a,s){t.exports=s.p+"assets/img/image-20230810120517337.drawio.0857cfb4.png"},680:function(t,a,s){t.exports=s.p+"assets/img/image-20230810140315956.drawio.056062fe.png"},681:function(t,a,s){t.exports=s.p+"assets/img/image-20230810140444106.drawio.e6dd1cf2.png"},682:function(t,a,s){t.exports=s.p+"assets/img/6337349361dd43d6b9fb48a047f6ae81.d2200b7f.png"},683:function(t,a,s){t.exports=s.p+"assets/img/2b6ccde607d9487cb44649d8d2d4a26c.268741fb.png"},684:function(t,a,s){t.exports=s.p+"assets/img/b9335376ef8a4e13b7f2796fe21d54f3.b8a71b73.png"},685:function(t,a,s){t.exports=s.p+"assets/img/81a836d56c68426db7087821c89505d2.3cb8751a.png"},686:function(t,a,s){t.exports=s.p+"assets/img/cf9bc797273a4c529cbd4d33ac88531f.2d3edb4d.png"},687:function(t,a,s){t.exports=s.p+"assets/img/743b7e6763ca4b74b157c2edad1b44aa.1c44e6ee.png"},688:function(t,a,s){t.exports=s.p+"assets/img/be4414eccc5c4902b21d32172cbf6421.3dcb3cb9.png"},689:function(t,a,s){t.exports=s.p+"assets/img/28c3737f43af4b50857f4d8e04609cf5.5036630d.png"},690:function(t,a,s){t.exports=s.p+"assets/img/image-20230829150054376.ad1f08b1.png"},691:function(t,a,s){t.exports=s.p+"assets/img/java-thread-x-key-volatile-1.9d28a280.png"}}]);