(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{1097:function(e,t,s){"use strict";s.r(t);var r=s(14),o=Object(r.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"第3章-rocketmq-设计"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#第3章-rocketmq-设计"}},[e._v("#")]),e._v(" 第3章 RocketMQ 设计")]),e._v(" "),r("h2",{attrs:{id:"_3-1-消息存储"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-消息存储"}},[e._v("#")]),e._v(" 3.1 消息存储")]),e._v(" "),r("p",[e._v("RocketMQ 中的消息存储在本地文件系统中，这些相关文件默认在当前用户主目录下的 "),r("strong",[e._v("store 目录")]),e._v(" 中。")]),e._v(" "),r("p",[r("strong",[e._v("abort")]),e._v("：该文件在 Broker 启动后会自动创建，正常关闭 Broker，该文件会自动消失。若在没有启动 Broker 的情况下，发现这个文件是存在的，则说明之前 Broker 的关闭是非正常关闭。")]),e._v(" "),r("p",[r("strong",[e._v("checkpoint")]),e._v("：其中存储着 commitlog、consumequeue、index 文件的最后刷盘时间戳。")]),e._v(" "),r("p",[r("strong",[e._v("commitlog")]),e._v("：其中存放着 commitlog 文件，而消息是写在 commitlog 文件中的。")]),e._v(" "),r("p",[r("strong",[e._v("config")]),e._v("：存放着 Broker 运行期间的一些配置数据。")]),e._v(" "),r("p",[r("strong",[e._v("consumequeue")]),e._v("：其中存放着 consumequeue 文件，队列就存放在这个目录中。")]),e._v(" "),r("p",[r("strong",[e._v("index")]),e._v("：其中存放着消息索引文件 indexFile。")]),e._v(" "),r("p",[r("strong",[e._v("lock")]),e._v("：运行期间使用到的全局资源锁。")]),e._v(" "),r("h3",{attrs:{id:"commitlog-文件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#commitlog-文件"}},[e._v("#")]),e._v(" commitlog 文件")]),e._v(" "),r("p",[e._v("commitlog 目录中存放着很多的 mappedFile 文件，当前 Broker 中的所有消息都是落盘到这些 mappedFile 文件中的。mappedFile 文件大小为 1G（小于等于 1G），写满后自动生成一个新的文件。文件名由 20 位十进制数构成，表示当前文件的第一条消息的起始位移偏移量。")]),e._v(" "),r("p",[e._v("一个 Broker 中仅包含一个 commitlog 目录，所有的 mappedFile 文件都是存放在该目录中的。即无论当前 Broker 中存放着多少 Topic 的消息，这些消息都是被顺序写入到了 mappedFile 文件中的。"),r("strong",[e._v("这些消息在 Broker 中存放时并没有被按照 Topic 进行分类存放。")])]),e._v(" "),r("p",[e._v("mappedFile 文件内容由一个个的 "),r("strong",[e._v("消息单元")]),e._v(" 构成。每个消息单元中包含消息总长度 MsgLen、消息的物理位置 physicalOffset、消息体内容 Body、消息体长度 BodyLength、消息生产者 BornHost、消息发送时间戳 BornTimestamp、消息主题 Topic、消息所在的队列 QueueId、消息在 Queue 中存储的偏移量 QueueOffset 等近 20 余项消息相关属性。")]),e._v(" "),r("p",[r("img",{attrs:{src:s(892),alt:"image-20230707101402521"}})]),e._v(" "),r("h3",{attrs:{id:"consumequeue-文件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#consumequeue-文件"}},[e._v("#")]),e._v(" consumequeue 文件")]),e._v(" "),r("p",[e._v("由于同一个 topic 的消息并不是连续的存储在 commitlog 中，消费者如果直接从 commitlog 获取消息效率非常低，所以通过 consumequeue 保存 commitlog 中消息的偏移量的物理地址，这样消费者在消费的时候先从 consumequeue 中根据偏移量定位到具体的 commitlog 物理文件，然后根据一定的规则（offset 和文件大小取模）在 commitlog 中快速定位。")]),e._v(" "),r("p",[e._v("为了提高效率，会为每个 Topic 在 "),r("code",[e._v("/store/consumequeue")]),e._v(" 中创建一个目录，目录名为 Topic 名称。在该 Topic 目录下，会再为每个该 Topic 的 Queue 建立一个目录，目录名为 queueId。每个目录中存放着若干 consumequeue 文件，consumequeue 文件是 commitlog 的索引文件，可以根据 consumequeue 定位到具体的消息。")]),e._v(" "),r("p",[e._v("consumequeue 文件名也由 20 位数字构成，表示当前文件的第一个索引条目的起始位移偏移量。和 mappedFile 文件名不同的是，其后续文件名是固定的。因为 consumequeue 文件大小是固定不变的。")]),e._v(" "),r("p",[e._v("consumequeue 文件中存储着一个个的 "),r("strong",[e._v("索引条目")]),e._v("，如下图所示。")]),e._v(" "),r("div",{staticStyle:{"text-align":"center"}},[r("p",[r("img",{attrs:{src:s(893),alt:"image-20230707103444860"}})])]),r("h2",{attrs:{id:"_3-2-消息消费"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-消息消费"}},[e._v("#")]),e._v(" 3.2 消息消费")]),e._v(" "),r("h3",{attrs:{id:"获取消息的方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#获取消息的方式"}},[e._v("#")]),e._v(" 获取消息的方式")]),e._v(" "),r("div",{staticClass:"subtitle"},[r("p",[e._v("拉取式消费")])]),r("p",[e._v("Consumer 主动从 Broker 中拉取消息，主动权由 Consumer 控制。一旦获取了批量消息，就会启动消费过程。不过，该方式的实时性较弱，即 Broker 中有了新的消息时消费者并不能及时发现并消费。")]),e._v(" "),r("p",[e._v("设置该间隔时需要注意平稳：间隔太短，空请求比例会增加；间隔太长，消息的实时性太差。")]),e._v(" "),r("div",{staticClass:"subtitle"},[r("p",[e._v("推送式消费")])]),r("p",[e._v("该模式下 Broker 收到数据后会主动推送给 Consumer。该获取方式一般实时性较高。")]),e._v(" "),r("p",[e._v("该获取方式是典型的 "),r("strong",[e._v("发布-订阅")]),e._v(" 模式，即 Consumer 向其关联的 Queue 注册了监听器，一旦发现有新的消息到来就会触发回调的执行，回调方法是 Consumer 去 Queue 中拉取消息。而这些都是基于 Consumer 与 Broker 间的长连接的。长连接的维护是需要消耗系统资源的。")]),e._v(" "),r("h3",{attrs:{id:"消费消息的模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#消费消息的模式"}},[e._v("#")]),e._v(" 消费消息的模式")]),e._v(" "),r("p",[e._v("消费模型由 Consumer 决定，消费维度为 Topic。默认情况下是集群模式。")]),e._v(" "),r("div",{staticClass:"subtitle"},[r("p",[e._v("集群消费")])]),r("p",[e._v("集群消费模式下，相同 Consumer Group 的每个 Consumer 实例平均分摊同一个 Topic 的消息。即 "),r("strong",[e._v("每条消息")]),e._v(" 只会被发送到 Consumer Group 中的 "),r("strong",[e._v("某个")]),e._v(" Consumer。")]),e._v(" "),r("p",[e._v("消费进度保存在 Broker 中。Consumer Group 中的所有 Consumer 共同消费同一个 Topic 中的消息，同一条消息只会被消费一次。消费进度会参与到了消费的负载均衡中，因此消费进度是需要共享的。")]),e._v(" "),r("div",{staticClass:"subtitle"},[r("p",[e._v("广播消费")])]),r("p",[e._v("广播消费模式下，相同 Consumer Group 的每个 Consumer 实例接收同一个 Topic 的全量消息。即 "),r("strong",[e._v("每条消息")]),e._v(" 都会被发送到 Consumer Group 中的 "),r("strong",[e._v("每个")]),e._v("  Consumer。")]),e._v(" "),r("p",[e._v("消费进度保存在 Consumer 中。Consumer Group 中每个 Consumer 都会消费所有消息，但它们的消费进度是不同。所以 Consumer 各自保存各自的消费进度。")]),e._v(" "),r("h3",{attrs:{id:"rebalance-机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#rebalance-机制"}},[e._v("#")]),e._v(" Rebalance 机制")]),e._v(" "),r("p",[e._v("Rebalance 机制：将⼀个 Topic 下的多个 Queue 在同⼀个 Consumer Group 中的多个 Consumer 间进行重新分配的过程。")]),e._v(" "),r("p",[e._v("Rebalance 机制的本意是为了提升消息的并行消费能力。")]),e._v(" "),r("div",{staticClass:"subtitle"},[r("p",[e._v("Rebalance 的限制")])]),r("p",[e._v("由于⼀个队列最多分配给⼀个消费者，因此当某个消费者组下的消费者实例数量大于队列的数量时，多余的消费者实例将分配不到任何队列。")]),e._v(" "),r("div",{staticClass:"subtitle"},[r("p",[e._v("Rebalance 带来的问题")])]),r("p",[r("strong",[e._v("消费暂停")]),e._v("：在只有一个 Consumer 时，其负责消费所有队列；在新增了一个 Consumer 后会触发 Rebalance 的发生。此时原 Consumer 就需要暂停部分队列的消费，等到这些队列分配给新的 Consumer 后，这些暂停消费的队列才能继续被消费。")]),e._v(" "),r("p",[r("strong",[e._v("消费重复")]),e._v("：Consumer 在消费新分配给自己的队列时，必须接着之前 Consumer 提交的消费进度的 offset 继续消费。然而默认情况下，offset 是异步提交的，这个异步性导致提交到 Broker 的 offset 与 Consumer 实际消费的消息并不一致。这个不一致的差值就是可能会重复消费的消息。")]),e._v(" "),r("p",[r("strong",[e._v("消费突刺")]),e._v("：如果需要重复消费的消息过多，或者因为 Rebalance 暂停时间过长从而导致积压了部分消息。那么有可能会导致在 Rebalance 结束之后瞬间需要消费很多消息。")]),e._v(" "),r("h2",{attrs:{id:"_3-3-负载均衡"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-负载均衡"}},[e._v("#")]),e._v(" 3.3 负载均衡")]),e._v(" "),r("p",[e._v("RocketMQ 是分布式消息服务，负载均衡是在生产者和消费者的客户端完成的。")]),e._v(" "),r("h3",{attrs:{id:"消费者的负载均衡"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#消费者的负载均衡"}},[e._v("#")]),e._v(" 消费者的负载均衡")]),e._v(" "),r("div",{staticClass:"anchor",attrs:{id:"平均分配策略"}},[e._v("平均分配策略")]),r("p",[e._v("根据 avg = QueueCount / ConsumerCount 的计算结果进行分配。如果能够整除，则按顺序将 avg 个 Queue 逐个分配 Consumer；如果不能整除，则将多余出的 Queue 按照 Consumer 顺序逐个分配。")]),e._v(" "),r("div",{staticStyle:{"text-align":"center"}},[r("p",[r("img",{attrs:{src:s(894),alt:"image-20230707112549334"}})])]),r("div",{staticClass:"anchor",attrs:{id:"环形平均策略"}},[e._v("环形平均策略")]),r("p",[e._v("根据消费者的顺序，依次在由 queue 队列组成的环形图中逐个分配。")]),e._v(" "),r("div",{staticStyle:{"text-align":"center"}},[r("p",[r("img",{attrs:{src:s(895),alt:"image-20230707112809935"}})])]),r("div",{staticClass:"anchor",attrs:{id:"一致性哈希"}},[e._v("一致性哈希")]),r("p",[e._v("该算法会将 Consumer 的 hash 值作为 Node 节点存放到 hash 环上，然后将 Queue 的 hash 值也放到 hash 环上，通过顺时针方向，距离 Queue 最近的那个 Consumer 就是该 Queue 要分配的 Consumer。")]),e._v(" "),r("p",[e._v("优点：有效减少由于消费者组扩容或缩容所带来的大量的 Rebalance。")]),e._v(" "),r("div",{staticStyle:{"text-align":"center"}},[r("p",[r("img",{attrs:{src:s(896),alt:"image-20230707113323802"}})])]),r("div",{staticClass:"anchor",attrs:{id:"同机房策略"}},[e._v("同机房策略")]),r("p",[e._v("根据 Queue 的部署机房位置和 Consumer 的位置，过滤出当前 Consumer 相同机房的 Queue。然后按照平均分配策略或环形平均策略对同机房 Queue 进行分配。如果没有同机房 Queue，则按照平均分配策略或环形平均策略对所有 Queue 进行分配。")]),e._v(" "),r("h3",{attrs:{id:"生产者的负载均衡"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#生产者的负载均衡"}},[e._v("#")]),e._v(" 生产者的负载均衡")]),e._v(" "),r("p",[e._v("消息投递算法，常见的有两种：")]),e._v(" "),r("div",{staticClass:"anchor",attrs:{id:"轮询算法"}},[e._v("轮询算法")]),r("p",[e._v("默认选择算法。该算法保证了每个 Queue 中可以均匀的获取到消息。")]),e._v(" "),r("p",[e._v("存在的问题：由于某些原因，在某些 Broker 上的 Queue 可能投递延迟较严重。从而导致 Producer 的缓存队列中出现较大的消息积压，影响消息的投递性能。")]),e._v(" "),r("div",{staticClass:"anchor",attrs:{id:"最小投递延迟算法"}},[e._v("最小投递延迟算法")]),r("p",[e._v("该算法会统计每次消息投递的时间延迟，然后根据统计出的结果将消息投递到时间延迟最小的 Queue。")]),e._v(" "),r("p",[e._v("如果延迟相同，则采用轮询算法投递。该算法可以有效提升消息的投递性能。")]),e._v(" "),r("p",[e._v("存在的问题：消息在 Queue 上的分配不均匀。投递延迟小的 Queue 其可能会存在大量的消息。而对该 Queue 的消费者压力会增大，降低消息的消费能力，可能会导致 MQ 中消息的堆积。")])])}),[],!1,null,null,null);t.default=o.exports},892:function(e,t,s){e.exports=s.p+"assets/img/image-20230707101402521.d643fec0.png"},893:function(e,t,s){e.exports=s.p+"assets/img/image-20230707103444860.e9b27712.png"},894:function(e,t,s){e.exports=s.p+"assets/img/image-20230707112549334.6ceaf466.png"},895:function(e,t,s){e.exports=s.p+"assets/img/image-20230707112809935.5461acd8.png"},896:function(e,t,s){e.exports=s.p+"assets/img/image-20230707113323802.de31e76d.png"}}]);