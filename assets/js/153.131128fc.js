(window.webpackJsonp=window.webpackJsonp||[]).push([[153],{1081:function(v,_,t){"use strict";t.r(_);var s=t(14),r=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"第1章-操作系统概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第1章-操作系统概述"}},[v._v("#")]),v._v(" 第1章 操作系统概述")]),v._v(" "),t("h2",{attrs:{id:"_1-1-操作系统的基本概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-操作系统的基本概念"}},[v._v("#")]),v._v(" 1.1 操作系统的基本概念")]),v._v(" "),t("h3",{attrs:{id:"概念、功能和目标"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概念、功能和目标"}},[v._v("#")]),v._v(" 概念、功能和目标")]),v._v(" "),t("p",[v._v("操作系统（Operating System，OS）是指控制和管理整个 "),t("strong",[v._v("计算机系统的硬件和软件资源")]),v._v("，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便地接口和环境，它是计算机系统中最基本的 "),t("strong",[v._v("系统软件")]),v._v("。")]),v._v(" "),t("p",[t("strong",[v._v("功能和目标：")])]),v._v(" "),t("ul",[t("li",[v._v("作为系统资源的管理者：处理机管理、存储器管理、文件管理、设备管理")]),v._v(" "),t("li",[v._v("作为用户和计算机硬件之间的接口：命令接口、程序接口、GUI（图形用户界面）")]),v._v(" "),t("li",[v._v("作为最接近硬件的层次：实现对硬件机器的拓展")])]),v._v(" "),t("h3",{attrs:{id:"特征"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#特征"}},[v._v("#")]),v._v(" 特征")]),v._v(" "),t("div",{staticClass:"anchor",attrs:{id:"并发"}},[v._v("并发")]),t("p",[t("strong",[v._v("并发")]),v._v(" 指两个或多个事件在同一时间间隔内发生。这些事件 "),t("strong",[v._v("宏观上是同时发生")]),v._v(" 的，但 "),t("strong",[v._v("微观上是交替发生")]),v._v(" 的。")]),v._v(" "),t("blockquote",[t("p",[v._v("并行：指两个或多个事件在同一时刻同时发生。")])]),v._v(" "),t("p",[v._v("操作系统的并发性指计算机系统中同时存在着多个运行着的程序。")]),v._v(" "),t("div",{staticClass:"anchor",attrs:{id:"共享"}},[v._v("共享")]),t("p",[t("strong",[v._v("共享")]),v._v(" 即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。")]),v._v(" "),t("div",{staticClass:"anchor",attrs:{id:"虚拟"}},[v._v("虚拟")]),t("p",[t("strong",[v._v("虚拟")]),v._v(" 是常把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后着）是用户感受到的。")]),v._v(" "),t("ul",[t("li",[v._v("空分复用技术：如虚拟存储技术")]),v._v(" "),t("li",[v._v("时分复用技术：如虚拟处理器技术")])]),v._v(" "),t("div",{staticClass:"anchor",attrs:{id:"异步"}},[v._v("异步")]),t("p",[v._v("// TODO")]),v._v(" "),t("h2",{attrs:{id:"_1-2-操作系统的发展与分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-操作系统的发展与分类"}},[v._v("#")]),v._v(" 1.2 操作系统的发展与分类")]),v._v(" "),t("h3",{attrs:{id:"手工操作阶段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#手工操作阶段"}},[v._v("#")]),v._v(" 手工操作阶段")]),v._v(" "),t("p",[v._v("主要缺点：用户独占全机、人机速度矛盾导致资源利用率极低。")]),v._v(" "),t("h3",{attrs:{id:"批处理阶段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#批处理阶段"}},[v._v("#")]),v._v(" 批处理阶段")]),v._v(" "),t("p",[v._v("单道批处理系统：")]),v._v(" "),t("ul",[t("li",[v._v("主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。")]),v._v(" "),t("li",[v._v("主要缺点：内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序。"),t("strong",[v._v("CPU 有大量的时间是在空闲等待 I/O 完成")]),v._v("。资源利用率依然很低。")])]),v._v(" "),t("p",[v._v("多道批处理系统：")]),v._v(" "),t("ul",[t("li",[v._v("主要优点：多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU 和其他资源保持“忙碌”状态，系统吞吐量增大。")]),v._v(" "),t("li",[v._v("主要缺点：用户响应时间长，"),t("strong",[v._v("没有人机交互功能")]),v._v("（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行）。")])]),v._v(" "),t("h3",{attrs:{id:"分时操作系统"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分时操作系统"}},[v._v("#")]),v._v(" 分时操作系统")]),v._v(" "),t("p",[v._v("分时操作系统：计算机以 "),t("strong",[v._v("时间片")]),v._v(" 为单位轮流为各个用户/作业服务，各个用户可通过终端与其进行交互。")]),v._v(" "),t("ul",[t("li",[v._v("主要优点：用户请求可以被即时响应，"),t("strong",[v._v("解决了人机交互问题")]),v._v("。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。")]),v._v(" "),t("li",[v._v("主要缺点："),t("strong",[v._v("不能优先处理一些紧急任务")]),v._v("。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。")])]),v._v(" "),t("h3",{attrs:{id:"实时操作系统"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实时操作系统"}},[v._v("#")]),v._v(" 实时操作系统")]),v._v(" "),t("p",[v._v("实时操作系统：")]),v._v(" "),t("ul",[t("li",[v._v("主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。")])]),v._v(" "),t("p",[v._v("在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且 "),t("strong",[v._v("要在严格的时限内处理完事件")]),v._v("。实时操作系统的主要特点是 "),t("strong",[v._v("及时性")]),v._v(" 和 "),t("strong",[v._v("可靠性")]),v._v("。")]),v._v(" "),t("h2",{attrs:{id:"_1-3-操作系统的运行机制与体系结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-操作系统的运行机制与体系结构"}},[v._v("#")]),v._v(" 1.3 操作系统的运行机制与体系结构")]),v._v(" "),t("h3",{attrs:{id:"运行机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#运行机制"}},[v._v("#")]),v._v(" 运行机制")]),v._v(" "),t("p",[t("strong",[v._v("两种指令：")])]),v._v(" "),t("ul",[t("li",[v._v("特权指令：不允许用户程序使用。")]),v._v(" "),t("li",[v._v("非特权指令。")])]),v._v(" "),t("p",[t("strong",[v._v("两种处理器状态：")])]),v._v(" "),t("ul",[t("li",[v._v("用户态（目态）：此时 CPU 只能执行非特权指令。")]),v._v(" "),t("li",[v._v("核心态（管态）：特权指令、非特权指令都可执行。")])]),v._v(" "),t("p",[t("strong",[v._v("程序状态字寄存器（PSW）中的某标志位来标识当前处理器处于什么状态")]),v._v("。如 0 为用户态，1 为核心态。")]),v._v(" "),t("p",[t("strong",[v._v("两种程序：")])]),v._v(" "),t("ul",[t("li",[v._v("内核程序：操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态。")]),v._v(" "),t("li",[v._v("应用程序：为了保证系统能安全运行，普通应用程序只能执行非特权指令，运行在用户态。")])]),v._v(" "),t("h3",{attrs:{id:"操作系统内核"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#操作系统内核"}},[v._v("#")]),v._v(" 操作系统内核")]),v._v(" "),t("p",[t("strong",[v._v("内核")]),v._v(" 是计算机上配置的 "),t("strong",[v._v("底层软件")]),v._v("，是操作系统最基本、最核心的部分。实现操作系统内核功能的那些程序就是内核程序。")]),v._v(" "),t("ul",[t("li",[v._v("时钟管理：实现计时功能。")]),v._v(" "),t("li",[v._v("中断处理：负责实现中断机制。")]),v._v(" "),t("li",[v._v("原语：是一种特殊的程序，处于操作系统最底层，是最接近硬件的部分。这种程序的运行具有 "),t("strong",[v._v("原子性")]),v._v("——其运行只能一气呵成，不可中断。运行时间较短、调用频繁。")])]),v._v(" "),t("p",[t("strong",[v._v("大内核")]),v._v("：将操作系统的主要功能模块都作为系统内核，运行在核心态。")]),v._v(" "),t("ul",[t("li",[v._v("优点：高性能。")]),v._v(" "),t("li",[v._v("缺点：内核代码庞大，结构混乱，难以维护。")])]),v._v(" "),t("p",[t("strong",[v._v("微内核")]),v._v("：只把最基本的功能保留在内核。")]),v._v(" "),t("ul",[t("li",[v._v("优点：内核功能少，结构清晰，方便维护。")]),v._v(" "),t("li",[v._v("缺点：需要频繁地在核心态和用户态之间切换，性能低。")])]),v._v(" "),t("h3",{attrs:{id:"中断和异常"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#中断和异常"}},[v._v("#")]),v._v(" 中断和异常")]),v._v(" "),t("p",[v._v("人们通过操作系统作为计算机的管理者，并引入中断机制，从而实现多道程序并发执行。")]),v._v(" "),t("p",[t("strong",[v._v("本质：发生中断就意味着需要操作系统介入，开展管理工作。")])]),v._v(" "),t("blockquote",[t("p",[v._v("“用户态 → 核心态” 的切换是通过 "),t("strong",[v._v("中断")]),v._v(" 实现的，并且中断是唯一途径。")]),v._v(" "),t("p",[v._v("“核心态 → 用户态” 的切换是通过执行一个 "),t("strong",[v._v("特权指令")]),v._v("，将程序状态字（PSW）的标志位设置为“用户态”。")])]),v._v(" "),t("div",{staticClass:"anchor",attrs:{id:"中断的分类"}},[v._v("中断的分类")]),t("ul",[t("li",[v._v("内中断（异常、例外、陷入）：信号的来源是 CPU "),t("strong",[v._v("内部")]),v._v("，与当前执行的指令 "),t("strong",[v._v("有关")]),v._v("。")]),v._v(" "),t("li",[v._v("外中断：信号的来源是 CPU "),t("strong",[v._v("外部")]),v._v("，与当前执行的指令 "),t("strong",[v._v("无关")]),v._v("。")])]),v._v(" "),t("h3",{attrs:{id:"系统调用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#系统调用"}},[v._v("#")]),v._v(" 系统调用")]),v._v(" "),t("p",[v._v("“系统调用” 是指操作系统提供给应用程序（程序员/编程人员）使用的 "),t("strong",[v._v("接口")]),v._v("，可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。")]),v._v(" "),t("div",{staticClass:"anchor",attrs:{id:"底层实现"}},[v._v("底层实现")]),t("p",[v._v("过程：传递系统调用参数 → 执行 "),t("strong",[v._v("陷入指令")]),v._v("（用户态） → 执行 "),t("strong",[v._v("系统调用")]),v._v(" 相应服务程序（核心态） → 返回用户程序。")]),v._v(" "),t("p",[v._v("注意：")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("陷入指令是在用户态执行的")]),v._v("，执行陷入指令之后立即引发一个 "),t("strong",[v._v("内中断")]),v._v("，从而 CPU "),t("strong",[v._v("进入核心态")]),v._v("。")]),v._v(" "),t("li",[v._v("发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行。")]),v._v(" "),t("li",[t("strong",[v._v("陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令。")])])]),v._v(" "),t("blockquote",[t("p",[v._v("陷入指令又叫做自陷指令或访管指令。")])])])}),[],!1,null,null,null);_.default=r.exports}}]);