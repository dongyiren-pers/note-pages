(window.webpackJsonp=window.webpackJsonp||[]).push([[155],{1087:function(v,t,_){"use strict";_.r(t);var s=_(14),e=Object(s.a)({},(function(){var v=this,t=v.$createElement,_=v._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"第3章-过期删除与内存淘汰"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#第3章-过期删除与内存淘汰"}},[v._v("#")]),v._v(" 第3章 过期删除与内存淘汰")]),v._v(" "),_("h2",{attrs:{id:"_3-1-过期删除策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-过期删除策略"}},[v._v("#")]),v._v(" 3.1 过期删除策略")]),v._v(" "),_("p",[v._v("在 Redis 内部，每当设置一个键的过期时间时，Redis 会将该键带上过期时间存放到一个 "),_("strong",[v._v("过期字典")]),v._v(" 中。当查询一个键时，Redis 便首先检查该键是否存在过期字典中，如果存在，那就获取其过期时间。然后将过期时间和当前系统时间进行比对，比系统时间大，那就没有过期；反之判定该键过期。")]),v._v(" "),_("h3",{attrs:{id:"定期删除策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#定期删除策略"}},[v._v("#")]),v._v(" 定期删除策略")]),v._v(" "),_("p",[v._v("使用定时器扫描 key（默认100ms），判断 key 是否过期，过期则删除。")]),v._v(" "),_("p",[_("strong",[v._v("优点")]),v._v("：能够较为及时删除过期的 key。")]),v._v(" "),_("p",[_("strong",[v._v("缺点")]),v._v("：每次都要扫描会非常消耗 CPU 资源；且定时器有间距，有可能出现 key 过期，但是此时定时器还没起，key 仍保存在内存中。")]),v._v(" "),_("h3",{attrs:{id:"惰性删除策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#惰性删除策略"}},[v._v("#")]),v._v(" 惰性删除策略")]),v._v(" "),_("p",[v._v("不主动删除过期键，每次访问 key 时，都检测 key 是否过期，如果过期则删除该 key。")]),v._v(" "),_("p",[_("strong",[v._v("优点")]),v._v("：因为每次访问时，才会检查 key 是否过期，所以此策略只会使用很少的系统资源，因此，惰性删除策略对 CPU 时间最友好。")]),v._v(" "),_("p",[_("strong",[v._v("缺点")]),v._v("：如果一个 key 已经过期，而这个 key 又仍然保留在 Redis 中，那么只要这个过期 key 一直没有被访问，它所占用的内存就不会释放，造成了一定的内存空间浪费。所以，惰性删除策略对内存不友好。")]),v._v(" "),_("blockquote",[_("p",[v._v("Redis 3.2 以前，主库惰性删除后，从库不会触发数据删除，此时还能读到，3.2 以后的版本才改正，返回空值，4.0 后从库才会定时校验过期 key。另外，expire 命令在主库设置 key 的过期时间，到了从库可能有延迟导致过期时间比实际的长，expire 命令表示执行完多久会过期，expireat/pexpireat 命令表示在某一时间点会过期。")])]),v._v(" "),_("p",[_("strong",[v._v("Redis 选择 惰性删除+定期删除 两种策略配合使用")]),v._v("，定期删除策略不在是每次都扫描全部 key，而是随机抽取一部分 key 进行检查，再配合惰性删除策略，以求在合理使用 CPU 和避免内存浪费之间取得平衡。")]),v._v(" "),_("h2",{attrs:{id:"_3-2-内存淘汰策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-内存淘汰策略"}},[v._v("#")]),v._v(" 3.2 内存淘汰策略")]),v._v(" "),_("p",[v._v("Redis 的运行内存达到了某个阀值时，就会触发 "),_("strong",[v._v("内存淘汰机制")]),v._v("，这个阀值就是我们设置的最大运行内存，此值在 Redis 的配置文件中可以找到，配置项为 maxmemory。")]),v._v(" "),_("p",[_("strong",[v._v("写入数据将导致超出 maxmemory 限制时，Redis 采用 maxmemory-policy 指定的策略进行数据淘汰。")])]),v._v(" "),_("p",[v._v("默认的淘汰策略是当内存满了之后，新写入操作会报错。其他淘汰策略，分为两种，一种是 "),_("strong",[v._v("在设置了过期时间的数据中进行淘汰")]),v._v("，一种是在 "),_("strong",[v._v("在所有数据范围内进行淘汰")]),v._v("。")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[_("strong",[v._v("策略")])]),v._v(" "),_("th",[_("strong",[v._v("描述")])]),v._v(" "),_("th",[_("strong",[v._v("版本")])])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("noeviction")]),v._v(" "),_("td",[v._v("直接返回错误")]),v._v(" "),_("td")]),v._v(" "),_("tr",[_("td",[v._v("volatile-ttl")]),v._v(" "),_("td",[v._v("从设置了过期时间的键中，选择过期时间最早的键，进行淘汰")]),v._v(" "),_("td")]),v._v(" "),_("tr",[_("td",[v._v("volatile-random")]),v._v(" "),_("td",[v._v("从设置了过期时间的键中，随机选择键，进行淘汰")]),v._v(" "),_("td")]),v._v(" "),_("tr",[_("td",[v._v("volatile-lru")]),v._v(" "),_("td",[v._v("从设置了过期时间的键中，使用 LRU 算法选择键，进行淘汰")]),v._v(" "),_("td")]),v._v(" "),_("tr",[_("td",[v._v("volatile-lfu")]),v._v(" "),_("td",[v._v("从设置了过期时间的键中，使用 LFU 算法选择键，进行淘汰")]),v._v(" "),_("td",[v._v("4.0")])]),v._v(" "),_("tr",[_("td",[v._v("allleys-random")]),v._v(" "),_("td",[v._v("从所有的键中，随机选择键，进行淘汰")]),v._v(" "),_("td")]),v._v(" "),_("tr",[_("td",[v._v("allkeys-lru")]),v._v(" "),_("td",[v._v("从所有的键中，使用 LRU 算法选择键，进行淘汰")]),v._v(" "),_("td")]),v._v(" "),_("tr",[_("td",[v._v("allkeys-lfu")]),v._v(" "),_("td",[v._v("从所有的键中，使用 LFU 算法选择键，进行淘汰")]),v._v(" "),_("td",[v._v("4.0")])])])]),v._v(" "),_("blockquote",[_("p",[v._v("TTL：Time To Live，生存时间。")])]),v._v(" "),_("h3",{attrs:{id:"lru-淘汰策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#lru-淘汰策略"}},[v._v("#")]),v._v(" LRU 淘汰策略")]),v._v(" "),_("div",{staticClass:"subtitle"},[_("p",[v._v("什么是 LRU 算法")])]),_("p",[_("strong",[v._v("LRU")]),v._v(" 全称是 Least Recently Used 翻译为 "),_("strong",[v._v("最近最少使用")]),v._v("，会选择淘汰最近最少使用的数据。")]),v._v(" "),_("p",[v._v("传统 LRU 算法的实现基于 "),_("strong",[v._v("链表")]),v._v("，元素按照操作顺序从前往后排列，最新操作的键会被移动到表头。需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素。")]),v._v(" "),_("p",[v._v("Redis 并没有使用这样的方式实现 LRU 算法，因为传统的 LRU 算法存在两个问题：")]),v._v(" "),_("ul",[_("li",[v._v("需要用链表管理所有的缓存数据，这会带来额外的空间开销；")]),v._v(" "),_("li",[v._v("如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 Redis 缓存性能。")])]),v._v(" "),_("div",{staticClass:"subtitle"},[_("p",[v._v("Redis 的实现")])]),_("p",[v._v("Redis 实现的是一种 "),_("strong",[v._v("近似 LRU 算法")]),v._v("，目的是为了更好的节约内存，"),_("strong",[v._v("实现方式是在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间")]),v._v("。")]),v._v(" "),_("p",[v._v("Redis 进行内存淘汰时，会使用 "),_("strong",[v._v("随机采样的方式来淘汰数据")]),v._v("，随机取 N 个值（此值可配置），然后 "),_("strong",[v._v("淘汰最久没有使用的那个")]),v._v("。")]),v._v(" "),_("blockquote",[_("p",[v._v("N 的值由 maxmemory-samples 决定。")])]),v._v(" "),_("p",[v._v("LRU 算法有一个问题，"),_("strong",[v._v("无法解决缓存污染问题")]),v._v("，比如一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在 Redis 缓存中很长一段时间，造成缓存污染。")]),v._v(" "),_("h3",{attrs:{id:"lfu-淘汰策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#lfu-淘汰策略"}},[v._v("#")]),v._v(" LFU 淘汰策略")]),v._v(" "),_("div",{staticClass:"subtitle"},[_("p",[v._v("什么是 LFU 算法")])]),_("p",[v._v("LFU 全称是 Least Frequently Used 翻译为 "),_("strong",[v._v("最近最不常用的")]),v._v("，LFU 算法是根据数据访问次数来淘汰数据的，它的核心思想是 “如果数据过去被访问多次，那么将来被访问的频率也更高”。")]),v._v(" "),_("p",[v._v("LFU 算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。这样就解决了偶尔被访问一次之后，数据留存在缓存中很长一段时间的问题，相比于 LRU 算法更合理一些。")]),v._v(" "),_("div",{staticClass:"subtitle"},[_("p",[v._v("Redis 的实现")])]),_("p",[v._v("Redis 对象头中的 lru 字段，在 LRU 算法下和 LFU 算法下使用方式并不相同。")]),v._v(" "),_("p",[_("strong",[v._v("在 LRU 算法中")]),v._v("，Redis 对象头的 24 bits 的 lru 字段是记录 key 的访问时间戳。")]),v._v(" "),_("p",[_("strong",[v._v("在 LFU 算法中")]),v._v("，Redis 对象头的 24 bits 的 lru 字段被分成两段来存储，高 16bit 存储 ldt（Last Decrement Time）记录 key 的访问时间戳；低 8bit 存储 logc（Logistic Counter）记录 key 的访问频次。")])])}),[],!1,null,null,null);t.default=e.exports}}]);