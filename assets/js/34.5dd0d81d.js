(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{1006:function(t,a,r){"use strict";r.r(a);var s=r(14),_=Object(s.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"第5章-分布式事务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#第5章-分布式事务"}},[t._v("#")]),t._v(" 第5章 分布式事务")]),t._v(" "),s("h2",{attrs:{id:"_5-2-基于-xa-协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-基于-xa-协议"}},[t._v("#")]),t._v(" 5.2 基于 XA 协议")]),t._v(" "),s("h3",{attrs:{id:"xa-协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#xa-协议"}},[t._v("#")]),t._v(" XA 协议")]),t._v(" "),s("p",[t._v("XA 协议是一个 "),s("strong",[t._v("基于数据库")]),t._v(" 的分布式事务协议，其分为两部分：事务管理器（Transaction Manager）和本地资源管理器（Resource Manager）。事务管理器作为一个全局的调度者，负责对各个本地资源管理器统一号令提交或者回滚。二阶提交协议（2PC）和三阶提交协议（3PC）就是根据此协议衍生出来而来。主流的诸如 Oracle、MySQL 等数据库均已实现了 XA 接口。")]),t._v(" "),s("h3",{attrs:{id:"两段提交-2pc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#两段提交-2pc"}},[t._v("#")]),t._v(" 两段提交（2PC）")]),t._v(" "),s("p",[t._v("引入一个作为 "),s("strong",[t._v("协调者（coordinator）")]),t._v(" 的组件来统一掌控所有 "),s("strong",[t._v("参与者（participant）")]),t._v(" 的操作结果，并最终指示这些节点是否要把操作结果进行真正的提交。")]),t._v(" "),s("ul",[s("li",[t._v("**第一阶段：准备阶段。**协调者向所有参与者发送 REQUEST-TO-PREPARE，当参与者收到 REQUEST-TO-PREPARE 消息后，它向协调者发送消息 PREPARED 或者 NO，表示事务是否准备好；如果发送的是 NO，那么事务要回滚；")]),t._v(" "),s("li",[t._v("**第二阶段：提交阶段。**协调者收集所有参与者的返回消息，如果所有的参与者都回复的是 PREPARED，那么协调者向所有参与者发送 COMMIT 消息；否则，协调者向所有回复 PREPARED 的参与者发送 ABORT 消息；参与者如果回复了 PREPARED 消息并且收到协调者发来的 COMMIT 消息，或者它收到 ABORT 消息，它将执行提交或回滚，并向协调者发送 DONE 消息以确认。")])]),t._v(" "),s("p",[s("img",{attrs:{src:r(623),alt:"img"}})]),t._v(" "),s("p",[t._v("二阶段提交看似能够提供原子性的操作，但它存在着严重的缺陷：")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("网络抖动导致的数据不一致")]),t._v("：第二阶段中协调者向参与者发送 commit 命令之后，一旦此时发生网络抖动，导致一部分参与者接收到了 commit 请求并执行，可其他未接到 commit 请求的参与者无法执行事务提交。进而导致整个分布式系统出现了数据不一致。")]),t._v(" "),s("li",[s("strong",[t._v("超时导致的同步阻塞问题")]),t._v("：2PC 中的所有的参与者节点都为事务阻塞型，当某一个参与者节点出现通信超时，其余参与者都会被动阻塞占用资源不能释放。")]),t._v(" "),s("li",[s("strong",[t._v("单点故障的风险")]),t._v("：由于严重地依赖协调者，一旦协调者发生故障，而此时参与者还都处于锁定资源的状态，无法完成事务 commit 操作。虽然协调者出现故障后，会重新选举一个协调者，可无法解决因前一个协调者宕机导致的参与者处于阻塞状态的问题。")])]),t._v(" "),s("h3",{attrs:{id:"三段提交-3pc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三段提交-3pc"}},[t._v("#")]),t._v(" 三段提交（3PC）")]),t._v(" "),s("p",[t._v("3PC 的三个阶段分别是 CanCommit、PreCommit、DoCommit：")]),t._v(" "),s("ul",[s("li",[t._v("**第一阶段：CanCommit。**协调者向所有参与者发送 CanCommit 命令，询问是否可以执行事务提交操作。如果全部响应 YES 则进入下一个阶段。")]),t._v(" "),s("li",[t._v("**第二阶段：PreCommit。**协调者向所有参与者发送 PreCommit 命令，询问是否可以进行事务的预提交操作，参与者接收到 PreCommit 请求后，如参与者成功的执行了事务操作，则返回 Yes 响应，进入最终 commit 阶段。一旦参与者中有向协调者发送了 No 响应，或因网络造成超时，协调者没有接到参与者的响应，协调者向所有参与者发送 abort 请求，参与者接受 abort 命令执行事务的中断。")]),t._v(" "),s("li",[s("strong",[t._v("第三阶段：DoCommit。")]),t._v("：在前两个阶段中所有参与者的响应反馈均是 YES 后，协调者向参与者发送 DoCommit 命令正式提交事务，如协调者没有接收到参与者发送的 ACK 响应，会向所有参与者发送 abort 请求命令，执行事务的中断。")])]),t._v(" "),s("p",[s("img",{attrs:{src:r(624),alt:"img"}})]),t._v(" "),s("h2",{attrs:{id:"_5-3-基于补偿"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-基于补偿"}},[t._v("#")]),t._v(" 5.3 基于补偿")]),t._v(" "),s("h3",{attrs:{id:"tcc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcc"}},[t._v("#")]),t._v(" TCC")]),t._v(" "),s("p",[t._v("TCC（Try-Confirm-Cancel）又被称补偿事务，TCC 与 2PC 的思想很相似，事务处理流程也很相似，但 "),s("strong",[t._v("2PC 是应用于在 DB 层面，TCC 则可以理解为在应用层面的 2PC，是需要我们编写业务逻辑来实现。")])]),t._v(" "),s("p",[t._v('TCC 它的核心思想是："针对每个操作都要注册一个与其对应的确认（Try）和补偿（Cancel）"。')]),t._v(" "),s("div",{staticClass:"anchor",attrs:{id:"tcc-的问题"}},[t._v("TCC 的问题")]),s("p",[t._v("1、空回滚")]),t._v(" "),s("p",[t._v("当一个分支事务所在的服务发生宕机或者网络异常导致调用失败，并未执行 try 方法，当恢复后事务执行回滚操作就会调用此分支事务的 cancel 方法，如果 cancel 方法不能处理此种情况就会出现空回滚。")]),t._v(" "),s("p",[t._v("解决方法就是当主业务发起事务时，生成一个全局事务记录，并生成一个全局唯一 ID，贯穿整个事务，再创建一张分支事务记录表，用于记录分支事务，try 执行时将全局事务 ID 和分支事务 ID 存入分支事务表中，表示执行了 try 阶段，当 cancel 执行时，先判断表中是否有该全局事务 ID 的数据，如果有则回滚，否则不做任何操作。比如 seata 的 AT 模式中就有分支事务表。")]),t._v(" "),s("p",[t._v("2、幂等问题")]),t._v(" "),s("p",[t._v("由于服务宕机或者网络问题，方法的调用可能出现超时，为了保证事务正常执行我们往往会加入重试的机制，因此就需要保证 confirm 和 cancel 阶段操作的幂等性。")]),t._v(" "),s("p",[t._v("我们可以在分支事务记录表中增加事务执行状态，每次执行 confirm 和 cancel 方法时都查询该事务的执行状态，以此判断事务的幂等性。")]),t._v(" "),s("p",[t._v("3、悬挂问题")]),t._v(" "),s("p",[t._v("TCC 中，在调用 try 之前会先注册分支事务，注册分支事务之后，调用出现超时，此时 try 请求还未到达对应的服务，因为调用超时了，所以会执行 cancel 调用，此时 cancel 已经执行完了，然而这个时候 try 请求到达了，这个时候执行了 try 之后就没有后续的操作了，就会导致资源挂起，无法释放。")]),t._v(" "),s("p",[t._v("执行 try 方法时我们可以借助分支事务表中事务的执行状态判断 confirm 或者 cancel 方法是否执行，如果执行了那么就不执行 try 阶段。")]),t._v(" "),s("h3",{attrs:{id:"saga"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#saga"}},[t._v("#")]),t._v(" Saga")]),t._v(" "),s("p",[t._v("Saga 是由一系列的本地事务构成。每一个本地事务在更新完数据库之后，会发布一条消息或者一个事件来触发 Saga 中的下一个本地事务的执行。如果一个本地事务因为某些业务规则无法满足而失败，Saga 会执行在这个失败的事务之前成功提交的所有事务的补偿操作。")]),t._v(" "),s("div",{staticClass:"anchor",attrs:{id:"基于事件的方式"}},[t._v("基于事件的方式")]),s("p",[t._v("在基于事件的方式中，一个服务执行完本地事务之后，会产生一个事件。其它服务会监听这个事件，触发该服务本地事务的执行，并产生新的事件。")]),t._v(" "),s("p",[s("strong",[t._v("缺点")]),t._v("：这种方式如果涉及比较多的业务参与方，则比较容易失控。各业务参与方可随意监听对方的消息，以至于最后没人知道到底有哪些系统在监听哪些消息。更悲催的是，这个模式还可能产生环形监听，即两个业务方相互监听对方所产生的事件。")]),t._v(" "),s("div",{staticClass:"anchor",attrs:{id:"基于命令的方式"}},[t._v("基于命令的方式")]),s("p",[t._v("在基于命令的方式中，我们会定义一个新的服务，即协调中心。协调中心通过命令/回复的方式来和 Saga 中其它服务进行交互。")]),t._v(" "),s("p",[s("strong",[t._v("缺点")]),t._v("：需要维护协调中心，而这个协调中心并不属于任何业务方。")]),t._v(" "),s("h2",{attrs:{id:"_5-4-基于最终一致性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-基于最终一致性"}},[t._v("#")]),t._v(" 5.4 基于最终一致性")]),t._v(" "),s("h3",{attrs:{id:"本地消息表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#本地消息表"}},[t._v("#")]),t._v(" 本地消息表")]),t._v(" "),s("p",[t._v("本地消息表的核心思路是将分布式事务拆分成本地事务进行处理。")]),t._v(" "),s("p",[t._v("通过在事务主动发起方额外新建事务消息表，事务发起方处理业务和记录事务消息在本地事务中完成，轮询事务消息表的数据发送事务消息，事务被动方基于消息中间件消费事务消息表中的事务。")]),t._v(" "),s("p",[s("img",{attrs:{src:r(625),alt:"image-20230906164219929"}})]),t._v(" "),s("h3",{attrs:{id:"消息队列事务"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消息队列事务"}},[t._v("#")]),t._v(" 消息队列事务")]),t._v(" "),s("blockquote",[s("p",[t._v("基于 MQ 的分布式事务方案其实是对本地消息表的封装，将本地消息表基于 MQ 内部，其他方面的协议基本与本地消息表一致。")])]),t._v(" "),s("p",[t._v("MQ事务方案整体流程和本地消息表的流程很相似，如下图：")]),t._v(" "),s("p",[s("img",{attrs:{src:r(626),alt:"image-20230906164451052"}})]),t._v(" "),s("h3",{attrs:{id:"最大努力通知"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#最大努力通知"}},[t._v("#")]),t._v(" 最大努力通知")]),t._v(" "),s("p",[s("img",{attrs:{src:r(627),alt:"image-20230906165000030"}})])])}),[],!1,null,null,null);a.default=_.exports},623:function(t,a,r){t.exports=r.p+"assets/img/arch-z-transection-4.14b70c4d.jpg"},624:function(t,a,r){t.exports=r.p+"assets/img/arch-z-transection-5.39746527.png"},625:function(t,a,r){t.exports=r.p+"assets/img/image-20230906164219929.e6fbf496.png"},626:function(t,a,r){t.exports=r.p+"assets/img/image-20230906164451052.50a93a9c.png"},627:function(t,a,r){t.exports=r.p+"assets/img/image-20230906165000030.514c49be.png"}}]);