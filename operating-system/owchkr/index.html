<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第3章 内存管理 | 后端技术栈笔记</title>
    <meta name="generator" content="VuePress 1.9.7">
    <script src="/note-pages//s0.pstatp.com/cdn/expire-1-M/jquery/3.4.0/jquery.min.js"></script>
    <script src="/note-pages//s0.pstatp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.js"></script>
    <link rel="stylesheet" href="/note-pages//s0.pstatp.com/cdn/expire-1-M/fancybox/3.5.7/jquery.fancybox.min.css">
    <meta name="description" content="BackEnd Notes">
    
    <link rel="preload" href="/note-pages/assets/css/0.styles.167a34c7.css" as="style"><link rel="preload" href="/note-pages/assets/js/app.05dcbd87.js" as="script"><link rel="preload" href="/note-pages/assets/js/3.4a2f67fd.js" as="script"><link rel="preload" href="/note-pages/assets/js/2.ab82720e.js" as="script"><link rel="preload" href="/note-pages/assets/js/4.550e6883.js" as="script"><link rel="prefetch" href="/note-pages/assets/js/10.e11a80d9.js"><link rel="prefetch" href="/note-pages/assets/js/100.489cf69a.js"><link rel="prefetch" href="/note-pages/assets/js/101.560e37ea.js"><link rel="prefetch" href="/note-pages/assets/js/102.baaa4f6a.js"><link rel="prefetch" href="/note-pages/assets/js/103.262b6423.js"><link rel="prefetch" href="/note-pages/assets/js/104.ac33d7ce.js"><link rel="prefetch" href="/note-pages/assets/js/105.5e6ce18f.js"><link rel="prefetch" href="/note-pages/assets/js/106.a69322ef.js"><link rel="prefetch" href="/note-pages/assets/js/107.6cdb78ee.js"><link rel="prefetch" href="/note-pages/assets/js/108.1d720289.js"><link rel="prefetch" href="/note-pages/assets/js/109.58f7297c.js"><link rel="prefetch" href="/note-pages/assets/js/11.241a46da.js"><link rel="prefetch" href="/note-pages/assets/js/110.9cef761d.js"><link rel="prefetch" href="/note-pages/assets/js/111.c782138c.js"><link rel="prefetch" href="/note-pages/assets/js/112.40cb3b1a.js"><link rel="prefetch" href="/note-pages/assets/js/113.c367e40a.js"><link rel="prefetch" href="/note-pages/assets/js/114.a4a75db5.js"><link rel="prefetch" href="/note-pages/assets/js/115.a73cd469.js"><link rel="prefetch" href="/note-pages/assets/js/116.ad853155.js"><link rel="prefetch" href="/note-pages/assets/js/117.a82b2649.js"><link rel="prefetch" href="/note-pages/assets/js/118.8f896dd0.js"><link rel="prefetch" href="/note-pages/assets/js/119.374482b1.js"><link rel="prefetch" href="/note-pages/assets/js/12.ebe220d5.js"><link rel="prefetch" href="/note-pages/assets/js/120.89698284.js"><link rel="prefetch" href="/note-pages/assets/js/121.cbe50685.js"><link rel="prefetch" href="/note-pages/assets/js/122.7de2ac51.js"><link rel="prefetch" href="/note-pages/assets/js/123.a2d16009.js"><link rel="prefetch" href="/note-pages/assets/js/124.e1ba7cbe.js"><link rel="prefetch" href="/note-pages/assets/js/125.4e1e6d6a.js"><link rel="prefetch" href="/note-pages/assets/js/126.3db22af3.js"><link rel="prefetch" href="/note-pages/assets/js/127.937f4ffc.js"><link rel="prefetch" href="/note-pages/assets/js/128.0bad2e20.js"><link rel="prefetch" href="/note-pages/assets/js/129.75a99d25.js"><link rel="prefetch" href="/note-pages/assets/js/13.5ee7bef5.js"><link rel="prefetch" href="/note-pages/assets/js/130.599b6d3d.js"><link rel="prefetch" href="/note-pages/assets/js/131.687214bf.js"><link rel="prefetch" href="/note-pages/assets/js/132.8295c067.js"><link rel="prefetch" href="/note-pages/assets/js/133.854d61c0.js"><link rel="prefetch" href="/note-pages/assets/js/134.f3fc20e1.js"><link rel="prefetch" href="/note-pages/assets/js/135.2a5a690d.js"><link rel="prefetch" href="/note-pages/assets/js/136.6ba30378.js"><link rel="prefetch" href="/note-pages/assets/js/137.80d7c511.js"><link rel="prefetch" href="/note-pages/assets/js/138.0a25898e.js"><link rel="prefetch" href="/note-pages/assets/js/139.fb3c377f.js"><link rel="prefetch" href="/note-pages/assets/js/14.a561f8b3.js"><link rel="prefetch" href="/note-pages/assets/js/140.cbfdbe32.js"><link rel="prefetch" href="/note-pages/assets/js/141.c09f054f.js"><link rel="prefetch" href="/note-pages/assets/js/142.723bd973.js"><link rel="prefetch" href="/note-pages/assets/js/143.b31785f9.js"><link rel="prefetch" href="/note-pages/assets/js/144.69d3d121.js"><link rel="prefetch" href="/note-pages/assets/js/145.c4ee6aa0.js"><link rel="prefetch" href="/note-pages/assets/js/146.7f836a1c.js"><link rel="prefetch" href="/note-pages/assets/js/147.d4a57976.js"><link rel="prefetch" href="/note-pages/assets/js/148.b15e75eb.js"><link rel="prefetch" href="/note-pages/assets/js/149.94085ddc.js"><link rel="prefetch" href="/note-pages/assets/js/15.4ed118f1.js"><link rel="prefetch" href="/note-pages/assets/js/150.6751d41b.js"><link rel="prefetch" href="/note-pages/assets/js/151.bd60e322.js"><link rel="prefetch" href="/note-pages/assets/js/152.15caf78f.js"><link rel="prefetch" href="/note-pages/assets/js/153.131128fc.js"><link rel="prefetch" href="/note-pages/assets/js/154.b8ee2e7d.js"><link rel="prefetch" href="/note-pages/assets/js/155.8fa1e2e0.js"><link rel="prefetch" href="/note-pages/assets/js/156.25e2a796.js"><link rel="prefetch" href="/note-pages/assets/js/157.7137c9c3.js"><link rel="prefetch" href="/note-pages/assets/js/158.fdc18c40.js"><link rel="prefetch" href="/note-pages/assets/js/159.0dadb745.js"><link rel="prefetch" href="/note-pages/assets/js/16.818fc8bf.js"><link rel="prefetch" href="/note-pages/assets/js/160.05f7541c.js"><link rel="prefetch" href="/note-pages/assets/js/161.2a8c62a2.js"><link rel="prefetch" href="/note-pages/assets/js/162.5b9983b7.js"><link rel="prefetch" href="/note-pages/assets/js/163.b51a5538.js"><link rel="prefetch" href="/note-pages/assets/js/164.06c9f20a.js"><link rel="prefetch" href="/note-pages/assets/js/165.c25063f4.js"><link rel="prefetch" href="/note-pages/assets/js/166.6c570da5.js"><link rel="prefetch" href="/note-pages/assets/js/167.12fb6fb6.js"><link rel="prefetch" href="/note-pages/assets/js/168.d7dd27bc.js"><link rel="prefetch" href="/note-pages/assets/js/169.27f575fe.js"><link rel="prefetch" href="/note-pages/assets/js/17.9daf0c47.js"><link rel="prefetch" href="/note-pages/assets/js/170.ba4295ef.js"><link rel="prefetch" href="/note-pages/assets/js/171.3fb54078.js"><link rel="prefetch" href="/note-pages/assets/js/18.086ed162.js"><link rel="prefetch" href="/note-pages/assets/js/19.adca670c.js"><link rel="prefetch" href="/note-pages/assets/js/20.2e9ff004.js"><link rel="prefetch" href="/note-pages/assets/js/21.07830947.js"><link rel="prefetch" href="/note-pages/assets/js/22.609929cb.js"><link rel="prefetch" href="/note-pages/assets/js/23.d83b832f.js"><link rel="prefetch" href="/note-pages/assets/js/24.592e8014.js"><link rel="prefetch" href="/note-pages/assets/js/25.9d28bb6f.js"><link rel="prefetch" href="/note-pages/assets/js/26.fd4195d5.js"><link rel="prefetch" href="/note-pages/assets/js/27.ca60e875.js"><link rel="prefetch" href="/note-pages/assets/js/28.c2cd75e6.js"><link rel="prefetch" href="/note-pages/assets/js/29.4213d132.js"><link rel="prefetch" href="/note-pages/assets/js/30.c6ee0ead.js"><link rel="prefetch" href="/note-pages/assets/js/31.eea6a542.js"><link rel="prefetch" href="/note-pages/assets/js/32.1ffdceaf.js"><link rel="prefetch" href="/note-pages/assets/js/33.0425748b.js"><link rel="prefetch" href="/note-pages/assets/js/34.5dd0d81d.js"><link rel="prefetch" href="/note-pages/assets/js/35.773df14e.js"><link rel="prefetch" href="/note-pages/assets/js/36.5db32ea2.js"><link rel="prefetch" href="/note-pages/assets/js/37.1106162c.js"><link rel="prefetch" href="/note-pages/assets/js/38.793ba7d0.js"><link rel="prefetch" href="/note-pages/assets/js/39.488fb9a5.js"><link rel="prefetch" href="/note-pages/assets/js/40.9c05b0ae.js"><link rel="prefetch" href="/note-pages/assets/js/41.ae198526.js"><link rel="prefetch" href="/note-pages/assets/js/42.d815456e.js"><link rel="prefetch" href="/note-pages/assets/js/43.1808aff8.js"><link rel="prefetch" href="/note-pages/assets/js/44.c26d9bde.js"><link rel="prefetch" href="/note-pages/assets/js/45.fae5f755.js"><link rel="prefetch" href="/note-pages/assets/js/46.703057c9.js"><link rel="prefetch" href="/note-pages/assets/js/47.ed3a23ce.js"><link rel="prefetch" href="/note-pages/assets/js/48.c5a46ee8.js"><link rel="prefetch" href="/note-pages/assets/js/49.b04c1681.js"><link rel="prefetch" href="/note-pages/assets/js/5.869d288f.js"><link rel="prefetch" href="/note-pages/assets/js/50.249fc2a7.js"><link rel="prefetch" href="/note-pages/assets/js/51.cab74632.js"><link rel="prefetch" href="/note-pages/assets/js/52.e2f231b3.js"><link rel="prefetch" href="/note-pages/assets/js/53.6241e308.js"><link rel="prefetch" href="/note-pages/assets/js/54.7d29c5c0.js"><link rel="prefetch" href="/note-pages/assets/js/55.a9050f95.js"><link rel="prefetch" href="/note-pages/assets/js/56.75828a09.js"><link rel="prefetch" href="/note-pages/assets/js/57.b3f75d67.js"><link rel="prefetch" href="/note-pages/assets/js/58.0cf3bd1c.js"><link rel="prefetch" href="/note-pages/assets/js/59.19f18f1f.js"><link rel="prefetch" href="/note-pages/assets/js/6.d879438f.js"><link rel="prefetch" href="/note-pages/assets/js/60.61940d92.js"><link rel="prefetch" href="/note-pages/assets/js/61.bc890bb0.js"><link rel="prefetch" href="/note-pages/assets/js/62.f487437c.js"><link rel="prefetch" href="/note-pages/assets/js/63.4a91369b.js"><link rel="prefetch" href="/note-pages/assets/js/64.1b0770e4.js"><link rel="prefetch" href="/note-pages/assets/js/65.b56e2b22.js"><link rel="prefetch" href="/note-pages/assets/js/66.dd49594c.js"><link rel="prefetch" href="/note-pages/assets/js/67.22efede4.js"><link rel="prefetch" href="/note-pages/assets/js/68.0d22a8a4.js"><link rel="prefetch" href="/note-pages/assets/js/69.aec9bfeb.js"><link rel="prefetch" href="/note-pages/assets/js/7.e3626849.js"><link rel="prefetch" href="/note-pages/assets/js/70.0c53c20d.js"><link rel="prefetch" href="/note-pages/assets/js/71.6d6db7d6.js"><link rel="prefetch" href="/note-pages/assets/js/72.fdcfb985.js"><link rel="prefetch" href="/note-pages/assets/js/73.a390b48d.js"><link rel="prefetch" href="/note-pages/assets/js/74.e817987f.js"><link rel="prefetch" href="/note-pages/assets/js/75.f144cf4f.js"><link rel="prefetch" href="/note-pages/assets/js/76.7be2f5f1.js"><link rel="prefetch" href="/note-pages/assets/js/77.6568d596.js"><link rel="prefetch" href="/note-pages/assets/js/78.4ff63ca8.js"><link rel="prefetch" href="/note-pages/assets/js/79.daaf791e.js"><link rel="prefetch" href="/note-pages/assets/js/8.f9f716a1.js"><link rel="prefetch" href="/note-pages/assets/js/80.a0605696.js"><link rel="prefetch" href="/note-pages/assets/js/81.ecb125f5.js"><link rel="prefetch" href="/note-pages/assets/js/82.b64b1c42.js"><link rel="prefetch" href="/note-pages/assets/js/83.d13b7f19.js"><link rel="prefetch" href="/note-pages/assets/js/84.c584da75.js"><link rel="prefetch" href="/note-pages/assets/js/85.7992353f.js"><link rel="prefetch" href="/note-pages/assets/js/86.17ad6399.js"><link rel="prefetch" href="/note-pages/assets/js/87.289f9f2f.js"><link rel="prefetch" href="/note-pages/assets/js/88.3496d6e2.js"><link rel="prefetch" href="/note-pages/assets/js/89.0d0c778d.js"><link rel="prefetch" href="/note-pages/assets/js/9.3209071f.js"><link rel="prefetch" href="/note-pages/assets/js/90.245b9fda.js"><link rel="prefetch" href="/note-pages/assets/js/91.806af5f2.js"><link rel="prefetch" href="/note-pages/assets/js/92.8a10f401.js"><link rel="prefetch" href="/note-pages/assets/js/93.ea90ae18.js"><link rel="prefetch" href="/note-pages/assets/js/94.98cc66ef.js"><link rel="prefetch" href="/note-pages/assets/js/95.836e96c5.js"><link rel="prefetch" href="/note-pages/assets/js/96.d4dd3eee.js"><link rel="prefetch" href="/note-pages/assets/js/97.e4275cb9.js"><link rel="prefetch" href="/note-pages/assets/js/98.0e320d92.js"><link rel="prefetch" href="/note-pages/assets/js/99.e6f77650.js">
    <link rel="stylesheet" href="/note-pages/assets/css/0.styles.167a34c7.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/note-pages/" class="home-link router-link-active"><!----> <span class="site-name">后端技术栈笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/note-pages/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础知识" class="dropdown-title"><span class="title">基础知识</span> <span class="arrow down"></span></button> <button type="button" aria-label="基础知识" class="mobile-dropdown-title"><span class="title">基础知识</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          算法
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/algorithm/5e022a/" class="nav-link">
  算法
</a></li></ul></li><li class="dropdown-item"><h4>
          计算机网络
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/network/a918ca/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-subitem"><a href="/note-pages/http/" class="nav-link">
  HTTP
</a></li><li class="dropdown-subitem"><a href="/note-pages/tcp-ip/" class="nav-link">
  TCP/IP
</a></li><li class="dropdown-subitem"><a href="/note-pages/socket/" class="nav-link">
  Socket
</a></li></ul></li><li class="dropdown-item"><h4>
          操作系统
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/operating-system/knuk3x/" class="nav-link">
  操作系统
</a></li><li class="dropdown-subitem"><a href="/note-pages/linux/" class="nav-link">
  Linux
</a></li></ul></li><li class="dropdown-item"><h4>
          其他
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/database-system/fyl5c1/" class="nav-link">
  数据库系统
</a></li><li class="dropdown-subitem"><a href="/note-pages/computer-systems/" class="nav-link">
  计算机系统
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程语言" class="dropdown-title"><span class="title">编程语言</span> <span class="arrow down"></span></button> <button type="button" aria-label="编程语言" class="mobile-dropdown-title"><span class="title">编程语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          Java
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/java/5ddf72/" class="nav-link">
  Java基础
</a></li><li class="dropdown-subitem"><a href="/note-pages/java-collection/" class="nav-link">
  Java集合
</a></li><li class="dropdown-subitem"><a href="/note-pages/java-concurrency/" class="nav-link">
  Java并发
</a></li><li class="dropdown-subitem"><a href="/note-pages/jvm/" class="nav-link">
  JVM
</a></li></ul></li><li class="dropdown-item"><h4>
          C/C++
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/cpp/" class="nav-link">
  C++基础
</a></li></ul></li><li class="dropdown-item"><h4>
          Go
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/go/" class="nav-link">
  Go基础
</a></li></ul></li><li class="dropdown-item"><h4>
          其他
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/assembly/" class="nav-link">
  Assembly
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开发框架" class="dropdown-title"><span class="title">开发框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="开发框架" class="mobile-dropdown-title"><span class="title">开发框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          框架
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/spring/" class="nav-link">
  Spring
</a></li></ul></li><li class="dropdown-item"><h4>
          数据库
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/mysql/1dh29a/" class="nav-link">
  MySQL
</a></li><li class="dropdown-subitem"><a href="/note-pages/redis/" class="nav-link">
  Redis
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="架构设计" class="dropdown-title"><span class="title">架构设计</span> <span class="arrow down"></span></button> <button type="button" aria-label="架构设计" class="mobile-dropdown-title"><span class="title">架构设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          分布式
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/distributed-system/01-理论基础/" class="nav-link">
  分布式系统
</a></li></ul></li><li class="dropdown-item"><h4>
          微服务
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/micro-service-in-action/" class="nav-link">
  微服务实战
</a></li></ul></li><li class="dropdown-item"><h4>
          消息队列
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/kafka/" class="nav-link">
  Kafka
</a></li><li class="dropdown-subitem"><a href="/note-pages/rocket-mq/" class="nav-link">
  RocketMQ
</a></li></ul></li><li class="dropdown-item"><h4>
          注册中心
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/zookeeper/" class="nav-link">
  ZooKeeper
</a></li><li class="dropdown-subitem"><a href="/note-pages/eureka/" class="nav-link">
  Eureka
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开发工具" class="dropdown-title"><span class="title">开发工具</span> <span class="arrow down"></span></button> <button type="button" aria-label="开发工具" class="mobile-dropdown-title"><span class="title">开发工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note-pages/git/" class="nav-link">
  Git
</a></li><li class="dropdown-item"><!----> <a href="/note-pages/docker/34kd5q/" class="nav-link">
  Docker
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="理论方法" class="dropdown-title"><span class="title">理论方法</span> <span class="arrow down"></span></button> <button type="button" aria-label="理论方法" class="mobile-dropdown-title"><span class="title">理论方法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note-pages/design-pattern/" class="nav-link">
  设计模式
</a></li><li class="dropdown-item"><!----> <a href="/note-pages/software-engineering/n4r1lx/" class="nav-link">
  软件工程
</a></li></ul></div></div><div class="nav-item"><a href="/note-pages/interview/f05h67/" class="nav-link">
  面试通关
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/note-pages/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础知识" class="dropdown-title"><span class="title">基础知识</span> <span class="arrow down"></span></button> <button type="button" aria-label="基础知识" class="mobile-dropdown-title"><span class="title">基础知识</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          算法
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/algorithm/5e022a/" class="nav-link">
  算法
</a></li></ul></li><li class="dropdown-item"><h4>
          计算机网络
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/network/a918ca/" class="nav-link">
  计算机网络
</a></li><li class="dropdown-subitem"><a href="/note-pages/http/" class="nav-link">
  HTTP
</a></li><li class="dropdown-subitem"><a href="/note-pages/tcp-ip/" class="nav-link">
  TCP/IP
</a></li><li class="dropdown-subitem"><a href="/note-pages/socket/" class="nav-link">
  Socket
</a></li></ul></li><li class="dropdown-item"><h4>
          操作系统
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/operating-system/knuk3x/" class="nav-link">
  操作系统
</a></li><li class="dropdown-subitem"><a href="/note-pages/linux/" class="nav-link">
  Linux
</a></li></ul></li><li class="dropdown-item"><h4>
          其他
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/database-system/fyl5c1/" class="nav-link">
  数据库系统
</a></li><li class="dropdown-subitem"><a href="/note-pages/computer-systems/" class="nav-link">
  计算机系统
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程语言" class="dropdown-title"><span class="title">编程语言</span> <span class="arrow down"></span></button> <button type="button" aria-label="编程语言" class="mobile-dropdown-title"><span class="title">编程语言</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          Java
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/java/5ddf72/" class="nav-link">
  Java基础
</a></li><li class="dropdown-subitem"><a href="/note-pages/java-collection/" class="nav-link">
  Java集合
</a></li><li class="dropdown-subitem"><a href="/note-pages/java-concurrency/" class="nav-link">
  Java并发
</a></li><li class="dropdown-subitem"><a href="/note-pages/jvm/" class="nav-link">
  JVM
</a></li></ul></li><li class="dropdown-item"><h4>
          C/C++
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/cpp/" class="nav-link">
  C++基础
</a></li></ul></li><li class="dropdown-item"><h4>
          Go
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/go/" class="nav-link">
  Go基础
</a></li></ul></li><li class="dropdown-item"><h4>
          其他
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/assembly/" class="nav-link">
  Assembly
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开发框架" class="dropdown-title"><span class="title">开发框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="开发框架" class="mobile-dropdown-title"><span class="title">开发框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          框架
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/spring/" class="nav-link">
  Spring
</a></li></ul></li><li class="dropdown-item"><h4>
          数据库
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/mysql/1dh29a/" class="nav-link">
  MySQL
</a></li><li class="dropdown-subitem"><a href="/note-pages/redis/" class="nav-link">
  Redis
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="架构设计" class="dropdown-title"><span class="title">架构设计</span> <span class="arrow down"></span></button> <button type="button" aria-label="架构设计" class="mobile-dropdown-title"><span class="title">架构设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>
          分布式
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/distributed-system/01-理论基础/" class="nav-link">
  分布式系统
</a></li></ul></li><li class="dropdown-item"><h4>
          微服务
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/micro-service-in-action/" class="nav-link">
  微服务实战
</a></li></ul></li><li class="dropdown-item"><h4>
          消息队列
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/kafka/" class="nav-link">
  Kafka
</a></li><li class="dropdown-subitem"><a href="/note-pages/rocket-mq/" class="nav-link">
  RocketMQ
</a></li></ul></li><li class="dropdown-item"><h4>
          注册中心
        </h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note-pages/zookeeper/" class="nav-link">
  ZooKeeper
</a></li><li class="dropdown-subitem"><a href="/note-pages/eureka/" class="nav-link">
  Eureka
</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="开发工具" class="dropdown-title"><span class="title">开发工具</span> <span class="arrow down"></span></button> <button type="button" aria-label="开发工具" class="mobile-dropdown-title"><span class="title">开发工具</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note-pages/git/" class="nav-link">
  Git
</a></li><li class="dropdown-item"><!----> <a href="/note-pages/docker/34kd5q/" class="nav-link">
  Docker
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="理论方法" class="dropdown-title"><span class="title">理论方法</span> <span class="arrow down"></span></button> <button type="button" aria-label="理论方法" class="mobile-dropdown-title"><span class="title">理论方法</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note-pages/design-pattern/" class="nav-link">
  设计模式
</a></li><li class="dropdown-item"><!----> <a href="/note-pages/software-engineering/n4r1lx/" class="nav-link">
  软件工程
</a></li></ul></div></div><div class="nav-item"><a href="/note-pages/interview/f05h67/" class="nav-link">
  面试通关
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/note-pages/operating-system/knuk3x/" class="sidebar-link">第1章 操作系统概述</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note-pages/operating-system/knuk3x/#_1-1-操作系统的基本概念" class="sidebar-link">1.1 操作系统的基本概念</a></li><li class="sidebar-sub-header"><a href="/note-pages/operating-system/knuk3x/#_1-2-操作系统的发展与分类" class="sidebar-link">1.2 操作系统的发展与分类</a></li><li class="sidebar-sub-header"><a href="/note-pages/operating-system/knuk3x/#_1-3-操作系统的运行机制与体系结构" class="sidebar-link">1.3 操作系统的运行机制与体系结构</a></li></ul></li><li><a href="/note-pages/operating-system/9xtgs8/" class="sidebar-link">第2章 进程与线程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note-pages/operating-system/9xtgs8/#_2-1-进程与线程" class="sidebar-link">2.1 进程与线程</a></li><li class="sidebar-sub-header"><a href="/note-pages/operating-system/9xtgs8/#_2-2-处理机的调度" class="sidebar-link">2.2 处理机的调度</a></li><li class="sidebar-sub-header"><a href="/note-pages/operating-system/9xtgs8/#_2-3-进程的同步与互斥" class="sidebar-link">2.3 进程的同步与互斥</a></li><li class="sidebar-sub-header"><a href="/note-pages/operating-system/9xtgs8/#_2-4-死锁" class="sidebar-link">2.4 死锁</a></li></ul></li><li><a href="/note-pages/operating-system/owchkr/" aria-current="page" class="active sidebar-link">第3章 内存管理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note-pages/operating-system/owchkr/#_3-1-内存管理相关概念" class="sidebar-link">3.1 内存管理相关概念</a></li><li class="sidebar-sub-header"><a href="/note-pages/operating-system/owchkr/#_3-2-虚拟内存" class="sidebar-link">3.2 虚拟内存</a></li></ul></li><li><a href="/note-pages/operating-system/vfjnsa/" class="sidebar-link">第4章 文件管理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note-pages/operating-system/vfjnsa/#_4-1-文件系统" class="sidebar-link">4.1 文件系统</a></li><li class="sidebar-sub-header"><a href="/note-pages/operating-system/vfjnsa/#_4-2-磁盘管理" class="sidebar-link">4.2 磁盘管理</a></li></ul></li><li><a href="/note-pages/operating-system/05-输入输出管理.html" class="sidebar-link">第5章 输入输出管理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note-pages/operating-system/05-输入输出管理.html#_5-1-i-o-管理概述" class="sidebar-link">5.1 I/O 管理概述</a></li><li class="sidebar-sub-header"><a href="/note-pages/operating-system/05-输入输出管理.html#_5-2-i-o-核心子系统" class="sidebar-link">5.2 I/O 核心子系统</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="第3章-内存管理"><a href="#第3章-内存管理" class="header-anchor">#</a> 第3章 内存管理</h1> <h2 id="_3-1-内存管理相关概念"><a href="#_3-1-内存管理相关概念" class="header-anchor">#</a> 3.1 内存管理相关概念</h2> <h3 id="内存管理的概念"><a href="#内存管理的概念" class="header-anchor">#</a> 内存管理的概念</h3> <p>操作系统 <strong>对内存的划分和动态分配</strong>，就是内存管理的概念。</p> <p>有效的内存管理在多道程序设计中非常重要，不仅方便用户使用存储器、提高内存利用率，还可以通过虚拟技术从逻辑上扩充存储器。</p> <p>内存管理的功能有：</p> <ul><li><strong>内存空间的分配与回收</strong>，包括内存的分配和共享。</li> <li><strong>地址转换</strong>，把逻辑地址转换成相应的物理地址。</li> <li><strong>内存空间的扩充</strong>，利用虚拟技术或自动覆盖技术，从逻辑上扩充内存。</li> <li><strong>存储保护</strong>，保证各道作业在各自存储空间内运行，互不干扰。</li></ul> <p>在进行具体的内存管理之前，需要了解进程运行的基本原理和要求。</p> <p>创建进程首先要将程序和数据装入内存。将用户原程序变成可在内存中执行的程序，通常需要以下几步。</p> <ul><li><strong>编译</strong>，由编译程序将用户源代码编译成若干个目标模块。</li> <li><strong>链接</strong>，由链接程序将编译后形成的一组目标模块，以及所需库函数链接，形成完整的装入模块。</li> <li><strong>装入</strong>，由装入程序将装入模块装入内存。</li></ul> <p>程序的链接有以下三种方式：</p> <ul><li><strong>静态链接</strong>：在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的可执行程序，以后不再拆开。</li> <li><strong>装入时动态链接</strong>：将源程序编译后所得到的一组目标模块，再装入内存时，采用边装入边链接的方式。</li> <li><strong>运行时动态链接</strong>：对某些目标模块的连接，是在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。</li></ul> <p>内存的装入模块在装入内存时，同样有以下三种方式：</p> <ul><li><strong>绝对装入</strong>。编译时，如果知道程序将驻留在内存的某个位置，编译程序将产生 <strong>绝对地址</strong> 的目标代码。绝对装入程序按照装入模块的地址，将程序和数据装入内存。装入模块被装入内存后，由于程序中的逻辑地址与实际地址完全相同，故不需对程序和数据的地址进行修改。绝对装入只适用于单道程序环境。</li> <li><strong>可重定位装入</strong>。在多道程序环境下，多个目标模块的起始地址通常都是从 0 开始，程序中的其他地址都是 <strong>相对于起始地址</strong> 的，此时应采用可重定位装入方式。根据内存的当前情况，将装入模块装入到内存的适当位置。<strong>装入时对目标程序中指令和数据的修改过程称为重定位</strong>，地址变换通常是装入时一次完成，所以又称为 <strong>静态重定位</strong>。</li> <li><strong>动态运行时装入</strong>，又称为 <strong>动态重定位</strong>，程序在内存中如果发生移动，就需要釆用动态的装入方式。装入程序在把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是 <strong>把这种地址转换推迟到程序真正要执行时才进行</strong>。因此，装入内存后的所有地址均为相对地址。这种方式需要一个重定位寄存器的支持。</li></ul> <p><img src="/note-pages/assets/img/20150922234019248.1d31760d.jpeg" alt="img"></p> <div id="逻辑地址空间与物理地址空间" class="anchor">逻辑地址空间与物理地址空间</div><p>编译后，每个目标模块都从 0 号单元开始编址，称为该目标模块的相对地址（逻辑地址）。</p> <p>当链接程序将各个模块链接成一个完整的可执行目标程序时，链接程序顺序依次按各个模块的相对地址构成统一的从 0 号单元开始编址的逻辑地址空间。用户程序和程序员只需知道逻辑地址，而内存管理的具体机制则是完全透明的，它们只有系统编程人员才会涉及。不同进程可以有相同的逻辑地址，因为这些相同的逻辑地址可以映射到主存的不同位置。</p> <p><strong>物理地址空间</strong> 是指内存中物理单元的集合，它是地址转换的最终地址，<strong>进程在运行时执行指令和访问数据最后都要通过物理地址从主存中存取</strong>。当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址，这个过程称为 <strong>地址重定位</strong>。</p> <div id="内存保护" class="anchor">内存保护</div><p>内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。通过釆用 <strong>重定位寄存器</strong> 和 <strong>界地址寄存器</strong> 来实现这种保护。</p> <p><strong>重定位寄存器含最小的物理地址值，界地址寄存器含最大的逻辑地址值</strong>。每个逻辑地址值必须小于界地址寄存器；内存管理机构动态地将逻辑地址与界地址寄存器进行比较，如果未发生地址越界，则加上重定位寄存器的值后映射成物理地址，再送交内存单元，如图所示。</p> <p><img src="/note-pages/assets/img/727485-20210705142045078-632248608.1d9eaeee.png" alt="img"></p> <h3 id="内存覆盖与内存交换"><a href="#内存覆盖与内存交换" class="header-anchor">#</a> 内存覆盖与内存交换</h3> <p>覆盖与交换技术是在多道程序环境下用来 <strong>扩充内存</strong> 的两种方法。</p> <div id="内存覆盖" class="anchor">内存覆盖</div><p>早期的计算机系统中，主存容量很小，虽然主存中仅存放一道用户程序，但是存储空间放不下用户进程的现象也经常发生，这一矛盾可以用覆盖技术来解决。</p> <p><strong>覆盖的基本思想是</strong>：由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可以 <strong>把用户空间分成一个固定区和若干个覆盖区</strong>。将经常活跃的部分放在固定区，其余部分按调用关系分段。首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段。</p> <p>覆盖技术的特点是打破了必须将一个进程的全部信息装入主存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行。</p> <div id="内存交换" class="anchor">内存交换</div><p><strong>交换（对换）的基本思想是</strong>：把处于等待状态（或在 CPU 调度原则下被剥夺运行权利）的程序从内存移到辅存，把内存空间腾出来，这一过程又叫换出；把准备好竞争 CPU 运行的程序从辅存移到内存，这一过程又称为换入。中级调度就是釆用交换技术。</p> <p>例如，有一个 CPU 釆用时间片轮转调度算法的多道程序环境。时间片到，内存管理器将刚刚执行过的进程换出，将另一进程换入到刚刚释放的内存空间中。同时，CPU 调度器可以将时间片分配给其他已在内存中的进程。每个进程用完时间片都与另一进程交换。理想情况下，内存管理器的交换过程速度足够快，总有进程在内存中可以执行。</p> <p><strong>交换技术主要是在不同进程（或作业）之间进行，而覆盖则用于同一个程序或进程中</strong>。</p> <p>由于覆盖技术要求给出程序段之间的覆盖结构，使得其对用户和程序员不透明，所以对于主存无法存放用户程序的矛盾，<strong>现代操作系统是通过虚拟内存技术来解决的</strong>，覆盖技术则已成为历史；而交换技术在现代操作系统中仍具有较强的生命力。</p> <h3 id="内存连续分配管理方式"><a href="#内存连续分配管理方式" class="header-anchor">#</a> 内存连续分配管理方式</h3> <p>连续分配方式，是指为一个用户程序 <strong>分配一个连续的内存空间</strong>。它主要包括单一连续分配、固定分区分配和动态分区分配。</p> <h4 id="单一连续分配"><a href="#单一连续分配" class="header-anchor">#</a> 单一连续分配</h4> <p>内存在此方式下分为系统区和用户区，系统区仅提供给操作系统使用，通常在低地址部分；用户区是为用户提供的、除系统区之外的内存空间。这种方式无需进行内存保护。</p> <p>这种方式的优点是简单、无外部碎片，可以釆用覆盖技术，不需要额外的技术支持。缺点是 <strong>只能用于单用户、单任务的操作系统中，有内部碎片，存储器的利用率极低。</strong></p> <h4 id="固定分区分配"><a href="#固定分区分配" class="header-anchor">#</a> 固定分区分配</h4> <p>固定分区分配是最简单的一种多道程序存储管理方式，它将用户内存空间 <strong>划分为若干个固定大小的区域</strong>，每个分区只装入一道作业。当有空闲分区时，便可以再从外存的后备作业队列中，选择适当大小的作业装入该分区，如此循环。</p> <p><img src="/note-pages/assets/img/727485-20210705142138066-445927118.e98862f8.png" alt="img"></p> <p>固定分区分配在划分分区时，有两种不同的方法，如图所示。</p> <ul><li>分区大小相等：用于利用一台计算机去控制多个相同对象的场合，缺乏灵活性。</li> <li>分区大小不等：划分为含有多个较小的分区、适量的中等分区及少量的大分区。</li></ul> <p>为便于内存分配，通常将分区按大小排队，并为之建立一张分区说明表，其中各表项包括每个分区的起始地址、大小及状态（是否已分配），如图（a）所示。当有用户程序要装入时，便检索该表，以找到合适的分区给予分配并将其状态置为 ”已分配”；未找到合适分区则拒绝为该用户程序分配内存。存储空间的分配情况如图（b）所示。</p> <p><img src="/note-pages/assets/img/727485-20210705142155396-1348018153.18bd9c03.png" alt="img"></p> <p>这种分区方式存在 <strong>两个问题</strong>：</p> <ul><li>程序可能太大而放不进任何一个分区中，这时用户不得不使用覆盖技术来使用内存空间；</li> <li>主存利用率低，当程序小于固定分区大小时，也占用了一个完整的内存分区空间，这样分区内部有空间浪费，这种现象称为 <strong>内部碎片</strong>。</li></ul> <p>固定分区是可用于多道程序设计最简单的存储分配，无外部碎片，但不能实现多进程共享一个主存区，所以存储空间利用率低。固定分区分配很少用于现在通用的操作系统中，但在某些用于控制多个相同对象的控制系统中仍发挥着一定的作用。</p> <h4 id="动态分区分配"><a href="#动态分区分配" class="header-anchor">#</a> 动态分区分配</h4> <p>动态分区分配又称为可变分区分配，是一种动态划分内存的分区方法。这种分区方法不预先将内存划分，而是在进程装入内存时，<strong>根据进程的大小动态地建立分区</strong>，并使分区的大小正好适合进程的需要。因此系统中分区的大小和数目是可变的。</p> <p><img src="/note-pages/assets/img/727485-20210705142209604-405492653.136ef567.png" alt="img"></p> <p>如图所示，系统有 64MB 内存空间，其中低 8MB 固定分配给操作系统，其余为用户可用内存。开始时装入前三个进程，在它们分别分配到所需空间后，内存只剩下 4MB，进程 4 无法装入。在某个时刻，内存中没有一个就绪进程，CPU 出现空闲，操作系统就换出进程 2，换入进程 4。由于进程 4 比进程 2 小，这样在主存中就产生了一个 6MB 的内存块。之后 CPU 又出现空闲，而主存无法容纳进程 2，操作系统就换出进程 1，换入进程 2。</p> <p>动态分区在开始分配时是很好的，但是之后会导致内存中出现许多小的内存块。随着时间的推移，内存中会产生越来越多的碎片（图中最后的 4MB 和中间的 6MB，且随着进程的换入/换出，很可能会出现更多更小的内存块），内存的利用率随之下降。</p> <p>这些小的内存块称为 <strong>外部碎片</strong>，指在所有 <strong>分区外的存储空间</strong> 会变成越来越多的碎片，这与固定分区中的内部碎片正好相对。克服外部碎片可以通过 <strong>紧凑技术</strong> 来解决，就是操作系统不时地对进程进行移动和整理。但是这需要动态重定位寄存器的支持，且相对费时。</p> <div id="动态分区的分配策略" class="anchor">动态分区的分配策略</div><p>在进程装入或换入主存时，如果内存中有多个足够大的空闲块，操作系统必须确定分配哪个内存块给进程使用，这就是 <strong>动态分区的分配策略</strong>，考虑以下几种算法：</p> <ul><li><strong>首次适应算法（First  Fit）</strong>：空闲分区以 <strong>地址递增</strong> 的次序链接。分配内存时顺序查找，找到大小能满足要求的第一个空闲分区。</li> <li><strong>最佳适应算法（Best  Fit）</strong>：空闲分区按 <strong>容量递增</strong> 形成分区链，找到第一个能满足要求的空闲分区。</li> <li><strong>最坏适应算法（Worst  Fit）</strong>：又称最大适应（Largest Fit）算法，空闲分区以 <strong>容量递减</strong> 的次序链接。找到第一个能满足要求的空闲分区，也就是挑选出最大的分区。</li> <li><strong>邻近适应算法（Next  Fit）</strong>：又称 <strong>循环首次适应算法</strong>，由首次适应算法演变而成。不同之处是分配内存时 <strong>从上次查找结束的位置开始继续查找</strong>。</li></ul> <p>在这几种方法中，首次适应算法不仅是最简单的，而且通常也是最好和最快的。在 UNIX 系统的最初版本中，就是使用首次适应算法为进程分配内存空间，其中使用数组的数据结构 （而非链表）来实现。不过，首次适应算法会使得内存的低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。</p> <p>邻近适应算法试图解决这个问题，但实际上，它常常会导致在内存的末尾分配空间（因为在一遍扫描中，内存前面部分使用后再释放时，不会参与分配），分裂成小碎片。它通常比首次适应算法的结果要差。</p> <p>最佳适应算法虽然称为“最佳”，但是性能通常很差，因为每次最佳的分配会留下很小的难以利用的内存块，它会产生最多的外部碎片。</p> <p>最坏适应算法与最佳适应算法相反，选择最大的可用块，这看起来最不容易产生碎片，但是却把最大的连续内存划分开，会很快导致没有可用的大的内存块，因此性能也非常差。</p> <h3 id="内存非连续分配管理方式"><a href="#内存非连续分配管理方式" class="header-anchor">#</a> 内存非连续分配管理方式</h3> <p><strong>以上三种</strong> 内存分区管理方法有一共同特点，即用户进程（作业）在主存中都是 <strong>连续存放的</strong>。</p> <p><strong>非连续分配</strong> 允许一个程序分散地装入到 <strong>不相邻的内存分区</strong> 中，根据分区的大小是否固定分为 <strong>分页存储管理方式</strong> 和 <strong>分段存储管理方式</strong>。</p> <p>分页存储管理方式中，又根据运行作业时是否要把作业的所有页面都装入内存才能运行分为 <strong>基本分页存储管理方式</strong> 和 <strong>请求分页存储管理方式</strong>。下面介绍基本分页存储管理方式。</p> <h4 id="基本分页存储管理方式"><a href="#基本分页存储管理方式" class="header-anchor">#</a> 基本分页存储管理方式</h4> <p>固定分区会产生内部碎片，动态分区会产生外部碎片，这两种技术对内存的利用率都比较低。我们希望内存的使用能尽量避免碎片的产生，<strong>这就引入了分页的思想</strong>：</p> <p><strong>把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程同样以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。</strong></p> <p>分页的方法从形式上看，像分区相等的固定分区技术，<strong>分页管理不会产生外部碎片</strong>。但它又有本质的不同点：块的大小相对分区要小很多，而且进程也按照块进行划分，进程运行时按块申请主存可用空间并执行。这样，进程只会在为最后一个不完整的块申请一个主存块空间时，才产生主存碎片，所以尽管会产生内部碎片，但是这种碎片相对于进程来说也是很小的，<strong>每个进程平均只产生半个块大小的内部碎片</strong>（称为 <strong>页内碎片</strong>）。</p> <div id="分页存储的几个基本概念" class="anchor">分页存储的几个基本概念</div><p>① <strong>页面和页面大小</strong>。<strong>进程中</strong> 的块称为 <strong>页（Page）</strong>，<strong>内存中</strong> 的块称为 <strong>页框（Page Frame，或页帧）</strong>。<strong>外存</strong> 以同样的单位进行划分，直接称为 <strong>块（Block）</strong>。进程在执行时需要申请主存空间，就是要为每个页面分配主存中的可用页框，这就产生了页和页框的一一对应。</p> <p>为方便地址转换，页面大小应是 2 的整数幂。同时页面大小应该适中，如果页面太小，会使进程的页面数过多，这样页表就过长，占用大量内存，而且也会增加硬件地址转换的开销，降低页面换入/换出的效率；页面过大又会使页内碎片增大，降低内存的利用率。所以页面的大小应该适中，考虑到耷间效率和时间效率的权衡。</p> <p>② <strong>地址结构</strong>。分页存储管理的逻辑地址结构如图所示。</p> <p><img src="data:image/png;base64,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" alt="img"></p> <p>地址结构包含两部分：前一部分为 <strong>页号 P</strong>，后一部分为 <strong>页内偏移量 W</strong>。地址长度为 32 位，其中 0~11 位为页内地址，即每页大小为 4KB；12~31 位为页号，地址空间最多允许有 2^20 页。</p> <p>③ <strong>页表</strong>。为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，记录页面在内存中对应的物理块号，页表一般存放在内存中。</p> <p>在配置了页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，<strong>页表的作用是实现从页号到物理块号的地址映射</strong>，如图所示。</p> <p><img src="/note-pages/assets/img/727485-20210705142310537-1273336098.4bb0768b.png" alt="img"></p> <div id="基本地址变换机构" class="anchor">基本地址变换机构</div><p>地址变换机构的任务是将逻辑地址转换为内存中物理地址，地址变换是借助于页表实现的。下图给出了分页存储管理系统中的地址变换机构。</p> <p><img src="/note-pages/assets/img/727485-20210705142324609-1852302717.e041880d.png" alt="img"></p> <p>在系统中通常设置一个页表寄存器（PTR），存放页表在内存的始址 F 和页表长度 M。进程未执行时，页表的始址和长度存放在进程控制块中，当进程执行时，才将页表始址和长度存入页表寄存器。设页面大小为 L，<strong>逻辑地址 A 到物理地址 E 的变换过程如下：</strong></p> <ul><li>计算页号 P（P = A / L）和页内偏移量 W （W = A % L）。</li> <li>比较页号 P 和页表长度 M，若 P &gt;= M，则产生越界中断，否则继续执行。</li> <li>页表中页号 P 对应的页表项地址 = 页表起始地址 F + 页号 P * 页表项长度，取出该页表项内容 b，即为物理块号。</li> <li>计算 E = b * L + W，用得到的物理地址 E 去访问内存。</li></ul> <p>以上整个地址变换过程均是由硬件自动完成的。</p> <blockquote><p><strong>例如</strong>，若页面大小 L 为 1K 字节，页号 2 对应的物理块为 b = 8，计算逻辑地址 A = 2500 的物理地址 E 的过程如下：</p> <p>P = 2500 / 1K = 2，W = 2500 % 1K = 452，查找得到页号 2 对应的物理块的块号为 8，E  = 8 * 1024 + 452=8644。</p></blockquote> <p>分页管理方式存在的 <strong>两个主要问题</strong>：</p> <ul><li>每次访存都需要进行逻辑地址到物理地址的转换，地址转换过程必须足够快，否则访存速度会降低；</li> <li>每个进程引入了页表，用于存储映射机制，页表不能太大，否则内存利用率会降低。</li></ul> <div id="具有快表的地址变换机构" class="anchor">具有快表的地址变换机构</div><p>由地址变换过程可知，若页表全部放在内存中，则存取一个数据或一条指令至少要访问两次内存：一次是访问页表，确定所存取的数据或指令的物理地址，第二次才根据该地址存取数据或指令。显然，这种方法比通常执行指令的速度慢了一半。</p> <p>为此，在地址变换机构中增设了一个具有并行查找能力的 <strong>高速缓冲存储器</strong> —— <strong>快表</strong>，又称 <strong>联想寄存器（TLB）</strong>，用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，主存中的页表常称为慢表，配有快表的地址变换机构如图所示。</p> <p><img src="/note-pages/assets/img/727485-20210705142341111-31060538.9b509ed8.png" alt="img"></p> <p>在具有快表的分页机制中，地址的变换过程：</p> <ul><li>CPU 给出逻辑地址后，由硬件进行地址转换并将页号送入高速缓存寄存器，并将此页号与快表中的所有页号进行比较。</li> <li>如果找到匹配的页号，说明所要访问的页表项在快表中，则直接从中取出该页对应的页框号，与页内偏移量拼接形成物理地址。这样，存取数据仅一次访存便可实现。</li> <li>如果没有找到，则需要访问主存中的页表，在读出页表项后，应同时将其存入快表，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换。</li></ul> <p>注意：有些处理机设计为快表和慢表同时查找，如果在快表中查找成功则终止慢表的查找。</p> <p>一般快表的命中率可以达到 90% 以上，这样，分页带来的速度损失就降低到 10% 以下。快表的有效性是基于著名的 <strong>局部性原理</strong>，这在后面的虚拟内存中将会具体讨论。</p> <div id="两级页表" class="anchor">两级页表</div><p>第二个问题：由于引入了分页管理，进程在执行时不需要将所有页调入内存页框中，而只要将保存有映射关系的页表调入内存中即可。但是我们 <strong>仍然需要考虑页表的大小</strong>。</p> <p>以 32 位逻辑地址空间、页面大小 4KB、页表项大小 4B 为例，若要实现进程对全部逻辑地址空间的映射，则每个进程需要 2^20，约 100 万个页表项。也就是说，每个进程仅页表这一项就需要 4MB 主存空间，这显然是不切实际的。而即便不考虑对全部逻辑地址空间进行映射的情况，一个逻辑地址空间稍大的进程，其页表大小也可能是过大的。</p> <p>以一个 40MB 的进程为例，页表项共 40KB，如果将所有页表项内容保存在内存中，那么需要 10 个内存页框来保存整个页表。整个进程大小约为 1 万个页面，而实际执行时只需要几十个页面进入内存页框就可以运行，但如果要求 10 个页面大小的页表必须全部进入内存，这相对实际执行时的几十个进程页面的大小来说，肯定是降低了内存利用率的；从另一方面来说，这 10 页的页表项也并不需要同时保存在内存中，因为大多数情况下，映射所需要的页表项都在页表的同一个页面中。</p> <p><strong>将页表映射的思想进一步延伸，就可以得到二级分页</strong>：将页表的 10 页空间也进行地址映射，建立上一级页表，用于存储页表的映射关系。这里对页表的 10 个页面进行映射只需要 10 个页表项，所以上一级页表只需要 1 页就足够（可以存储 2^10=1024 个页表项）。在进程执行时，只需要将这 1 页的上一级页表调入内存即可，进程的页表和进程本身的页面，可以在后面的执行中再 i 周入内存。</p> <p>如图所示，这是 Intel 处理器 80x86 系列的硬件分页的地址转换过程。在 32 位系统中，全部 32 位逻辑地址空间可以分为 2^20（4GB/4KB）个页面。这些页面可以再进一步建立顶级页表，需要 2^10 个顶级页表项进行索引，这正好是一页的大小，所以建立二级页表即可。</p> <p><img src="/note-pages/assets/img/727485-20210705142354535-1103997675.2a855c85.png" alt="img"></p> <p><strong>建立多级页表的目的在于建立索引</strong>，这样不用浪费主存空间去存储无用的页表项，也不用盲目地顺序式查找页表项，而建立索引的要求是最高一级页表项不超过一页的大小。在 64 位操作系统中，页表的划分则需要重新考虑，这是很多教材和辅导书中的常见题目，但是很多都给出了错误的分析，需要注意。</p> <h4 id="基本分段存储管理方式"><a href="#基本分段存储管理方式" class="header-anchor">#</a> 基本分段存储管理方式</h4> <p>分页管理方式是从计算机的角度考虑设计的，以提高内存的利用率，提升计算机的性能，且分页通过硬件机制实现，对用户完全透明；而分段管理方式的提出则是考虑了用户和程序员，以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要。</p> <div id="分段" class="anchor">分段</div><p>段式管理方式 <strong>按照用户进程中的自然段</strong> 划分逻辑空间。例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这个用户进程划分为 5 个段，每段从 0 开始编址，并分配一段连续的地址空间（段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的）。其逻辑地址由段号 S 与段内偏移量 W 两部分组成。</p> <p>在下图中，段号为 16 位，段内偏移量为 16 位，则一个作业最多可有 <span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>16</mn></msup><mo>=</mo><mn>65536</mn></mrow><annotation encoding="application/x-tex">2^{16}=65536</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">5</span><span class="mord">5</span><span class="mord">3</span><span class="mord">6</span></span></span></span></span> 个段，最大段长为 64KB。</p> <p><img src="data:image/png;base64,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" alt="img"></p> <p><img src="/note-pages/assets/img/20150923210221157.ffc06551.png" alt="img"></p> <p>在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，但在段式系统中，段号和段内偏移量必须由用户显示提供，在高级程序设计语言中，这个工作由编译程序完成。</p> <div id="段表" class="anchor">段表</div><p>每个进程都有一张逻辑空间与内存空间映射的段表，其中每一个段表项对应进程的一个段，段表项记录该段在内存中的起始地址和段的长度。段表的内容如图所示。</p> <p><img src="/note-pages/assets/img/20150923210354908.9498e260.png" alt="img"></p> <p>在配置了段表后，执行中的进程可通过查找段表，找到每个段所对应的内存区。可见，<strong>段表用于实现从逻辑段到物理内存区的映射</strong>。</p> <p><img src="/note-pages/assets/img/image-20240126195516941.d1df40cc.png" alt="img"></p> <div id="地址变换机构" class="anchor">地址变换机构</div><p>分段系统的地址变换过程如图所示。为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了 <strong>段表寄存器</strong>，用于存放段表始址 F 和段表长度 M。</p> <p>其从逻辑地址 A 到物理地址 E 之间的地址变换过程如下：</p> <ul><li>从逻辑地址 A 中取出前几位为段号 S，后几位为段内偏移量 W。</li> <li>比较段号 S 和段表长度 M，若 S &gt; M，则产生越界中断，否则继续执行。</li> <li>段表中段号 S 对应的段表项地址 = 段表起始地址 F + 段号 S * 段表项长度，取出该段表项的前几位得到段长 C。若段内偏移量 &gt;= C，则产生越界中断，否则继续执行。</li> <li>取出段表项中该段的起始地址 b，计算 E = b + W，用得到的物理地址 E 去访问内存。</li></ul> <p><img src="/note-pages/assets/img/20150923210522058.725dd9d2.jpeg" alt="img"></p> <div id="段的共享与保护" class="anchor">段的共享与保护</div><p>在分段系统中，段的共享是通过两个作业的段表中相应表项指向被共享的段的同一个物理副本来实现的。当一个作业正从共享段中读取数据时，必须防止另一个作业修改此共享段中的数据。不能修改的代码称为 <strong>纯代码</strong> 或 <strong>可重入代码</strong>（它不属于临界资源)，这样的代码和不能修改的数据是可以共享的，而可修改的代码和数据则不能共享。</p> <p>与分页管理类似，分段管理的保护方法主要有两种：一种是 <strong>存取控制保护</strong>，另一种是 <strong>地址越界保护</strong>。地址越界保护是利用段表寄存器中的段表长度与逻辑地址中的段号比较，若段号大于段表长度则产生越界中断；再利用段表项中的段长和逻辑地址中的段内位移进行比较，若段内位移大于段长，也会产生越界中断。</p> <h4 id="段页式管理方式"><a href="#段页式管理方式" class="header-anchor">#</a> 段页式管理方式</h4> <p>页式存储管理能有效地提高内存利用率，而分段存储管理能反映程序的逻辑结构并有利于段的共享。如果将这两种存储管理方法结合起来，就形成了段页式存储管理方式。</p> <p>在段页式系统中，作业的地址空间 <strong>首先被分成若干个逻辑段</strong>，每段都有自己的段号，然后 <strong>再将每一段分成若干个大小固定的页</strong>。对内存空间的管理仍然和分页存储管理一样，将其分</p> <p>在段页式系统中，作业的逻辑地址分为三部分：段号、页号和页内偏移量，如所示。</p> <p><img src="data:image/png;base64,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" alt="img"></p> <p><img src="/note-pages/assets/img/20150923210806703.833f7011.png" alt="img"></p> <p>为了实现地址变换，系统为每个进程建立 <strong>一张段表</strong>，而 <strong>每个分段有一张页表</strong>。段表表项中至少包括段号、页表长度和页表起始地址，页表表项中至少包括页号和块号。此外，系统中还应有一个 <strong>段表寄存器</strong>，指出作业的段表起始地址和段表长度。</p> <p><img src="/note-pages/assets/img/image-20240118204314309.6a386126.png" alt="image-20240118204314309"></p> <blockquote><p><strong>注意</strong>：在一个进程中，段表只有一个，而页表可能有多个。</p></blockquote> <p>在进行地址变换时，首先通过段表查到页表起始地址，然后通过页表找到页帧号，最后形成物理地址。如图所示，进行一次访问实际需要三次访问主存，这里同样可以使用快表以加快查找速度，其关键字由段号、页号组成，值是对应的页帧号和保护码。</p> <p><img src="/note-pages/assets/img/727485-20210705142557380-332373689.95920215.png" alt="img"></p> <h2 id="_3-2-虚拟内存"><a href="#_3-2-虚拟内存" class="header-anchor">#</a> 3.2 虚拟内存</h2> <h3 id="虚拟内存的概念、特征以及虚拟内存的实现"><a href="#虚拟内存的概念、特征以及虚拟内存的实现" class="header-anchor">#</a> 虚拟内存的概念、特征以及虚拟内存的实现</h3> <div id="传统存储管理方式的特征" class="anchor">传统存储管理方式的特征</div><p>上一节所讨论的各种内存管理策略都是为了同时将多个进程保存在内存中以便允许多道程序设计。它们都具有以下两个共同的特征：</p> <p><strong>一次性</strong>：作业 <strong>必须一次性全部装入内存</strong> 后，方能开始运行。这会导致两种情况发生：</p> <ul><li>当作业很大，不能全部被装入内存时，将使该作业无法运行；</li> <li>当大量作业要求运行时，内存不足以容纳所有作业，只能使少数作业先运行，导致多道程序度的下降。</li></ul> <p><strong>驻留性</strong>：作业被装入内存后，就 <strong>一直驻留在内存中</strong>，其任何部分都不会被换出，直至作业运行结束。运行中的进程，会因等待 I/O 而被阻塞，可能处于长期等待状态。</p> <p>由以上分析可知，许多在程序运行中不用或暂时不用的程序（数据）占据了大量的内存空间，而一些需要运行的作业又无法装入运行，显然浪费了宝贵的内存资源。</p> <div id="局部性原理" class="anchor">局部性原理</div><p>要真正理解虚拟内存技术的思想，首先必须了解计算机中著名的局部性原理。</p> <p>局部性原理表现在以下两个方面：</p> <ul><li><strong>时间局部性</strong>：如果程序中的某条指令一旦执行，<strong>不久以后该指令可能再次执行</strong>；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于程序中存在着大量的循环操作。</li> <li><strong>空间局部性</strong>：一旦程序访问了某个存储单元，在不久之后，其 <strong>附近的存储单元</strong> 也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li></ul> <p>时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上就是建立了 “内存一外存” 的两级存储器的结构，利用局部性原理实现高速缓存。</p> <div id="虚拟存储器的定义和特征" class="anchor">虚拟存储器的定义和特征</div><p>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息。这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为 <strong>虚拟存储器</strong>。</p> <p>之所以将其称为虚拟存储器，是因为这种存储器实际上并不存在，只是由于系统提供了 <strong>部分装入、请求调入和置换功能</strong> 后（对用户完全透明），给用户的感觉是好像存在一个比实际物理内存大得多的存储器。虚拟存储器的大小由计算机的地址结构决定，并非是内存和外存的简单相加。</p> <div id="虚拟内存技术的实现" class="anchor">虚拟内存技术的实现</div><p>釆用连续分配方式时，会使相当一部分内存空间都处于暂时或 “永久” 的空闲状态，造成内存资源的严重浪费，而且也无法从逻辑上扩大内存容量。因此，<strong>虚拟内存的实现需要建立在离散分配的内存管理方式的基础上</strong>。虚拟内存的实现有以下三种方式：</p> <ul><li>请求分页存储管理。</li> <li>请求分段存储管理。</li> <li>请求段页式存储管理。</li></ul> <p>不管哪种方式，都需要有一定的硬件支持。一般需要的支持有以下几个方面：</p> <ul><li>一定容量的内存和外存。</li> <li>页表机制（或段表机制），作为主要的数据结构。</li> <li>中断机构，当用户程序要访问的部分尚未调入内存，则产生中断。</li> <li>地址变换机构，逻辑地址到物理地址的变换。</li></ul> <h3 id="请求分页管理方式实现虚拟内存"><a href="#请求分页管理方式实现虚拟内存" class="header-anchor">#</a> 请求分页管理方式实现虚拟内存</h3> <p>请求分页系统建立在基本分页系统基础之上，为了支持虚拟存储器功能而增加了 <strong>请求调页</strong> 功能和 <strong>页面置换</strong> 功能。请求分页是目前最常用的一种实现虚拟存储器的方法。</p> <p>在请求分页系统中，只要求将当前需要的一部分页面装入内存，便可以启动作业运行。在作业执行过程中，当所要访问的页面不在内存时，再通过调页功能将其调入，同时还可以通过置换功能将暂时不用的页面换出到外存上，以便腾出内存空间。</p> <p>为了实现请求分页，系统必须提供一定的硬件支持。除了需要一定容量的内存及外存的计算机系统，还需要有页表机制、缺页中断机构和地址变换机构。</p> <div id="页表机制" class="anchor">页表机制</div><p>请求分页系统的页表机制不同于基本分页系统，请求分页系统在一个作业运行之前不要求全部一次性调入内存，因此在作业的运行过程中，必然会出现要访问的页面不在内存的情况，如何发现和处理这种情况是请求分页系统必须解决的两个基本问题。为此，在请求页表项中增加了四个字段，如图所示。</p> <p><img src="data:image/png;base64,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" alt="img"></p> <p>增加的四个字段说明如下：</p> <ul><li><strong>状态位 P</strong>：用于指示该页是否已调入内存，供程序访问时参考。</li> <li><strong>访问字段 A</strong>：用于记录本页在一段时间内被访问的次数，或记录本页最近己有多长时间未被访问，供置换算法换出页面时参考。</li> <li><strong>修改位 M</strong>：标识该页在调入内存后是否被修改过。</li> <li><strong>外存地址</strong>：用于指出该页在外存上的地址，通常是物理块号，供调入该页时参考。</li></ul> <div id="缺页中断机构" class="anchor">缺页中断机构</div><p>在请求分页系统中，每当所要访问的页面不在内存时，便产生一个 <strong>缺页中断</strong>，请求操作系统将所缺的页调入内存。此时应将缺页的进程阻塞（调页完成唤醒）：</p> <ul><li>如果内存中有空闲块，则分配一个块，将要调入的页装入，并修改页表中相应页表项；</li> <li>如果内存中没有空闲块，则要淘汰某页（若被淘汰页在内存期间被修改过，则要将其写回外存）。</li></ul> <p>缺页中断作为中断同样要经历，诸如保护 CPU 环境、分析中断原因、转入缺页中断处理程序、恢复 CPU 环境等几个步骤。但与一般的中断相比，它有以下两个明显的区别：</p> <ul><li>在指令执行期间产生和处理中断信号，而非一条指令执行完后，属于 <strong>内部中断</strong>。</li> <li>一条指令在执行期间，可能产生多次缺页中断。</li></ul> <div id="地址变换机构" class="anchor">地址变换机构</div><p>请求分页系统中的地址变换机构，是在分页系统地址变换机构的基础上，为实现虚拟内存，又增加了某些功能而形成的。</p> <p><img src="/note-pages/assets/img/727485-20210705150930175-80399221.3d787551.png" alt="img"></p> <p>如图所示，在进行地址变换时，先检索快表：</p> <ul><li>若找到要访问的页，<strong>便修改页表项中的访问位（写指令则还须重置修改位）</strong>，然后利用页表项中给出的物理块号和页内地址形成物理地址。</li> <li>若未找到该页的页表项，应到内存中去查找页表，再对比页表项中的状态位 P，看该页是否已调入内存，未调入则产生缺页中断，请求从外存把该页调入内存。</li></ul> <h3 id="页面置换算法"><a href="#页面置换算法" class="header-anchor">#</a> 页面置换算法</h3> <p>进程运行时，若其访问的页面不在内存而需将其调入，但内存已无空闲空间时，就需要从内存中调出一页程序或数据，送入磁盘的对换区。</p> <p>选择调出页面的算法就称为 <strong>页面置换算法</strong>。好的页面置换算法应有较低的页面更换频率，也就是说，应将以后不会再访问或者以后较长时间内不会再访问的页面先调出。</p> <p>常见的置换算法有以下四种。</p> <h4 id="最佳置换算法-opt"><a href="#最佳置换算法-opt" class="header-anchor">#</a> 最佳置换算法（OPT）</h4> <p>最佳（Optimal，OPT）置换算法所选择的被淘汰页面将是以后永不使用的，或者是 <strong>在最长时间内不再被访问的页面</strong>，这样可以保证获得最低的缺页率。但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而 <strong>该算法无法实现</strong>。</p> <p>最佳置换算法可以用来评价其他算法。假定系统为某进程分配了三个物理块，并考虑有以下页面号引用串：7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1。</p> <p>进程运行时，先将 7, 0, 1 三个页面依次装入内存。进程要访问页面 2 时，产生缺页中断，根据最佳置换算法，选择第 18 次访问才需调入的页面 7 予以淘汰。然后，访问页面 0 时，因为已在内存中所以不必产生缺页中断。访问页面 3 时又会根据最佳置换算法将页面 1 淘汰……依此类推，如表所示。从表中可以看出釆用最佳置换算法时的情况。</p> <p>可以看到，发生缺页中断的次数为 9，页面置换的次数为 6。</p> <div style="font-size:11px;text-align:center;"><table><thead><tr><th>访问页面</th> <th>7</th> <th>0</th> <th>1</th> <th>2</th> <th>0</th> <th>3</th> <th>0</th> <th>4</th> <th>2</th> <th>3</th> <th>0</th> <th>3</th> <th>2</th> <th>1</th> <th>2</th> <th>0</th> <th>1</th> <th>7</th> <th>0</th> <th>1</th></tr></thead> <tbody><tr><td>物理块1</td> <td>7</td> <td>7</td> <td>7</td> <td>2</td> <td></td> <td>2</td> <td></td> <td>2</td> <td></td> <td></td> <td>2</td> <td></td> <td></td> <td>2</td> <td></td> <td></td> <td></td> <td>7</td> <td></td> <td></td></tr> <tr><td>物理块2</td> <td></td> <td>0</td> <td>0</td> <td>0</td> <td></td> <td>0</td> <td></td> <td>4</td> <td></td> <td></td> <td>0</td> <td></td> <td></td> <td>0</td> <td></td> <td></td> <td></td> <td>0</td> <td></td> <td></td></tr> <tr><td>物理块3</td> <td></td> <td></td> <td>1</td> <td>1</td> <td></td> <td>3</td> <td></td> <td>3</td> <td></td> <td></td> <td>3</td> <td></td> <td></td> <td>1</td> <td></td> <td></td> <td></td> <td>1</td> <td></td> <td></td></tr> <tr><td>缺页否</td> <td>√</td> <td>√</td> <td>√</td> <td>√</td> <td></td> <td>√</td> <td></td> <td>√</td> <td></td> <td></td> <td>√</td> <td></td> <td></td> <td>√</td> <td></td> <td></td> <td></td> <td>√</td> <td></td> <td></td></tr></tbody></table></div><h4 id="先进先出-fifo-页面置换算法"><a href="#先进先出-fifo-页面置换算法" class="header-anchor">#</a> 先进先出（FIFO）页面置换算法</h4> <p><strong>优先淘汰最早进入内存的页面</strong>，亦即在内存中驻留时间最久的页面。该算法实现简单，只需把调入内存的页面根据先后次序链接成队列，设置一个指针总指向最早的页面。但该算法与进程实际运行时的规律不适应，因为在进程中，有的页面经常被访问。</p> <div style="font-size:11px;text-align:center;"><table><thead><tr><th>访问页面</th> <th>7</th> <th>0</th> <th>1</th> <th>2</th> <th>0</th> <th>3</th> <th>0</th> <th>4</th> <th>2</th> <th>3</th> <th>0</th> <th>3</th> <th>2</th> <th>1</th> <th>2</th> <th>0</th> <th>1</th> <th>7</th> <th>0</th> <th>1</th></tr></thead> <tbody><tr><td>物理块1</td> <td>7</td> <td>7</td> <td>7</td> <td>2</td> <td></td> <td>2</td> <td>2</td> <td>4</td> <td>4</td> <td>4</td> <td>0</td> <td></td> <td></td> <td>0</td> <td>0</td> <td></td> <td></td> <td>7</td> <td>7</td> <td>7</td></tr> <tr><td>物理块2</td> <td></td> <td>0</td> <td>0</td> <td>0</td> <td></td> <td>3</td> <td>3</td> <td>3</td> <td>2</td> <td>2</td> <td>2</td> <td></td> <td></td> <td>1</td> <td>1</td> <td></td> <td></td> <td>1</td> <td>0</td> <td>0</td></tr> <tr><td>物理块3</td> <td></td> <td></td> <td>1</td> <td>1</td> <td></td> <td>1</td> <td>0</td> <td>0</td> <td>0</td> <td>3</td> <td>3</td> <td></td> <td></td> <td>3</td> <td>2</td> <td></td> <td></td> <td>2</td> <td>2</td> <td>1</td></tr> <tr><td>缺页否</td> <td>√</td> <td>√</td> <td>√</td> <td>√</td> <td></td> <td>√</td> <td>√</td> <td>√</td> <td>√</td> <td>√</td> <td>√</td> <td></td> <td></td> <td>√</td> <td>√</td> <td></td> <td></td> <td>√</td> <td>√</td> <td>√</td></tr></tbody></table></div><p>这里仍用上面的实例，釆用 FIFO 算法进行页面置换。进程访问页面 2 时，把最早进入内存的页面 7 换出。然后访问页面 3 时，再把 2, 0, 1 中最先进入内存的页换出。由表可以看出，利用 FIFO 算法时进行了 12 次页面置换，比最佳置换算法正好多一倍。</p> <p>FIFO 算法还会产生 <strong>当所分配的物理块数增大而页故障数不减反增的异常现象</strong>，这是由 Belady 于 1969 年发现，故称为 <strong>Belady 异常</strong>，如下表所示。只有 FIFO 算法可能出现 Belady 异常，而 LRU 和 OPT 算法永远不会出现 Belady 异常。</p> <div style="font-size:12px;text-align:center;"><table><thead><tr><th>访问页面</th> <th>1</th> <th>2</th> <th>3</th> <th>4</th> <th>1</th> <th>2</th> <th>5</th> <th>1</th> <th>2</th> <th>3</th> <th>4</th> <th>5</th></tr></thead> <tbody><tr><td>物理块1</td> <td>1</td> <td>1</td> <td>1</td> <td>4</td> <td>4</td> <td>4</td> <td>5</td> <td></td> <td></td> <td>,5'</td> <td>5</td> <td></td></tr> <tr><td>物理块2</td> <td></td> <td>2</td> <td>2</td> <td>2</td> <td>1</td> <td>1</td> <td>1</td> <td></td> <td></td> <td>3</td> <td>3</td> <td></td></tr> <tr><td>物理块3</td> <td></td> <td></td> <td>3</td> <td>3</td> <td>3</td> <td>2</td> <td>2</td> <td></td> <td></td> <td>2</td> <td>4</td> <td></td></tr> <tr><td>缺页否</td> <td>√</td> <td>√</td> <td>√</td> <td>√</td> <td>√</td> <td>√</td> <td>√</td> <td></td> <td></td> <td>√</td> <td>√</td> <td></td></tr> <tr><td>物理块1*</td> <td></td> <td>1</td> <td>1</td> <td>1</td> <td></td> <td></td> <td>5</td> <td>5</td> <td>5</td> <td>5</td> <td>4</td> <td>4</td></tr> <tr><td>物理块2*</td> <td></td> <td>2</td> <td>2</td> <td>2</td> <td></td> <td></td> <td>2</td> <td>1</td> <td>1</td> <td>1</td> <td>1</td> <td>5</td></tr> <tr><td>物理块3*</td> <td></td> <td></td> <td>3</td> <td>3</td> <td></td> <td></td> <td>3</td> <td>3</td> <td>2</td> <td>2</td> <td>2</td> <td>2</td></tr> <tr><td>物理块4*</td> <td></td> <td></td> <td></td> <td>4</td> <td></td> <td></td> <td>4</td> <td>4</td> <td>4</td> <td>3</td> <td>3</td> <td>3</td></tr> <tr><td>缺页否</td> <td>√</td> <td>√</td> <td>√</td> <td></td> <td></td> <td></td> <td>√</td> <td>√</td> <td>√</td> <td>√</td> <td>√</td> <td>√</td></tr></tbody></table></div><h4 id="最近最久未使用-lru-置换算法"><a href="#最近最久未使用-lru-置换算法" class="header-anchor">#</a> 最近最久未使用（LRU）置换算法</h4> <p><strong>选择最近最长时间未访问过的页面予以淘汰</strong>，它认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问。该算法为每个页面设置一个访问字段，来记录页面自上次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的予以淘汰。</p> <p>再对上面的实例釆用 LRU 算法进行页面置换，如下表所示。进程第一次对页面 2 访问时，将最近最久未被访问的页面 7 置换出去。然后访问页面 3 时，将最近最久未使用的页面 1 换出。</p> <div style="font-size:12px;text-align:center;"><table><thead><tr><th>访问页面</th> <th>7</th> <th>0</th> <th>1</th> <th>2</th> <th>0</th> <th>3</th> <th>0</th> <th>4</th> <th>2</th> <th>3</th> <th>0</th> <th>3</th> <th>2</th> <th>1</th> <th>2</th> <th>0</th> <th>1</th> <th>7</th> <th>0</th> <th>1</th></tr></thead> <tbody><tr><td>物理块1</td> <td>7</td> <td>7</td> <td>7</td> <td>2</td> <td></td> <td>2</td> <td></td> <td>4</td> <td>4</td> <td>4</td> <td>0</td> <td></td> <td></td> <td>1</td> <td></td> <td>1</td> <td></td> <td>1</td> <td></td> <td></td></tr> <tr><td>物理块2</td> <td></td> <td>0</td> <td>0</td> <td>0</td> <td></td> <td>0</td> <td></td> <td>0</td> <td>0</td> <td>3</td> <td>3</td> <td></td> <td></td> <td>3</td> <td></td> <td>0</td> <td></td> <td>0</td> <td></td> <td></td></tr> <tr><td>物理块3</td> <td></td> <td></td> <td>1</td> <td>1</td> <td></td> <td>3</td> <td></td> <td>3</td> <td>2</td> <td>2</td> <td>2</td> <td></td> <td></td> <td>2</td> <td></td> <td>2</td> <td></td> <td>7</td> <td></td> <td></td></tr> <tr><td>缺页否</td> <td>√</td> <td>√</td> <td>√</td> <td>√</td> <td></td> <td>√</td> <td></td> <td>√</td> <td>√</td> <td>√</td> <td>√</td> <td></td> <td></td> <td>√</td> <td></td> <td>√</td> <td></td> <td>√</td> <td></td> <td></td></tr></tbody></table></div><p>前 5 次置换的情况与最佳置换算法相同，但两种算法并无必然联系。实际上，LRU 算法根据各页以前的情况，是 “向前看” 的，而最佳置换算法则根据各页以后的使用情况，是 “向后看” 的。</p> <p><strong>LRU 性能较好，但需要寄存器和栈的硬件支持</strong>。LRU 是堆栈类的算法。理论上可以证明，堆栈类算法不可能出现 Belady 异常。FIFO 算法基于队列实现，不是堆栈类算法。</p> <h4 id="时钟-clock-置换算法"><a href="#时钟-clock-置换算法" class="header-anchor">#</a> 时钟（CLOCK）置换算法</h4> <p>LRU 算法的性能接近于 OPT，但是实现起来比较困难，且开销大；FIFO 算法实现简单，但性能差。所以操作系统的设计者尝试了很多算法，试图用比较小的开销接近 LRU 的性能，这类算法都是 CLOCK 算法的变体。</p> <p><strong>简单的 CLOCK 算法</strong> 是给每一帧关联一个附加位，称为 <strong>使用位</strong>。当某一页首次装入主存时，该帧的使用位设置为 1；当该页随后再被访问到时，它的使用位也被置为 1。对于页替换算法，用于替换的候选帧集合看做一个循环缓冲区，并且有一个指针与之相关联。当某一页被替换时，该指针被设置成指向缓冲区中的下一帧。<strong>当需要替换一页时，操作系统扫描缓冲区，以查找使用位被置为 0 的一帧。每当遇到一个使用位为 1 的帧时，操作系统就将该位重新置为 0</strong>；如果在这个过程开始时，缓冲区中所有帧的使用位均为 0，则选择遇到的第一个帧替换；如果所有帧的使用位均为 1，则指针在缓冲区中完整地循环一周，把所有使用位都置为 0，并且停留在最初的位置上，替换该帧中的页。由于该算法循环地检查各页面的情况，故称为 CLOCK 算法，又称为最近未用（Not Recently Used，NRU）算法。</p> <p>CLOCK 算法的性能比较接近 LRU，而通过增加使用的位数目，可以使得 CLOCK 算法更加高效。在使用位的基础上再增加一个 <strong>修改位</strong>，则得到改进型的 CLOCK 置换算法。这样，每一帧都处于以下四种情况之一：</p> <ul><li>最近未被访问，也未被修改（u=0，m=0）。</li> <li>最近被访问，但未被修改（u=1，m=0）。</li> <li>最近未被访问，但被修改（u=0，m=1）。</li> <li>最近被访问，被修改（u=1，m=1）。</li></ul> <p>算法执行如下操作步骤：</p> <ul><li>从指针的当前位置开始，扫描帧缓冲区。在这次扫描过程中，对使用位不做任何修改。选择遇到的第一个帧（u=0，m=0）用于替换。</li> <li>如果第 1）步失败，则重新扫描，查找（u=0，m=1）的帧。选择遇到的第一个这样的帧用于替换。在这个扫描过程中，对每个跳过的帧，把它的使用位设置成 0。</li> <li>如果第 2）步失败，指针将回到它的最初位置，并且集合中所有帧的使用位均为 0。重复第 1 步，并且如果有必要，重复第 2 步。这样将可以找到供替换的帧。</li></ul> <p>改进型的 CLOCK 算法优于简单 CLOCK 算法之处在于替换时首选没有变化的页。由于修改过的页在被替换之前必须写回，因而这样做会节省时间。</p> <h3 id="页面分配策略"><a href="#页面分配策略" class="header-anchor">#</a> 页面分配策略</h3> <div id="驻留集大小" class="anchor">驻留集大小</div><p>对于分页式的虚拟内存，在准备执行时，不需要也不可能把一个进程的所有页都读取到主存，因此，操作系统必须决定读取多少页。也就是说，给特定的进程分配多大的主存空间，这需要考虑以下几点：</p> <ul><li>分配给一个进程的存储量越小，在任何时候驻留在主存中的进程数就越多，从而可以提高处理机的时间利用效率。</li> <li>如果一个进程在主存中的页数过少，尽管有局部性原理，页错误率仍然会相对较高。</li> <li>如果页数过多，由于局部性原理，给特定的进程分配更多的主存空间对该进程的错误率没有明显的影响。</li></ul> <p>基于这些因素，现代操作系统通常釆用 <strong>三种策略</strong>：</p> <ul><li><strong>固定分配局部置换</strong>：每个进程被固定分配一定数量的物理块，运行期间不变，缺页时只能在自身分配的页面中置换。</li> <li><strong>可变分配全局置换</strong>：每个进程被分配一定数量的物理块，操作系统自身保持一个空闲物理块队列，缺页时系统从公共空闲队列中分配新的物理块。</li> <li><strong>可变分配局部置换</strong>：每个进程被分配一定数量的物理块，缺页时只能在自身分配的页面中置换，但系统可根据缺页情况调整分配的物理块数量。</li></ul> <div id="调入页面的时机" class="anchor">调入页面的时机</div><p>为确定系统将进程运行时所缺的页面调入内存的时机，可釆取以下两种调页策略：</p> <ul><li><strong>预调页策略</strong>：基于局部性原理，预先调入 <strong>预测</strong> 会被访问的多个相邻页面，提高效率，但准确率约为50%，通常用于进程首次调入。</li> <li><strong>请求调页策略</strong>：根据进程实际需求，当访问的页面不在内存时提出请求，系统调入所需页面，保证调入页被使用，但可能导致高I/O开销。</li></ul> <div id="从何处调入页面" class="anchor">从何处调入页面</div><p>请求分页系统中的外存分为两部分：用于存放文件的 <strong>文件区</strong> 和用于存放对换页面的 <strong>对换区</strong>。对换区通常是釆用连续分配方式，而文件区釆用离散分配方式，故对换区的磁盘 I/O 速度比文件区的更快。这样从何处调入页面有三种情况：</p> <ul><li>系统拥有足够的对换区空间：可以全部从对换区调入所需页面，以提髙调页速度。为此，在进程运行前，需将与该进程有关的文件从文件区复制到对换区。</li> <li>系统缺少足够的对换区空间：凡不会被修改的文件都直接从文件区调入；而当换出这些页面时，由于它们未被修改而不必再将它们换出。但对于那些可能被修改的部分，在将它们换出时须调到对换区，以后需要时再从对换区调入。</li> <li>UNIX方式：与进程有关的文件都放在文件区，故未运行过的页面，都应从文件区调入。曾经运行过但又被换出的页面，由于是被放在对换区，因此下次调入时应从对换区调入。进程请求的共享页面若被其他进程调入内存，则无需再从对换区调入。</li></ul> <h3 id="页面抖动和工作集"><a href="#页面抖动和工作集" class="header-anchor">#</a> 页面抖动和工作集</h3> <div id="页面抖动（颠簸）" class="anchor">页面抖动（颠簸）</div><p>在页面置换过程中的一种最糟糕的情形是，<strong>刚刚换出的页面马上又要换入主存，刚刚换入的页面马上就要换出主存</strong>，这种频繁的页面调度行为称为 <strong>抖动</strong>，或 <strong>颠簸</strong>。如果一个进程在换页上用的时间多于执行时间，那么这个进程就在颠簸。</p> <p>频繁的发生缺页中断（抖动），其 <strong>主要原因是某个进程频繁访问的页面数目高于可用的物理页帧数目</strong>。虚拟内存技术可以在内存中保留更多的进程以提髙系统效率。在稳定状态，几乎主存的所有空间都被进程块占据，处理机和操作系统可以直接访问到尽可能多的进程。但如果管理不当，处理机的大部分时间都将用于交换块，即请求调入页面的操作，而不是执行进程的指令，这就会大大降低系统效率。</p> <div id="工作集（驻留集）" class="anchor">工作集（驻留集）</div><p><strong>工作集（或驻留集）是指在某段时间间隔内，进程要访问的页面集合</strong>。经常被使用的页面需要在工作集中，而长期不被使用的页面要从工作集中被丢弃。为了防止系统出现抖动现象，需要选择合适的工作集大小。</p> <p><strong>工作集模型的原理是</strong>：让操作系统跟踪每个进程的工作集，并为进程分配大于其工作集的物理块。如果还有空闲物理块，则可以再调一个进程到内存以增加多道程序数。如果所有工作集之和增加以至于超过了可用物理块的总数，那么操作系统会暂停一个进程，将其页面调出并且将其物理块分配给其他进程，防止出现抖动现象。</p> <p>正确选择工作集的大小，对存储器的利用率和系统吞吐量的提嵩，都将产生重要影响。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/note-pages/operating-system/9xtgs8/" class="prev">
        第2章 进程与线程
      </a></span> <span class="next"><a href="/note-pages/operating-system/vfjnsa/">
        第4章 文件管理
      </a>
      →
    </span></p></div> </main> <aside items="[object Object],[object Object],[object Object],[object Object],[object Object]" class="right-sidebar"><div style="margin-left:20px; margin-bottom: 10px; text-align: center; font-size:16px;font-weight:bold;">此页内容</div> <div class="right-sidebar-wrap"><ul class="right-sidebar-links"><li id="tab-item0" class="right-sidebar-item active"><a href="#_3-1-内存管理相关概念" class="right-sidebar-item-level2">
          3.1 内存管理相关概念
        </a></li><li id="tab-item1" class="right-sidebar-item"><a href="#内存管理的概念" class="right-sidebar-item-level3">
          内存管理的概念
        </a></li><li id="tab-item2" class="right-sidebar-item"><a href="#内存覆盖与内存交换" class="right-sidebar-item-level3">
          内存覆盖与内存交换
        </a></li><li id="tab-item3" class="right-sidebar-item"><a href="#内存连续分配管理方式" class="right-sidebar-item-level3">
          内存连续分配管理方式
        </a></li><li id="tab-item4" class="right-sidebar-item"><a href="#单一连续分配" class="right-sidebar-item-level4">
          单一连续分配
        </a></li><li id="tab-item5" class="right-sidebar-item"><a href="#固定分区分配" class="right-sidebar-item-level4">
          固定分区分配
        </a></li><li id="tab-item6" class="right-sidebar-item"><a href="#动态分区分配" class="right-sidebar-item-level4">
          动态分区分配
        </a></li><li id="tab-item7" class="right-sidebar-item"><a href="#内存非连续分配管理方式" class="right-sidebar-item-level3">
          内存非连续分配管理方式
        </a></li><li id="tab-item8" class="right-sidebar-item"><a href="#基本分页存储管理方式" class="right-sidebar-item-level4">
          基本分页存储管理方式
        </a></li><li id="tab-item9" class="right-sidebar-item"><a href="#基本分段存储管理方式" class="right-sidebar-item-level4">
          基本分段存储管理方式
        </a></li><li id="tab-item10" class="right-sidebar-item"><a href="#段页式管理方式" class="right-sidebar-item-level4">
          段页式管理方式
        </a></li><li id="tab-item11" class="right-sidebar-item"><a href="#_3-2-虚拟内存" class="right-sidebar-item-level2">
          3.2 虚拟内存
        </a></li><li id="tab-item12" class="right-sidebar-item"><a href="#虚拟内存的概念、特征以及虚拟内存的实现" class="right-sidebar-item-level3">
          虚拟内存的概念、特征以及虚拟内存的实现
        </a></li><li id="tab-item13" class="right-sidebar-item"><a href="#请求分页管理方式实现虚拟内存" class="right-sidebar-item-level3">
          请求分页管理方式实现虚拟内存
        </a></li><li id="tab-item14" class="right-sidebar-item"><a href="#页面置换算法" class="right-sidebar-item-level3">
          页面置换算法
        </a></li><li id="tab-item15" class="right-sidebar-item"><a href="#最佳置换算法-opt" class="right-sidebar-item-level4">
          最佳置换算法（OPT）
        </a></li><li id="tab-item16" class="right-sidebar-item"><a href="#先进先出-fifo-页面置换算法" class="right-sidebar-item-level4">
          先进先出（FIFO）页面置换算法
        </a></li><li id="tab-item17" class="right-sidebar-item"><a href="#最近最久未使用-lru-置换算法" class="right-sidebar-item-level4">
          最近最久未使用（LRU）置换算法
        </a></li><li id="tab-item18" class="right-sidebar-item"><a href="#时钟-clock-置换算法" class="right-sidebar-item-level4">
          时钟（CLOCK）置换算法
        </a></li><li id="tab-item19" class="right-sidebar-item"><a href="#页面分配策略" class="right-sidebar-item-level3">
          页面分配策略
        </a></li><li id="tab-item20" class="right-sidebar-item"><a href="#页面抖动和工作集" class="right-sidebar-item-level3">
          页面抖动和工作集
        </a></li></ul></div></aside></div><div class="global-ui"></div></div>
    <script src="/note-pages/assets/js/app.05dcbd87.js" defer></script><script src="/note-pages/assets/js/3.4a2f67fd.js" defer></script><script src="/note-pages/assets/js/2.ab82720e.js" defer></script><script src="/note-pages/assets/js/4.550e6883.js" defer></script>
  </body>
</html>
